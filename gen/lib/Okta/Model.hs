{-
   Okta API

   Allows customers to easily access the Okta API

   OpenAPI Version: 3.0.1
   Okta API API version: 1.0.0
   Contact: devex-public@okta.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Okta.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Okta.Model where

import Okta.Core
import Okta.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AcceptLanguage
newtype AcceptLanguage = AcceptLanguage { unAcceptLanguage :: Text } deriving (P.Eq, P.Show)

-- ** Activate
newtype Activate = Activate { unActivate :: Bool } deriving (P.Eq, P.Show)

-- ** After
newtype After = After { unAfter :: Text } deriving (P.Eq, P.Show)

-- ** AppId
newtype AppId = AppId { unAppId :: Text } deriving (P.Eq, P.Show)

-- ** AppInstanceId
newtype AppInstanceId = AppInstanceId { unAppInstanceId :: Text } deriving (P.Eq, P.Show)

-- ** AppName
newtype AppName = AppName { unAppName :: Text } deriving (P.Eq, P.Show)

-- ** ApplicationId
newtype ApplicationId = ApplicationId { unApplicationId :: Text } deriving (P.Eq, P.Show)

-- ** AssociatedUserId
newtype AssociatedUserId = AssociatedUserId { unAssociatedUserId :: Text } deriving (P.Eq, P.Show)

-- ** AuthServerId
newtype AuthServerId = AuthServerId { unAuthServerId :: Text } deriving (P.Eq, P.Show)

-- ** AuthenticatorId
newtype AuthenticatorId = AuthenticatorId { unAuthenticatorId :: Text } deriving (P.Eq, P.Show)

-- ** BrandId
newtype BrandId = BrandId { unBrandId :: Text } deriving (P.Eq, P.Show)

-- ** ClaimId
newtype ClaimId = ClaimId { unClaimId :: Text } deriving (P.Eq, P.Show)

-- ** ClientId
newtype ClientId = ClientId { unClientId :: Text } deriving (P.Eq, P.Show)

-- ** ContactType
newtype ContactType = ContactType { unContactType :: Text } deriving (P.Eq, P.Show)

-- ** CsrId
newtype CsrId = CsrId { unCsrId :: Text } deriving (P.Eq, P.Show)

-- ** Cursor
newtype Cursor = Cursor { unCursor :: Text } deriving (P.Eq, P.Show)

-- ** CustomizationId
newtype CustomizationId = CustomizationId { unCustomizationId :: Text } deriving (P.Eq, P.Show)

-- ** DisableNotifications
newtype DisableNotifications = DisableNotifications { unDisableNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** DomainId
newtype DomainId = DomainId { unDomainId :: Text } deriving (P.Eq, P.Show)

-- ** EventHookId
newtype EventHookId = EventHookId { unEventHookId :: Text } deriving (P.Eq, P.Show)

-- ** Expand
newtype Expand = Expand { unExpand :: Text } deriving (P.Eq, P.Show)

-- ** FactorId
newtype FactorId = FactorId { unFactorId :: Text } deriving (P.Eq, P.Show)

-- ** FeatureId
newtype FeatureId = FeatureId { unFeatureId :: Text } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** GrantId
newtype GrantId = GrantId { unGrantId :: Text } deriving (P.Eq, P.Show)

-- ** GroupId
newtype GroupId = GroupId { unGroupId :: Text } deriving (P.Eq, P.Show)

-- ** IdpId
newtype IdpId = IdpId { unIdpId :: Text } deriving (P.Eq, P.Show)

-- ** IncludeNonDeleted
newtype IncludeNonDeleted = IncludeNonDeleted { unIncludeNonDeleted :: Bool } deriving (P.Eq, P.Show)

-- ** InlineHookId
newtype InlineHookId = InlineHookId { unInlineHookId :: Text } deriving (P.Eq, P.Show)

-- ** KeyId
newtype KeyId = KeyId { unKeyId :: Text } deriving (P.Eq, P.Show)

-- ** Lifecycle
newtype Lifecycle = Lifecycle { unLifecycle :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** LimitText
newtype LimitText = LimitText { unLimitText :: Text } deriving (P.Eq, P.Show)

-- ** LinkedObjectName
newtype LinkedObjectName = LinkedObjectName { unLinkedObjectName :: Text } deriving (P.Eq, P.Show)

-- ** MappingId
newtype MappingId = MappingId { unMappingId :: Text } deriving (P.Eq, P.Show)

-- ** Mode
newtype Mode = Mode { unMode :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** NextLogin
newtype NextLogin = NextLogin { unNextLogin :: Text } deriving (P.Eq, P.Show)

-- ** NotificationTypeText
newtype NotificationTypeText = NotificationTypeText { unNotificationTypeText :: Text } deriving (P.Eq, P.Show)

-- ** OauthTokens
newtype OauthTokens = OauthTokens { unOauthTokens :: Bool } deriving (P.Eq, P.Show)

-- ** OktaAccessGatewayAgent
newtype OktaAccessGatewayAgent = OktaAccessGatewayAgent { unOktaAccessGatewayAgent :: Text } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: Text } deriving (P.Eq, P.Show)

-- ** PayloadData
newtype PayloadData = PayloadData { unPayloadData :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** PolicyId
newtype PolicyId = PolicyId { unPolicyId :: Text } deriving (P.Eq, P.Show)

-- ** PrimaryRelationshipName
newtype PrimaryRelationshipName = PrimaryRelationshipName { unPrimaryRelationshipName :: Text } deriving (P.Eq, P.Show)

-- ** PrimaryUserId
newtype PrimaryUserId = PrimaryUserId { unPrimaryUserId :: Text } deriving (P.Eq, P.Show)

-- ** Provider
newtype Provider = Provider { unProvider :: Bool } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** QueryScope
newtype QueryScope = QueryScope { unQueryScope :: Text } deriving (P.Eq, P.Show)

-- ** RelationshipName
newtype RelationshipName = RelationshipName { unRelationshipName :: Text } deriving (P.Eq, P.Show)

-- ** RemoveUsers
newtype RemoveUsers = RemoveUsers { unRemoveUsers :: Bool } deriving (P.Eq, P.Show)

-- ** RoleId
newtype RoleId = RoleId { unRoleId :: Text } deriving (P.Eq, P.Show)

-- ** RoleTypeOrRoleId
newtype RoleTypeOrRoleId = RoleTypeOrRoleId { unRoleTypeOrRoleId :: Text } deriving (P.Eq, P.Show)

-- ** RuleId
newtype RuleId = RuleId { unRuleId :: Text } deriving (P.Eq, P.Show)

-- ** SchemaId
newtype SchemaId = SchemaId { unSchemaId :: Text } deriving (P.Eq, P.Show)

-- ** ScopeId
newtype ScopeId = ScopeId { unScopeId :: Text } deriving (P.Eq, P.Show)

-- ** Search
newtype Search = Search { unSearch :: Text } deriving (P.Eq, P.Show)

-- ** SendEmail
newtype SendEmail = SendEmail { unSendEmail :: Bool } deriving (P.Eq, P.Show)

-- ** SessionId
newtype SessionId = SessionId { unSessionId :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: DateTime } deriving (P.Eq, P.Show)

-- ** SortBy
newtype SortBy = SortBy { unSortBy :: Text } deriving (P.Eq, P.Show)

-- ** SortOrder
newtype SortOrder = SortOrder { unSortOrder :: Text } deriving (P.Eq, P.Show)

-- ** SourceId
newtype SourceId = SourceId { unSourceId :: Text } deriving (P.Eq, P.Show)

-- ** Status
newtype Status = Status { unStatus :: Text } deriving (P.Eq, P.Show)

-- ** Strict
newtype Strict = Strict { unStrict :: Bool } deriving (P.Eq, P.Show)

-- ** TargetAid
newtype TargetAid = TargetAid { unTargetAid :: Text } deriving (P.Eq, P.Show)

-- ** TargetGroupId
newtype TargetGroupId = TargetGroupId { unTargetGroupId :: Text } deriving (P.Eq, P.Show)

-- ** TargetId
newtype TargetId = TargetId { unTargetId :: Text } deriving (P.Eq, P.Show)

-- ** TargetIdpId
newtype TargetIdpId = TargetIdpId { unTargetIdpId :: Text } deriving (P.Eq, P.Show)

-- ** TemplateId
newtype TemplateId = TemplateId { unTemplateId :: Text } deriving (P.Eq, P.Show)

-- ** TemplateName
newtype TemplateName = TemplateName { unTemplateName :: Text } deriving (P.Eq, P.Show)

-- ** TemplateType
newtype TemplateType = TemplateType { unTemplateType :: Text } deriving (P.Eq, P.Show)

-- ** ThemeId
newtype ThemeId = ThemeId { unThemeId :: Text } deriving (P.Eq, P.Show)

-- ** TokenId
newtype TokenId = TokenId { unTokenId :: Text } deriving (P.Eq, P.Show)

-- ** TokenLifetimeSeconds
newtype TokenLifetimeSeconds = TokenLifetimeSeconds { unTokenLifetimeSeconds :: Int } deriving (P.Eq, P.Show)

-- ** TransactionId
newtype TransactionId = TransactionId { unTransactionId :: Text } deriving (P.Eq, P.Show)

-- ** TrustedOriginId
newtype TrustedOriginId = TrustedOriginId { unTrustedOriginId :: Text } deriving (P.Eq, P.Show)

-- ** TypeId
newtype TypeId = TypeId { unTypeId :: Text } deriving (P.Eq, P.Show)

-- ** Until
newtype Until = Until { unUntil :: DateTime } deriving (P.Eq, P.Show)

-- ** UpdatePhone
newtype UpdatePhone = UpdatePhone { unUpdatePhone :: Bool } deriving (P.Eq, P.Show)

-- ** UserAgent
newtype UserAgent = UserAgent { unUserAgent :: Text } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Text } deriving (P.Eq, P.Show)

-- ** ValidityYears
newtype ValidityYears = ValidityYears { unValidityYears :: Int } deriving (P.Eq, P.Show)

-- ** XForwardedFor
newtype XForwardedFor = XForwardedFor { unXForwardedFor :: Text } deriving (P.Eq, P.Show)

-- ** ZoneId
newtype ZoneId = ZoneId { unZoneId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AccessPolicyConstraint
-- | AccessPolicyConstraint
data AccessPolicyConstraint = AccessPolicyConstraint
  { accessPolicyConstraintTypes :: !(Maybe [Text]) -- ^ "types"
  , accessPolicyConstraintMethods :: !(Maybe [Text]) -- ^ "methods"
  , accessPolicyConstraintReauthenticateIn :: !(Maybe Text) -- ^ "reauthenticateIn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyConstraint
instance A.FromJSON AccessPolicyConstraint where
  parseJSON = A.withObject "AccessPolicyConstraint" $ \o ->
    AccessPolicyConstraint
      <$> (o .:? "types")
      <*> (o .:? "methods")
      <*> (o .:? "reauthenticateIn")

-- | ToJSON AccessPolicyConstraint
instance A.ToJSON AccessPolicyConstraint where
  toJSON AccessPolicyConstraint {..} =
   _omitNulls
      [ "types" .= accessPolicyConstraintTypes
      , "methods" .= accessPolicyConstraintMethods
      , "reauthenticateIn" .= accessPolicyConstraintReauthenticateIn
      ]


-- | Construct a value of type 'AccessPolicyConstraint' (by applying it's required fields, if any)
mkAccessPolicyConstraint
  :: AccessPolicyConstraint
mkAccessPolicyConstraint =
  AccessPolicyConstraint
  { accessPolicyConstraintTypes = Nothing
  , accessPolicyConstraintMethods = Nothing
  , accessPolicyConstraintReauthenticateIn = Nothing
  }

-- ** AccessPolicyConstraints
-- | AccessPolicyConstraints
data AccessPolicyConstraints = AccessPolicyConstraints
  { accessPolicyConstraintsKnowledge :: !(Maybe A.Value) -- ^ "knowledge"
  , accessPolicyConstraintsPossession :: !(Maybe PossessionConstraint) -- ^ "possession"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyConstraints
instance A.FromJSON AccessPolicyConstraints where
  parseJSON = A.withObject "AccessPolicyConstraints" $ \o ->
    AccessPolicyConstraints
      <$> (o .:? "knowledge")
      <*> (o .:? "possession")

-- | ToJSON AccessPolicyConstraints
instance A.ToJSON AccessPolicyConstraints where
  toJSON AccessPolicyConstraints {..} =
   _omitNulls
      [ "knowledge" .= accessPolicyConstraintsKnowledge
      , "possession" .= accessPolicyConstraintsPossession
      ]


-- | Construct a value of type 'AccessPolicyConstraints' (by applying it's required fields, if any)
mkAccessPolicyConstraints
  :: AccessPolicyConstraints
mkAccessPolicyConstraints =
  AccessPolicyConstraints
  { accessPolicyConstraintsKnowledge = Nothing
  , accessPolicyConstraintsPossession = Nothing
  }

-- ** AccessPolicyRule
-- | AccessPolicyRule
data AccessPolicyRule = AccessPolicyRule
  { accessPolicyRuleActions :: !(Maybe AccessPolicyRuleActions) -- ^ "actions"
  , accessPolicyRuleConditions :: !(Maybe AccessPolicyRuleConditions) -- ^ "conditions"
  , accessPolicyRuleName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyRule
instance A.FromJSON AccessPolicyRule where
  parseJSON = A.withObject "AccessPolicyRule" $ \o ->
    AccessPolicyRule
      <$> (o .:? "actions")
      <*> (o .:? "conditions")
      <*> (o .:? "name")

-- | ToJSON AccessPolicyRule
instance A.ToJSON AccessPolicyRule where
  toJSON AccessPolicyRule {..} =
   _omitNulls
      [ "actions" .= accessPolicyRuleActions
      , "conditions" .= accessPolicyRuleConditions
      , "name" .= accessPolicyRuleName
      ]


-- | Construct a value of type 'AccessPolicyRule' (by applying it's required fields, if any)
mkAccessPolicyRule
  :: AccessPolicyRule
mkAccessPolicyRule =
  AccessPolicyRule
  { accessPolicyRuleActions = Nothing
  , accessPolicyRuleConditions = Nothing
  , accessPolicyRuleName = Nothing
  }

-- ** AccessPolicyRuleActions
-- | AccessPolicyRuleActions
data AccessPolicyRuleActions = AccessPolicyRuleActions
  { accessPolicyRuleActionsAppSignOn :: !(Maybe AccessPolicyRuleApplicationSignOn) -- ^ "appSignOn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyRuleActions
instance A.FromJSON AccessPolicyRuleActions where
  parseJSON = A.withObject "AccessPolicyRuleActions" $ \o ->
    AccessPolicyRuleActions
      <$> (o .:? "appSignOn")

-- | ToJSON AccessPolicyRuleActions
instance A.ToJSON AccessPolicyRuleActions where
  toJSON AccessPolicyRuleActions {..} =
   _omitNulls
      [ "appSignOn" .= accessPolicyRuleActionsAppSignOn
      ]


-- | Construct a value of type 'AccessPolicyRuleActions' (by applying it's required fields, if any)
mkAccessPolicyRuleActions
  :: AccessPolicyRuleActions
mkAccessPolicyRuleActions =
  AccessPolicyRuleActions
  { accessPolicyRuleActionsAppSignOn = Nothing
  }

-- ** AccessPolicyRuleApplicationSignOn
-- | AccessPolicyRuleApplicationSignOn
data AccessPolicyRuleApplicationSignOn = AccessPolicyRuleApplicationSignOn
  { accessPolicyRuleApplicationSignOnAccess :: !(Maybe Text) -- ^ "access"
  , accessPolicyRuleApplicationSignOnVerificationMethod :: !(Maybe VerificationMethod) -- ^ "verificationMethod"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyRuleApplicationSignOn
instance A.FromJSON AccessPolicyRuleApplicationSignOn where
  parseJSON = A.withObject "AccessPolicyRuleApplicationSignOn" $ \o ->
    AccessPolicyRuleApplicationSignOn
      <$> (o .:? "access")
      <*> (o .:? "verificationMethod")

-- | ToJSON AccessPolicyRuleApplicationSignOn
instance A.ToJSON AccessPolicyRuleApplicationSignOn where
  toJSON AccessPolicyRuleApplicationSignOn {..} =
   _omitNulls
      [ "access" .= accessPolicyRuleApplicationSignOnAccess
      , "verificationMethod" .= accessPolicyRuleApplicationSignOnVerificationMethod
      ]


-- | Construct a value of type 'AccessPolicyRuleApplicationSignOn' (by applying it's required fields, if any)
mkAccessPolicyRuleApplicationSignOn
  :: AccessPolicyRuleApplicationSignOn
mkAccessPolicyRuleApplicationSignOn =
  AccessPolicyRuleApplicationSignOn
  { accessPolicyRuleApplicationSignOnAccess = Nothing
  , accessPolicyRuleApplicationSignOnVerificationMethod = Nothing
  }

-- ** AccessPolicyRuleConditions
-- | AccessPolicyRuleConditions
data AccessPolicyRuleConditions = AccessPolicyRuleConditions
  { accessPolicyRuleConditionsUserType :: !(Maybe UserTypeCondition) -- ^ "userType"
  , accessPolicyRuleConditionsElCondition :: !(Maybe AccessPolicyRuleCustomCondition) -- ^ "elCondition"
  , accessPolicyRuleConditionsDevice :: !(Maybe DeviceAccessPolicyRuleCondition) -- ^ "device"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyRuleConditions
instance A.FromJSON AccessPolicyRuleConditions where
  parseJSON = A.withObject "AccessPolicyRuleConditions" $ \o ->
    AccessPolicyRuleConditions
      <$> (o .:? "userType")
      <*> (o .:? "elCondition")
      <*> (o .:? "device")

-- | ToJSON AccessPolicyRuleConditions
instance A.ToJSON AccessPolicyRuleConditions where
  toJSON AccessPolicyRuleConditions {..} =
   _omitNulls
      [ "userType" .= accessPolicyRuleConditionsUserType
      , "elCondition" .= accessPolicyRuleConditionsElCondition
      , "device" .= accessPolicyRuleConditionsDevice
      ]


-- | Construct a value of type 'AccessPolicyRuleConditions' (by applying it's required fields, if any)
mkAccessPolicyRuleConditions
  :: AccessPolicyRuleConditions
mkAccessPolicyRuleConditions =
  AccessPolicyRuleConditions
  { accessPolicyRuleConditionsUserType = Nothing
  , accessPolicyRuleConditionsElCondition = Nothing
  , accessPolicyRuleConditionsDevice = Nothing
  }

-- ** AccessPolicyRuleCustomCondition
-- | AccessPolicyRuleCustomCondition
data AccessPolicyRuleCustomCondition = AccessPolicyRuleCustomCondition
  { accessPolicyRuleCustomConditionCondition :: !(Maybe Text) -- ^ "condition"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccessPolicyRuleCustomCondition
instance A.FromJSON AccessPolicyRuleCustomCondition where
  parseJSON = A.withObject "AccessPolicyRuleCustomCondition" $ \o ->
    AccessPolicyRuleCustomCondition
      <$> (o .:? "condition")

-- | ToJSON AccessPolicyRuleCustomCondition
instance A.ToJSON AccessPolicyRuleCustomCondition where
  toJSON AccessPolicyRuleCustomCondition {..} =
   _omitNulls
      [ "condition" .= accessPolicyRuleCustomConditionCondition
      ]


-- | Construct a value of type 'AccessPolicyRuleCustomCondition' (by applying it's required fields, if any)
mkAccessPolicyRuleCustomCondition
  :: AccessPolicyRuleCustomCondition
mkAccessPolicyRuleCustomCondition =
  AccessPolicyRuleCustomCondition
  { accessPolicyRuleCustomConditionCondition = Nothing
  }

-- ** AcsEndpoint
-- | AcsEndpoint
data AcsEndpoint = AcsEndpoint
  { acsEndpointUrl :: !(Maybe Text) -- ^ "url"
  , acsEndpointIndex :: !(Maybe Int) -- ^ "index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AcsEndpoint
instance A.FromJSON AcsEndpoint where
  parseJSON = A.withObject "AcsEndpoint" $ \o ->
    AcsEndpoint
      <$> (o .:? "url")
      <*> (o .:? "index")

-- | ToJSON AcsEndpoint
instance A.ToJSON AcsEndpoint where
  toJSON AcsEndpoint {..} =
   _omitNulls
      [ "url" .= acsEndpointUrl
      , "index" .= acsEndpointIndex
      ]


-- | Construct a value of type 'AcsEndpoint' (by applying it's required fields, if any)
mkAcsEndpoint
  :: AcsEndpoint
mkAcsEndpoint =
  AcsEndpoint
  { acsEndpointUrl = Nothing
  , acsEndpointIndex = Nothing
  }

-- ** ActivateFactorRequest
-- | ActivateFactorRequest
data ActivateFactorRequest = ActivateFactorRequest
  { activateFactorRequestAttestation :: !(Maybe Text) -- ^ "attestation"
  , activateFactorRequestClientData :: !(Maybe Text) -- ^ "clientData"
  , activateFactorRequestPassCode :: !(Maybe Text) -- ^ "passCode"
  , activateFactorRequestRegistrationData :: !(Maybe Text) -- ^ "registrationData"
  , activateFactorRequestStateToken :: !(Maybe Text) -- ^ "stateToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ActivateFactorRequest
instance A.FromJSON ActivateFactorRequest where
  parseJSON = A.withObject "ActivateFactorRequest" $ \o ->
    ActivateFactorRequest
      <$> (o .:? "attestation")
      <*> (o .:? "clientData")
      <*> (o .:? "passCode")
      <*> (o .:? "registrationData")
      <*> (o .:? "stateToken")

-- | ToJSON ActivateFactorRequest
instance A.ToJSON ActivateFactorRequest where
  toJSON ActivateFactorRequest {..} =
   _omitNulls
      [ "attestation" .= activateFactorRequestAttestation
      , "clientData" .= activateFactorRequestClientData
      , "passCode" .= activateFactorRequestPassCode
      , "registrationData" .= activateFactorRequestRegistrationData
      , "stateToken" .= activateFactorRequestStateToken
      ]


-- | Construct a value of type 'ActivateFactorRequest' (by applying it's required fields, if any)
mkActivateFactorRequest
  :: ActivateFactorRequest
mkActivateFactorRequest =
  ActivateFactorRequest
  { activateFactorRequestAttestation = Nothing
  , activateFactorRequestClientData = Nothing
  , activateFactorRequestPassCode = Nothing
  , activateFactorRequestRegistrationData = Nothing
  , activateFactorRequestStateToken = Nothing
  }

-- ** AppAndInstanceConditionEvaluatorAppOrInstance
-- | AppAndInstanceConditionEvaluatorAppOrInstance
data AppAndInstanceConditionEvaluatorAppOrInstance = AppAndInstanceConditionEvaluatorAppOrInstance
  { appAndInstanceConditionEvaluatorAppOrInstanceId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , appAndInstanceConditionEvaluatorAppOrInstanceName :: !(Maybe Text) -- ^ "name"
  , appAndInstanceConditionEvaluatorAppOrInstanceType :: !(Maybe E'Type) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppAndInstanceConditionEvaluatorAppOrInstance
instance A.FromJSON AppAndInstanceConditionEvaluatorAppOrInstance where
  parseJSON = A.withObject "AppAndInstanceConditionEvaluatorAppOrInstance" $ \o ->
    AppAndInstanceConditionEvaluatorAppOrInstance
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON AppAndInstanceConditionEvaluatorAppOrInstance
instance A.ToJSON AppAndInstanceConditionEvaluatorAppOrInstance where
  toJSON AppAndInstanceConditionEvaluatorAppOrInstance {..} =
   _omitNulls
      [ "id" .= appAndInstanceConditionEvaluatorAppOrInstanceId
      , "name" .= appAndInstanceConditionEvaluatorAppOrInstanceName
      , "type" .= appAndInstanceConditionEvaluatorAppOrInstanceType
      ]


-- | Construct a value of type 'AppAndInstanceConditionEvaluatorAppOrInstance' (by applying it's required fields, if any)
mkAppAndInstanceConditionEvaluatorAppOrInstance
  :: AppAndInstanceConditionEvaluatorAppOrInstance
mkAppAndInstanceConditionEvaluatorAppOrInstance =
  AppAndInstanceConditionEvaluatorAppOrInstance
  { appAndInstanceConditionEvaluatorAppOrInstanceId = Nothing
  , appAndInstanceConditionEvaluatorAppOrInstanceName = Nothing
  , appAndInstanceConditionEvaluatorAppOrInstanceType = Nothing
  }

-- ** AppAndInstancePolicyRuleCondition
-- | AppAndInstancePolicyRuleCondition
data AppAndInstancePolicyRuleCondition = AppAndInstancePolicyRuleCondition
  { appAndInstancePolicyRuleConditionExclude :: !(Maybe [AppAndInstanceConditionEvaluatorAppOrInstance]) -- ^ "exclude"
  , appAndInstancePolicyRuleConditionInclude :: !(Maybe [AppAndInstanceConditionEvaluatorAppOrInstance]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppAndInstancePolicyRuleCondition
instance A.FromJSON AppAndInstancePolicyRuleCondition where
  parseJSON = A.withObject "AppAndInstancePolicyRuleCondition" $ \o ->
    AppAndInstancePolicyRuleCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON AppAndInstancePolicyRuleCondition
instance A.ToJSON AppAndInstancePolicyRuleCondition where
  toJSON AppAndInstancePolicyRuleCondition {..} =
   _omitNulls
      [ "exclude" .= appAndInstancePolicyRuleConditionExclude
      , "include" .= appAndInstancePolicyRuleConditionInclude
      ]


-- | Construct a value of type 'AppAndInstancePolicyRuleCondition' (by applying it's required fields, if any)
mkAppAndInstancePolicyRuleCondition
  :: AppAndInstancePolicyRuleCondition
mkAppAndInstancePolicyRuleCondition =
  AppAndInstancePolicyRuleCondition
  { appAndInstancePolicyRuleConditionExclude = Nothing
  , appAndInstancePolicyRuleConditionInclude = Nothing
  }

-- ** AppInstancePolicyRuleCondition
-- | AppInstancePolicyRuleCondition
data AppInstancePolicyRuleCondition = AppInstancePolicyRuleCondition
  { appInstancePolicyRuleConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , appInstancePolicyRuleConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppInstancePolicyRuleCondition
instance A.FromJSON AppInstancePolicyRuleCondition where
  parseJSON = A.withObject "AppInstancePolicyRuleCondition" $ \o ->
    AppInstancePolicyRuleCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON AppInstancePolicyRuleCondition
instance A.ToJSON AppInstancePolicyRuleCondition where
  toJSON AppInstancePolicyRuleCondition {..} =
   _omitNulls
      [ "exclude" .= appInstancePolicyRuleConditionExclude
      , "include" .= appInstancePolicyRuleConditionInclude
      ]


-- | Construct a value of type 'AppInstancePolicyRuleCondition' (by applying it's required fields, if any)
mkAppInstancePolicyRuleCondition
  :: AppInstancePolicyRuleCondition
mkAppInstancePolicyRuleCondition =
  AppInstancePolicyRuleCondition
  { appInstancePolicyRuleConditionExclude = Nothing
  , appInstancePolicyRuleConditionInclude = Nothing
  }

-- ** AppLink
-- | AppLink
data AppLink = AppLink
  { appLinkAppAssignmentId :: !(Maybe Text) -- ^ /ReadOnly/ "appAssignmentId"
  , appLinkAppInstanceId :: !(Maybe Text) -- ^ /ReadOnly/ "appInstanceId"
  , appLinkAppName :: !(Maybe Text) -- ^ /ReadOnly/ "appName"
  , appLinkCredentialsSetup :: !(Maybe Bool) -- ^ /ReadOnly/ "credentialsSetup"
  , appLinkHidden :: !(Maybe Bool) -- ^ /ReadOnly/ "hidden"
  , appLinkId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , appLinkLabel :: !(Maybe Text) -- ^ /ReadOnly/ "label"
  , appLinkLinkUrl :: !(Maybe Text) -- ^ /ReadOnly/ "linkUrl"
  , appLinkLogoUrl :: !(Maybe Text) -- ^ /ReadOnly/ "logoUrl"
  , appLinkSortOrder :: !(Maybe Int) -- ^ /ReadOnly/ "sortOrder"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppLink
instance A.FromJSON AppLink where
  parseJSON = A.withObject "AppLink" $ \o ->
    AppLink
      <$> (o .:? "appAssignmentId")
      <*> (o .:? "appInstanceId")
      <*> (o .:? "appName")
      <*> (o .:? "credentialsSetup")
      <*> (o .:? "hidden")
      <*> (o .:? "id")
      <*> (o .:? "label")
      <*> (o .:? "linkUrl")
      <*> (o .:? "logoUrl")
      <*> (o .:? "sortOrder")

-- | ToJSON AppLink
instance A.ToJSON AppLink where
  toJSON AppLink {..} =
   _omitNulls
      [ "appAssignmentId" .= appLinkAppAssignmentId
      , "appInstanceId" .= appLinkAppInstanceId
      , "appName" .= appLinkAppName
      , "credentialsSetup" .= appLinkCredentialsSetup
      , "hidden" .= appLinkHidden
      , "id" .= appLinkId
      , "label" .= appLinkLabel
      , "linkUrl" .= appLinkLinkUrl
      , "logoUrl" .= appLinkLogoUrl
      , "sortOrder" .= appLinkSortOrder
      ]


-- | Construct a value of type 'AppLink' (by applying it's required fields, if any)
mkAppLink
  :: AppLink
mkAppLink =
  AppLink
  { appLinkAppAssignmentId = Nothing
  , appLinkAppInstanceId = Nothing
  , appLinkAppName = Nothing
  , appLinkCredentialsSetup = Nothing
  , appLinkHidden = Nothing
  , appLinkId = Nothing
  , appLinkLabel = Nothing
  , appLinkLinkUrl = Nothing
  , appLinkLogoUrl = Nothing
  , appLinkSortOrder = Nothing
  }

-- ** AppUser
-- | AppUser
data AppUser = AppUser
  { appUserEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , appUserLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , appUserCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , appUserCredentials :: !(Maybe AppUserCredentials) -- ^ "credentials"
  , appUserExternalId :: !(Maybe Text) -- ^ /ReadOnly/ "externalId"
  , appUserId :: !(Maybe Text) -- ^ "id"
  , appUserLastSync :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastSync"
  , appUserLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , appUserPasswordChanged :: !(Maybe DateTime) -- ^ /ReadOnly/ "passwordChanged"
  , appUserProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  , appUserScope :: !(Maybe Text) -- ^ "scope"
  , appUserStatus :: !(Maybe Text) -- ^ /ReadOnly/ "status"
  , appUserStatusChanged :: !(Maybe DateTime) -- ^ /ReadOnly/ "statusChanged"
  , appUserSyncState :: !(Maybe Text) -- ^ /ReadOnly/ "syncState"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppUser
instance A.FromJSON AppUser where
  parseJSON = A.withObject "AppUser" $ \o ->
    AppUser
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "externalId")
      <*> (o .:? "id")
      <*> (o .:? "lastSync")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "passwordChanged")
      <*> (o .:? "profile")
      <*> (o .:? "scope")
      <*> (o .:? "status")
      <*> (o .:? "statusChanged")
      <*> (o .:? "syncState")

-- | ToJSON AppUser
instance A.ToJSON AppUser where
  toJSON AppUser {..} =
   _omitNulls
      [ "_embedded" .= appUserEmbedded
      , "_links" .= appUserLinks
      , "created" .= appUserCreated
      , "credentials" .= appUserCredentials
      , "externalId" .= appUserExternalId
      , "id" .= appUserId
      , "lastSync" .= appUserLastSync
      , "lastUpdated" .= appUserLastUpdated
      , "passwordChanged" .= appUserPasswordChanged
      , "profile" .= appUserProfile
      , "scope" .= appUserScope
      , "status" .= appUserStatus
      , "statusChanged" .= appUserStatusChanged
      , "syncState" .= appUserSyncState
      ]


-- | Construct a value of type 'AppUser' (by applying it's required fields, if any)
mkAppUser
  :: AppUser
mkAppUser =
  AppUser
  { appUserEmbedded = Nothing
  , appUserLinks = Nothing
  , appUserCreated = Nothing
  , appUserCredentials = Nothing
  , appUserExternalId = Nothing
  , appUserId = Nothing
  , appUserLastSync = Nothing
  , appUserLastUpdated = Nothing
  , appUserPasswordChanged = Nothing
  , appUserProfile = Nothing
  , appUserScope = Nothing
  , appUserStatus = Nothing
  , appUserStatusChanged = Nothing
  , appUserSyncState = Nothing
  }

-- ** AppUserCredentials
-- | AppUserCredentials
data AppUserCredentials = AppUserCredentials
  { appUserCredentialsPassword :: !(Maybe AppUserPasswordCredential) -- ^ "password"
  , appUserCredentialsUserName :: !(Maybe Text) -- ^ "userName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppUserCredentials
instance A.FromJSON AppUserCredentials where
  parseJSON = A.withObject "AppUserCredentials" $ \o ->
    AppUserCredentials
      <$> (o .:? "password")
      <*> (o .:? "userName")

-- | ToJSON AppUserCredentials
instance A.ToJSON AppUserCredentials where
  toJSON AppUserCredentials {..} =
   _omitNulls
      [ "password" .= appUserCredentialsPassword
      , "userName" .= appUserCredentialsUserName
      ]


-- | Construct a value of type 'AppUserCredentials' (by applying it's required fields, if any)
mkAppUserCredentials
  :: AppUserCredentials
mkAppUserCredentials =
  AppUserCredentials
  { appUserCredentialsPassword = Nothing
  , appUserCredentialsUserName = Nothing
  }

-- ** AppUserPasswordCredential
-- | AppUserPasswordCredential
data AppUserPasswordCredential = AppUserPasswordCredential
  { appUserPasswordCredentialValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppUserPasswordCredential
instance A.FromJSON AppUserPasswordCredential where
  parseJSON = A.withObject "AppUserPasswordCredential" $ \o ->
    AppUserPasswordCredential
      <$> (o .:? "value")

-- | ToJSON AppUserPasswordCredential
instance A.ToJSON AppUserPasswordCredential where
  toJSON AppUserPasswordCredential {..} =
   _omitNulls
      [ "value" .= appUserPasswordCredentialValue
      ]


-- | Construct a value of type 'AppUserPasswordCredential' (by applying it's required fields, if any)
mkAppUserPasswordCredential
  :: AppUserPasswordCredential
mkAppUserPasswordCredential =
  AppUserPasswordCredential
  { appUserPasswordCredentialValue = Nothing
  }

-- ** Application
-- | Application
data Application = Application
  { applicationEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , applicationLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , applicationAccessibility :: !(Maybe ApplicationAccessibility) -- ^ "accessibility"
  , applicationCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , applicationCredentials :: !(Maybe ApplicationCredentials) -- ^ "credentials"
  , applicationFeatures :: !(Maybe [Text]) -- ^ "features"
  , applicationId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , applicationLabel :: !(Maybe Text) -- ^ "label"
  , applicationLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , applicationLicensing :: !(Maybe ApplicationLicensing) -- ^ "licensing"
  , applicationName :: !(Maybe Text) -- ^ /ReadOnly/ "name"
  , applicationProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  , applicationSettings :: !(Maybe ApplicationSettings) -- ^ "settings"
  , applicationSignOnMode :: !(Maybe ApplicationSignOnMode) -- ^ "signOnMode"
  , applicationStatus :: !(Maybe E'Status) -- ^ /ReadOnly/ "status"
  , applicationVisibility :: !(Maybe ApplicationVisibility) -- ^ "visibility"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Application
instance A.FromJSON Application where
  parseJSON = A.withObject "Application" $ \o ->
    Application
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "accessibility")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "features")
      <*> (o .:? "id")
      <*> (o .:? "label")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "licensing")
      <*> (o .:? "name")
      <*> (o .:? "profile")
      <*> (o .:? "settings")
      <*> (o .:? "signOnMode")
      <*> (o .:? "status")
      <*> (o .:? "visibility")

-- | ToJSON Application
instance A.ToJSON Application where
  toJSON Application {..} =
   _omitNulls
      [ "_embedded" .= applicationEmbedded
      , "_links" .= applicationLinks
      , "accessibility" .= applicationAccessibility
      , "created" .= applicationCreated
      , "credentials" .= applicationCredentials
      , "features" .= applicationFeatures
      , "id" .= applicationId
      , "label" .= applicationLabel
      , "lastUpdated" .= applicationLastUpdated
      , "licensing" .= applicationLicensing
      , "name" .= applicationName
      , "profile" .= applicationProfile
      , "settings" .= applicationSettings
      , "signOnMode" .= applicationSignOnMode
      , "status" .= applicationStatus
      , "visibility" .= applicationVisibility
      ]


-- | Construct a value of type 'Application' (by applying it's required fields, if any)
mkApplication
  :: Application
mkApplication =
  Application
  { applicationEmbedded = Nothing
  , applicationLinks = Nothing
  , applicationAccessibility = Nothing
  , applicationCreated = Nothing
  , applicationCredentials = Nothing
  , applicationFeatures = Nothing
  , applicationId = Nothing
  , applicationLabel = Nothing
  , applicationLastUpdated = Nothing
  , applicationLicensing = Nothing
  , applicationName = Nothing
  , applicationProfile = Nothing
  , applicationSettings = Nothing
  , applicationSignOnMode = Nothing
  , applicationStatus = Nothing
  , applicationVisibility = Nothing
  }

-- ** ApplicationAccessibility
-- | ApplicationAccessibility
data ApplicationAccessibility = ApplicationAccessibility
  { applicationAccessibilityErrorRedirectUrl :: !(Maybe Text) -- ^ "errorRedirectUrl"
  , applicationAccessibilityLoginRedirectUrl :: !(Maybe Text) -- ^ "loginRedirectUrl"
  , applicationAccessibilitySelfService :: !(Maybe Bool) -- ^ "selfService"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationAccessibility
instance A.FromJSON ApplicationAccessibility where
  parseJSON = A.withObject "ApplicationAccessibility" $ \o ->
    ApplicationAccessibility
      <$> (o .:? "errorRedirectUrl")
      <*> (o .:? "loginRedirectUrl")
      <*> (o .:? "selfService")

-- | ToJSON ApplicationAccessibility
instance A.ToJSON ApplicationAccessibility where
  toJSON ApplicationAccessibility {..} =
   _omitNulls
      [ "errorRedirectUrl" .= applicationAccessibilityErrorRedirectUrl
      , "loginRedirectUrl" .= applicationAccessibilityLoginRedirectUrl
      , "selfService" .= applicationAccessibilitySelfService
      ]


-- | Construct a value of type 'ApplicationAccessibility' (by applying it's required fields, if any)
mkApplicationAccessibility
  :: ApplicationAccessibility
mkApplicationAccessibility =
  ApplicationAccessibility
  { applicationAccessibilityErrorRedirectUrl = Nothing
  , applicationAccessibilityLoginRedirectUrl = Nothing
  , applicationAccessibilitySelfService = Nothing
  }

-- ** ApplicationCredentials
-- | ApplicationCredentials
data ApplicationCredentials = ApplicationCredentials
  { applicationCredentialsSigning :: !(Maybe ApplicationCredentialsSigning) -- ^ "signing"
  , applicationCredentialsUserNameTemplate :: !(Maybe ApplicationCredentialsUsernameTemplate) -- ^ "userNameTemplate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentials
instance A.FromJSON ApplicationCredentials where
  parseJSON = A.withObject "ApplicationCredentials" $ \o ->
    ApplicationCredentials
      <$> (o .:? "signing")
      <*> (o .:? "userNameTemplate")

-- | ToJSON ApplicationCredentials
instance A.ToJSON ApplicationCredentials where
  toJSON ApplicationCredentials {..} =
   _omitNulls
      [ "signing" .= applicationCredentialsSigning
      , "userNameTemplate" .= applicationCredentialsUserNameTemplate
      ]


-- | Construct a value of type 'ApplicationCredentials' (by applying it's required fields, if any)
mkApplicationCredentials
  :: ApplicationCredentials
mkApplicationCredentials =
  ApplicationCredentials
  { applicationCredentialsSigning = Nothing
  , applicationCredentialsUserNameTemplate = Nothing
  }

-- ** ApplicationCredentialsOAuthClient
-- | ApplicationCredentialsOAuthClient
data ApplicationCredentialsOAuthClient = ApplicationCredentialsOAuthClient
  { applicationCredentialsOAuthClientAutoKeyRotation :: !(Maybe Bool) -- ^ "autoKeyRotation"
  , applicationCredentialsOAuthClientClientId :: !(Maybe Text) -- ^ "client_id"
  , applicationCredentialsOAuthClientClientSecret :: !(Maybe Text) -- ^ "client_secret"
  , applicationCredentialsOAuthClientTokenEndpointAuthMethod :: !(Maybe OAuthEndpointAuthenticationMethod) -- ^ "token_endpoint_auth_method"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentialsOAuthClient
instance A.FromJSON ApplicationCredentialsOAuthClient where
  parseJSON = A.withObject "ApplicationCredentialsOAuthClient" $ \o ->
    ApplicationCredentialsOAuthClient
      <$> (o .:? "autoKeyRotation")
      <*> (o .:? "client_id")
      <*> (o .:? "client_secret")
      <*> (o .:? "token_endpoint_auth_method")

-- | ToJSON ApplicationCredentialsOAuthClient
instance A.ToJSON ApplicationCredentialsOAuthClient where
  toJSON ApplicationCredentialsOAuthClient {..} =
   _omitNulls
      [ "autoKeyRotation" .= applicationCredentialsOAuthClientAutoKeyRotation
      , "client_id" .= applicationCredentialsOAuthClientClientId
      , "client_secret" .= applicationCredentialsOAuthClientClientSecret
      , "token_endpoint_auth_method" .= applicationCredentialsOAuthClientTokenEndpointAuthMethod
      ]


-- | Construct a value of type 'ApplicationCredentialsOAuthClient' (by applying it's required fields, if any)
mkApplicationCredentialsOAuthClient
  :: ApplicationCredentialsOAuthClient
mkApplicationCredentialsOAuthClient =
  ApplicationCredentialsOAuthClient
  { applicationCredentialsOAuthClientAutoKeyRotation = Nothing
  , applicationCredentialsOAuthClientClientId = Nothing
  , applicationCredentialsOAuthClientClientSecret = Nothing
  , applicationCredentialsOAuthClientTokenEndpointAuthMethod = Nothing
  }

-- ** ApplicationCredentialsSigning
-- | ApplicationCredentialsSigning
data ApplicationCredentialsSigning = ApplicationCredentialsSigning
  { applicationCredentialsSigningKid :: !(Maybe Text) -- ^ "kid"
  , applicationCredentialsSigningLastRotated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastRotated"
  , applicationCredentialsSigningNextRotation :: !(Maybe DateTime) -- ^ /ReadOnly/ "nextRotation"
  , applicationCredentialsSigningRotationMode :: !(Maybe Text) -- ^ "rotationMode"
  , applicationCredentialsSigningUse :: !(Maybe ApplicationCredentialsSigningUse) -- ^ "use"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentialsSigning
instance A.FromJSON ApplicationCredentialsSigning where
  parseJSON = A.withObject "ApplicationCredentialsSigning" $ \o ->
    ApplicationCredentialsSigning
      <$> (o .:? "kid")
      <*> (o .:? "lastRotated")
      <*> (o .:? "nextRotation")
      <*> (o .:? "rotationMode")
      <*> (o .:? "use")

-- | ToJSON ApplicationCredentialsSigning
instance A.ToJSON ApplicationCredentialsSigning where
  toJSON ApplicationCredentialsSigning {..} =
   _omitNulls
      [ "kid" .= applicationCredentialsSigningKid
      , "lastRotated" .= applicationCredentialsSigningLastRotated
      , "nextRotation" .= applicationCredentialsSigningNextRotation
      , "rotationMode" .= applicationCredentialsSigningRotationMode
      , "use" .= applicationCredentialsSigningUse
      ]


-- | Construct a value of type 'ApplicationCredentialsSigning' (by applying it's required fields, if any)
mkApplicationCredentialsSigning
  :: ApplicationCredentialsSigning
mkApplicationCredentialsSigning =
  ApplicationCredentialsSigning
  { applicationCredentialsSigningKid = Nothing
  , applicationCredentialsSigningLastRotated = Nothing
  , applicationCredentialsSigningNextRotation = Nothing
  , applicationCredentialsSigningRotationMode = Nothing
  , applicationCredentialsSigningUse = Nothing
  }

-- ** ApplicationCredentialsUsernameTemplate
-- | ApplicationCredentialsUsernameTemplate
data ApplicationCredentialsUsernameTemplate = ApplicationCredentialsUsernameTemplate
  { applicationCredentialsUsernameTemplateSuffix :: !(Maybe Text) -- ^ "suffix"
  , applicationCredentialsUsernameTemplateTemplate :: !(Maybe Text) -- ^ "template"
  , applicationCredentialsUsernameTemplateType :: !(Maybe Text) -- ^ "type"
  , applicationCredentialsUsernameTemplatePushStatus :: !(Maybe Text) -- ^ "pushStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentialsUsernameTemplate
instance A.FromJSON ApplicationCredentialsUsernameTemplate where
  parseJSON = A.withObject "ApplicationCredentialsUsernameTemplate" $ \o ->
    ApplicationCredentialsUsernameTemplate
      <$> (o .:? "suffix")
      <*> (o .:? "template")
      <*> (o .:? "type")
      <*> (o .:? "pushStatus")

-- | ToJSON ApplicationCredentialsUsernameTemplate
instance A.ToJSON ApplicationCredentialsUsernameTemplate where
  toJSON ApplicationCredentialsUsernameTemplate {..} =
   _omitNulls
      [ "suffix" .= applicationCredentialsUsernameTemplateSuffix
      , "template" .= applicationCredentialsUsernameTemplateTemplate
      , "type" .= applicationCredentialsUsernameTemplateType
      , "pushStatus" .= applicationCredentialsUsernameTemplatePushStatus
      ]


-- | Construct a value of type 'ApplicationCredentialsUsernameTemplate' (by applying it's required fields, if any)
mkApplicationCredentialsUsernameTemplate
  :: ApplicationCredentialsUsernameTemplate
mkApplicationCredentialsUsernameTemplate =
  ApplicationCredentialsUsernameTemplate
  { applicationCredentialsUsernameTemplateSuffix = Nothing
  , applicationCredentialsUsernameTemplateTemplate = Nothing
  , applicationCredentialsUsernameTemplateType = Nothing
  , applicationCredentialsUsernameTemplatePushStatus = Nothing
  }

-- ** ApplicationFeature
-- | ApplicationFeature
data ApplicationFeature = ApplicationFeature
  { applicationFeatureCapabilities :: !(Maybe CapabilitiesObject) -- ^ "capabilities"
  , applicationFeatureDescription :: !(Maybe Text) -- ^ "description"
  , applicationFeatureLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , applicationFeatureName :: !(Maybe Text) -- ^ "name"
  , applicationFeatureStatus :: !(Maybe EnabledStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationFeature
instance A.FromJSON ApplicationFeature where
  parseJSON = A.withObject "ApplicationFeature" $ \o ->
    ApplicationFeature
      <$> (o .:? "capabilities")
      <*> (o .:? "description")
      <*> (o .:? "_links")
      <*> (o .:? "name")
      <*> (o .:? "status")

-- | ToJSON ApplicationFeature
instance A.ToJSON ApplicationFeature where
  toJSON ApplicationFeature {..} =
   _omitNulls
      [ "capabilities" .= applicationFeatureCapabilities
      , "description" .= applicationFeatureDescription
      , "_links" .= applicationFeatureLinks
      , "name" .= applicationFeatureName
      , "status" .= applicationFeatureStatus
      ]


-- | Construct a value of type 'ApplicationFeature' (by applying it's required fields, if any)
mkApplicationFeature
  :: ApplicationFeature
mkApplicationFeature =
  ApplicationFeature
  { applicationFeatureCapabilities = Nothing
  , applicationFeatureDescription = Nothing
  , applicationFeatureLinks = Nothing
  , applicationFeatureName = Nothing
  , applicationFeatureStatus = Nothing
  }

-- ** ApplicationGroupAssignment
-- | ApplicationGroupAssignment
data ApplicationGroupAssignment = ApplicationGroupAssignment
  { applicationGroupAssignmentEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , applicationGroupAssignmentLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , applicationGroupAssignmentId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , applicationGroupAssignmentLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , applicationGroupAssignmentPriority :: !(Maybe Int) -- ^ "priority"
  , applicationGroupAssignmentProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationGroupAssignment
instance A.FromJSON ApplicationGroupAssignment where
  parseJSON = A.withObject "ApplicationGroupAssignment" $ \o ->
    ApplicationGroupAssignment
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "priority")
      <*> (o .:? "profile")

-- | ToJSON ApplicationGroupAssignment
instance A.ToJSON ApplicationGroupAssignment where
  toJSON ApplicationGroupAssignment {..} =
   _omitNulls
      [ "_embedded" .= applicationGroupAssignmentEmbedded
      , "_links" .= applicationGroupAssignmentLinks
      , "id" .= applicationGroupAssignmentId
      , "lastUpdated" .= applicationGroupAssignmentLastUpdated
      , "priority" .= applicationGroupAssignmentPriority
      , "profile" .= applicationGroupAssignmentProfile
      ]


-- | Construct a value of type 'ApplicationGroupAssignment' (by applying it's required fields, if any)
mkApplicationGroupAssignment
  :: ApplicationGroupAssignment
mkApplicationGroupAssignment =
  ApplicationGroupAssignment
  { applicationGroupAssignmentEmbedded = Nothing
  , applicationGroupAssignmentLinks = Nothing
  , applicationGroupAssignmentId = Nothing
  , applicationGroupAssignmentLastUpdated = Nothing
  , applicationGroupAssignmentPriority = Nothing
  , applicationGroupAssignmentProfile = Nothing
  }

-- ** ApplicationLicensing
-- | ApplicationLicensing
data ApplicationLicensing = ApplicationLicensing
  { applicationLicensingSeatCount :: !(Maybe Int) -- ^ "seatCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationLicensing
instance A.FromJSON ApplicationLicensing where
  parseJSON = A.withObject "ApplicationLicensing" $ \o ->
    ApplicationLicensing
      <$> (o .:? "seatCount")

-- | ToJSON ApplicationLicensing
instance A.ToJSON ApplicationLicensing where
  toJSON ApplicationLicensing {..} =
   _omitNulls
      [ "seatCount" .= applicationLicensingSeatCount
      ]


-- | Construct a value of type 'ApplicationLicensing' (by applying it's required fields, if any)
mkApplicationLicensing
  :: ApplicationLicensing
mkApplicationLicensing =
  ApplicationLicensing
  { applicationLicensingSeatCount = Nothing
  }

-- ** ApplicationSettings
-- | ApplicationSettings
data ApplicationSettings = ApplicationSettings
  { applicationSettingsApp :: !(Maybe A.Value) -- ^ "app"
  , applicationSettingsImplicitAssignment :: !(Maybe Bool) -- ^ "implicitAssignment"
  , applicationSettingsInlineHookId :: !(Maybe Text) -- ^ "inlineHookId"
  , applicationSettingsNotifications :: !(Maybe ApplicationSettingsNotifications) -- ^ "notifications"
  , applicationSettingsNotes :: !(Maybe ApplicationSettingsNotes) -- ^ "notes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettings
instance A.FromJSON ApplicationSettings where
  parseJSON = A.withObject "ApplicationSettings" $ \o ->
    ApplicationSettings
      <$> (o .:? "app")
      <*> (o .:? "implicitAssignment")
      <*> (o .:? "inlineHookId")
      <*> (o .:? "notifications")
      <*> (o .:? "notes")

-- | ToJSON ApplicationSettings
instance A.ToJSON ApplicationSettings where
  toJSON ApplicationSettings {..} =
   _omitNulls
      [ "app" .= applicationSettingsApp
      , "implicitAssignment" .= applicationSettingsImplicitAssignment
      , "inlineHookId" .= applicationSettingsInlineHookId
      , "notifications" .= applicationSettingsNotifications
      , "notes" .= applicationSettingsNotes
      ]


-- | Construct a value of type 'ApplicationSettings' (by applying it's required fields, if any)
mkApplicationSettings
  :: ApplicationSettings
mkApplicationSettings =
  ApplicationSettings
  { applicationSettingsApp = Nothing
  , applicationSettingsImplicitAssignment = Nothing
  , applicationSettingsInlineHookId = Nothing
  , applicationSettingsNotifications = Nothing
  , applicationSettingsNotes = Nothing
  }

-- ** ApplicationSettingsNotes
-- | ApplicationSettingsNotes
data ApplicationSettingsNotes = ApplicationSettingsNotes
  { applicationSettingsNotesAdmin :: !(Maybe Text) -- ^ "admin"
  , applicationSettingsNotesEnduser :: !(Maybe Text) -- ^ "enduser"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotes
instance A.FromJSON ApplicationSettingsNotes where
  parseJSON = A.withObject "ApplicationSettingsNotes" $ \o ->
    ApplicationSettingsNotes
      <$> (o .:? "admin")
      <*> (o .:? "enduser")

-- | ToJSON ApplicationSettingsNotes
instance A.ToJSON ApplicationSettingsNotes where
  toJSON ApplicationSettingsNotes {..} =
   _omitNulls
      [ "admin" .= applicationSettingsNotesAdmin
      , "enduser" .= applicationSettingsNotesEnduser
      ]


-- | Construct a value of type 'ApplicationSettingsNotes' (by applying it's required fields, if any)
mkApplicationSettingsNotes
  :: ApplicationSettingsNotes
mkApplicationSettingsNotes =
  ApplicationSettingsNotes
  { applicationSettingsNotesAdmin = Nothing
  , applicationSettingsNotesEnduser = Nothing
  }

-- ** ApplicationSettingsNotifications
-- | ApplicationSettingsNotifications
data ApplicationSettingsNotifications = ApplicationSettingsNotifications
  { applicationSettingsNotificationsVpn :: !(Maybe ApplicationSettingsNotificationsVpn) -- ^ "vpn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotifications
instance A.FromJSON ApplicationSettingsNotifications where
  parseJSON = A.withObject "ApplicationSettingsNotifications" $ \o ->
    ApplicationSettingsNotifications
      <$> (o .:? "vpn")

-- | ToJSON ApplicationSettingsNotifications
instance A.ToJSON ApplicationSettingsNotifications where
  toJSON ApplicationSettingsNotifications {..} =
   _omitNulls
      [ "vpn" .= applicationSettingsNotificationsVpn
      ]


-- | Construct a value of type 'ApplicationSettingsNotifications' (by applying it's required fields, if any)
mkApplicationSettingsNotifications
  :: ApplicationSettingsNotifications
mkApplicationSettingsNotifications =
  ApplicationSettingsNotifications
  { applicationSettingsNotificationsVpn = Nothing
  }

-- ** ApplicationSettingsNotificationsVpn
-- | ApplicationSettingsNotificationsVpn
data ApplicationSettingsNotificationsVpn = ApplicationSettingsNotificationsVpn
  { applicationSettingsNotificationsVpnHelpUrl :: !(Maybe Text) -- ^ "helpUrl"
  , applicationSettingsNotificationsVpnMessage :: !(Maybe Text) -- ^ "message"
  , applicationSettingsNotificationsVpnNetwork :: !(Maybe ApplicationSettingsNotificationsVpnNetwork) -- ^ "network"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotificationsVpn
instance A.FromJSON ApplicationSettingsNotificationsVpn where
  parseJSON = A.withObject "ApplicationSettingsNotificationsVpn" $ \o ->
    ApplicationSettingsNotificationsVpn
      <$> (o .:? "helpUrl")
      <*> (o .:? "message")
      <*> (o .:? "network")

-- | ToJSON ApplicationSettingsNotificationsVpn
instance A.ToJSON ApplicationSettingsNotificationsVpn where
  toJSON ApplicationSettingsNotificationsVpn {..} =
   _omitNulls
      [ "helpUrl" .= applicationSettingsNotificationsVpnHelpUrl
      , "message" .= applicationSettingsNotificationsVpnMessage
      , "network" .= applicationSettingsNotificationsVpnNetwork
      ]


-- | Construct a value of type 'ApplicationSettingsNotificationsVpn' (by applying it's required fields, if any)
mkApplicationSettingsNotificationsVpn
  :: ApplicationSettingsNotificationsVpn
mkApplicationSettingsNotificationsVpn =
  ApplicationSettingsNotificationsVpn
  { applicationSettingsNotificationsVpnHelpUrl = Nothing
  , applicationSettingsNotificationsVpnMessage = Nothing
  , applicationSettingsNotificationsVpnNetwork = Nothing
  }

-- ** ApplicationSettingsNotificationsVpnNetwork
-- | ApplicationSettingsNotificationsVpnNetwork
data ApplicationSettingsNotificationsVpnNetwork = ApplicationSettingsNotificationsVpnNetwork
  { applicationSettingsNotificationsVpnNetworkConnection :: !(Maybe Text) -- ^ "connection"
  , applicationSettingsNotificationsVpnNetworkExclude :: !(Maybe [Text]) -- ^ "exclude"
  , applicationSettingsNotificationsVpnNetworkInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotificationsVpnNetwork
instance A.FromJSON ApplicationSettingsNotificationsVpnNetwork where
  parseJSON = A.withObject "ApplicationSettingsNotificationsVpnNetwork" $ \o ->
    ApplicationSettingsNotificationsVpnNetwork
      <$> (o .:? "connection")
      <*> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON ApplicationSettingsNotificationsVpnNetwork
instance A.ToJSON ApplicationSettingsNotificationsVpnNetwork where
  toJSON ApplicationSettingsNotificationsVpnNetwork {..} =
   _omitNulls
      [ "connection" .= applicationSettingsNotificationsVpnNetworkConnection
      , "exclude" .= applicationSettingsNotificationsVpnNetworkExclude
      , "include" .= applicationSettingsNotificationsVpnNetworkInclude
      ]


-- | Construct a value of type 'ApplicationSettingsNotificationsVpnNetwork' (by applying it's required fields, if any)
mkApplicationSettingsNotificationsVpnNetwork
  :: ApplicationSettingsNotificationsVpnNetwork
mkApplicationSettingsNotificationsVpnNetwork =
  ApplicationSettingsNotificationsVpnNetwork
  { applicationSettingsNotificationsVpnNetworkConnection = Nothing
  , applicationSettingsNotificationsVpnNetworkExclude = Nothing
  , applicationSettingsNotificationsVpnNetworkInclude = Nothing
  }

-- ** ApplicationVisibility
-- | ApplicationVisibility
data ApplicationVisibility = ApplicationVisibility
  { applicationVisibilityAutoLaunch :: !(Maybe Bool) -- ^ "autoLaunch"
  , applicationVisibilityAppLinks :: !(Maybe (Map.Map String Bool)) -- ^ "appLinks"
  , applicationVisibilityAutoSubmitToolbar :: !(Maybe Bool) -- ^ "autoSubmitToolbar"
  , applicationVisibilityHide :: !(Maybe ApplicationVisibilityHide) -- ^ "hide"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationVisibility
instance A.FromJSON ApplicationVisibility where
  parseJSON = A.withObject "ApplicationVisibility" $ \o ->
    ApplicationVisibility
      <$> (o .:? "autoLaunch")
      <*> (o .:? "appLinks")
      <*> (o .:? "autoSubmitToolbar")
      <*> (o .:? "hide")

-- | ToJSON ApplicationVisibility
instance A.ToJSON ApplicationVisibility where
  toJSON ApplicationVisibility {..} =
   _omitNulls
      [ "autoLaunch" .= applicationVisibilityAutoLaunch
      , "appLinks" .= applicationVisibilityAppLinks
      , "autoSubmitToolbar" .= applicationVisibilityAutoSubmitToolbar
      , "hide" .= applicationVisibilityHide
      ]


-- | Construct a value of type 'ApplicationVisibility' (by applying it's required fields, if any)
mkApplicationVisibility
  :: ApplicationVisibility
mkApplicationVisibility =
  ApplicationVisibility
  { applicationVisibilityAutoLaunch = Nothing
  , applicationVisibilityAppLinks = Nothing
  , applicationVisibilityAutoSubmitToolbar = Nothing
  , applicationVisibilityHide = Nothing
  }

-- ** ApplicationVisibilityHide
-- | ApplicationVisibilityHide
data ApplicationVisibilityHide = ApplicationVisibilityHide
  { applicationVisibilityHideIOs :: !(Maybe Bool) -- ^ "iOS"
  , applicationVisibilityHideWeb :: !(Maybe Bool) -- ^ "web"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationVisibilityHide
instance A.FromJSON ApplicationVisibilityHide where
  parseJSON = A.withObject "ApplicationVisibilityHide" $ \o ->
    ApplicationVisibilityHide
      <$> (o .:? "iOS")
      <*> (o .:? "web")

-- | ToJSON ApplicationVisibilityHide
instance A.ToJSON ApplicationVisibilityHide where
  toJSON ApplicationVisibilityHide {..} =
   _omitNulls
      [ "iOS" .= applicationVisibilityHideIOs
      , "web" .= applicationVisibilityHideWeb
      ]


-- | Construct a value of type 'ApplicationVisibilityHide' (by applying it's required fields, if any)
mkApplicationVisibilityHide
  :: ApplicationVisibilityHide
mkApplicationVisibilityHide =
  ApplicationVisibilityHide
  { applicationVisibilityHideIOs = Nothing
  , applicationVisibilityHideWeb = Nothing
  }

-- ** AssignRoleRequest
-- | AssignRoleRequest
data AssignRoleRequest = AssignRoleRequest
  { assignRoleRequestType :: !(Maybe RoleType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssignRoleRequest
instance A.FromJSON AssignRoleRequest where
  parseJSON = A.withObject "AssignRoleRequest" $ \o ->
    AssignRoleRequest
      <$> (o .:? "type")

-- | ToJSON AssignRoleRequest
instance A.ToJSON AssignRoleRequest where
  toJSON AssignRoleRequest {..} =
   _omitNulls
      [ "type" .= assignRoleRequestType
      ]


-- | Construct a value of type 'AssignRoleRequest' (by applying it's required fields, if any)
mkAssignRoleRequest
  :: AssignRoleRequest
mkAssignRoleRequest =
  AssignRoleRequest
  { assignRoleRequestType = Nothing
  }

-- ** AuthenticationProvider
-- | AuthenticationProvider
data AuthenticationProvider = AuthenticationProvider
  { authenticationProviderName :: !(Maybe Text) -- ^ "name"
  , authenticationProviderType :: !(Maybe AuthenticationProviderType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticationProvider
instance A.FromJSON AuthenticationProvider where
  parseJSON = A.withObject "AuthenticationProvider" $ \o ->
    AuthenticationProvider
      <$> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON AuthenticationProvider
instance A.ToJSON AuthenticationProvider where
  toJSON AuthenticationProvider {..} =
   _omitNulls
      [ "name" .= authenticationProviderName
      , "type" .= authenticationProviderType
      ]


-- | Construct a value of type 'AuthenticationProvider' (by applying it's required fields, if any)
mkAuthenticationProvider
  :: AuthenticationProvider
mkAuthenticationProvider =
  AuthenticationProvider
  { authenticationProviderName = Nothing
  , authenticationProviderType = Nothing
  }

-- ** Authenticator
-- | Authenticator
data Authenticator = Authenticator
  { authenticatorLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , authenticatorCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , authenticatorId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , authenticatorKey :: !(Maybe Text) -- ^ "key"
  , authenticatorStatus :: !(Maybe AuthenticatorStatus) -- ^ "status"
  , authenticatorLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , authenticatorName :: !(Maybe Text) -- ^ "name"
  , authenticatorType :: !(Maybe AuthenticatorType) -- ^ "type"
  , authenticatorSettings :: !(Maybe AuthenticatorSettings) -- ^ "settings"
  , authenticatorProvider :: !(Maybe AuthenticatorProvider) -- ^ "provider"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Authenticator
instance A.FromJSON Authenticator where
  parseJSON = A.withObject "Authenticator" $ \o ->
    Authenticator
      <$> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "key")
      <*> (o .:? "status")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "type")
      <*> (o .:? "settings")
      <*> (o .:? "provider")

-- | ToJSON Authenticator
instance A.ToJSON Authenticator where
  toJSON Authenticator {..} =
   _omitNulls
      [ "_links" .= authenticatorLinks
      , "created" .= authenticatorCreated
      , "id" .= authenticatorId
      , "key" .= authenticatorKey
      , "status" .= authenticatorStatus
      , "lastUpdated" .= authenticatorLastUpdated
      , "name" .= authenticatorName
      , "type" .= authenticatorType
      , "settings" .= authenticatorSettings
      , "provider" .= authenticatorProvider
      ]


-- | Construct a value of type 'Authenticator' (by applying it's required fields, if any)
mkAuthenticator
  :: Authenticator
mkAuthenticator =
  Authenticator
  { authenticatorLinks = Nothing
  , authenticatorCreated = Nothing
  , authenticatorId = Nothing
  , authenticatorKey = Nothing
  , authenticatorStatus = Nothing
  , authenticatorLastUpdated = Nothing
  , authenticatorName = Nothing
  , authenticatorType = Nothing
  , authenticatorSettings = Nothing
  , authenticatorProvider = Nothing
  }

-- ** AuthenticatorProvider
-- | AuthenticatorProvider
data AuthenticatorProvider = AuthenticatorProvider
  { authenticatorProviderType :: !(Maybe Text) -- ^ "type"
  , authenticatorProviderConfiguration :: !(Maybe AuthenticatorProviderConfiguration) -- ^ "configuration"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticatorProvider
instance A.FromJSON AuthenticatorProvider where
  parseJSON = A.withObject "AuthenticatorProvider" $ \o ->
    AuthenticatorProvider
      <$> (o .:? "type")
      <*> (o .:? "configuration")

-- | ToJSON AuthenticatorProvider
instance A.ToJSON AuthenticatorProvider where
  toJSON AuthenticatorProvider {..} =
   _omitNulls
      [ "type" .= authenticatorProviderType
      , "configuration" .= authenticatorProviderConfiguration
      ]


-- | Construct a value of type 'AuthenticatorProvider' (by applying it's required fields, if any)
mkAuthenticatorProvider
  :: AuthenticatorProvider
mkAuthenticatorProvider =
  AuthenticatorProvider
  { authenticatorProviderType = Nothing
  , authenticatorProviderConfiguration = Nothing
  }

-- ** AuthenticatorProviderConfiguration
-- | AuthenticatorProviderConfiguration
data AuthenticatorProviderConfiguration = AuthenticatorProviderConfiguration
  { authenticatorProviderConfigurationHostName :: !(Maybe Text) -- ^ "hostName"
  , authenticatorProviderConfigurationAuthPort :: !(Maybe Int) -- ^ "authPort"
  , authenticatorProviderConfigurationInstanceId :: !(Maybe Text) -- ^ "instanceId"
  , authenticatorProviderConfigurationSharedSecret :: !(Maybe Text) -- ^ "sharedSecret"
  , authenticatorProviderConfigurationUserNameTemplate :: !(Maybe AuthenticatorProviderConfigurationUserNamePlate) -- ^ "userNameTemplate"
  , authenticatorProviderConfigurationHost :: !(Maybe Text) -- ^ "host"
  , authenticatorProviderConfigurationSecretKey :: !(Maybe Text) -- ^ "secretKey"
  , authenticatorProviderConfigurationIntegrationKey :: !(Maybe Text) -- ^ "integrationKey"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticatorProviderConfiguration
instance A.FromJSON AuthenticatorProviderConfiguration where
  parseJSON = A.withObject "AuthenticatorProviderConfiguration" $ \o ->
    AuthenticatorProviderConfiguration
      <$> (o .:? "hostName")
      <*> (o .:? "authPort")
      <*> (o .:? "instanceId")
      <*> (o .:? "sharedSecret")
      <*> (o .:? "userNameTemplate")
      <*> (o .:? "host")
      <*> (o .:? "secretKey")
      <*> (o .:? "integrationKey")

-- | ToJSON AuthenticatorProviderConfiguration
instance A.ToJSON AuthenticatorProviderConfiguration where
  toJSON AuthenticatorProviderConfiguration {..} =
   _omitNulls
      [ "hostName" .= authenticatorProviderConfigurationHostName
      , "authPort" .= authenticatorProviderConfigurationAuthPort
      , "instanceId" .= authenticatorProviderConfigurationInstanceId
      , "sharedSecret" .= authenticatorProviderConfigurationSharedSecret
      , "userNameTemplate" .= authenticatorProviderConfigurationUserNameTemplate
      , "host" .= authenticatorProviderConfigurationHost
      , "secretKey" .= authenticatorProviderConfigurationSecretKey
      , "integrationKey" .= authenticatorProviderConfigurationIntegrationKey
      ]


-- | Construct a value of type 'AuthenticatorProviderConfiguration' (by applying it's required fields, if any)
mkAuthenticatorProviderConfiguration
  :: AuthenticatorProviderConfiguration
mkAuthenticatorProviderConfiguration =
  AuthenticatorProviderConfiguration
  { authenticatorProviderConfigurationHostName = Nothing
  , authenticatorProviderConfigurationAuthPort = Nothing
  , authenticatorProviderConfigurationInstanceId = Nothing
  , authenticatorProviderConfigurationSharedSecret = Nothing
  , authenticatorProviderConfigurationUserNameTemplate = Nothing
  , authenticatorProviderConfigurationHost = Nothing
  , authenticatorProviderConfigurationSecretKey = Nothing
  , authenticatorProviderConfigurationIntegrationKey = Nothing
  }

-- ** AuthenticatorProviderConfigurationUserNamePlate
-- | AuthenticatorProviderConfigurationUserNamePlate
data AuthenticatorProviderConfigurationUserNamePlate = AuthenticatorProviderConfigurationUserNamePlate
  { authenticatorProviderConfigurationUserNamePlateTemplate :: !(Maybe Text) -- ^ "template"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticatorProviderConfigurationUserNamePlate
instance A.FromJSON AuthenticatorProviderConfigurationUserNamePlate where
  parseJSON = A.withObject "AuthenticatorProviderConfigurationUserNamePlate" $ \o ->
    AuthenticatorProviderConfigurationUserNamePlate
      <$> (o .:? "template")

-- | ToJSON AuthenticatorProviderConfigurationUserNamePlate
instance A.ToJSON AuthenticatorProviderConfigurationUserNamePlate where
  toJSON AuthenticatorProviderConfigurationUserNamePlate {..} =
   _omitNulls
      [ "template" .= authenticatorProviderConfigurationUserNamePlateTemplate
      ]


-- | Construct a value of type 'AuthenticatorProviderConfigurationUserNamePlate' (by applying it's required fields, if any)
mkAuthenticatorProviderConfigurationUserNamePlate
  :: AuthenticatorProviderConfigurationUserNamePlate
mkAuthenticatorProviderConfigurationUserNamePlate =
  AuthenticatorProviderConfigurationUserNamePlate
  { authenticatorProviderConfigurationUserNamePlateTemplate = Nothing
  }

-- ** AuthenticatorSettings
-- | AuthenticatorSettings
data AuthenticatorSettings = AuthenticatorSettings
  { authenticatorSettingsAllowedFor :: !(Maybe AllowedForEnum) -- ^ "allowedFor"
  , authenticatorSettingsTokenLifetimeInMinutes :: !(Maybe Int) -- ^ "tokenLifetimeInMinutes"
  , authenticatorSettingsAppInstanceId :: !(Maybe Text) -- ^ "appInstanceId"
  , authenticatorSettingsChannelBinding :: !(Maybe ChannelBinding) -- ^ "channelBinding"
  , authenticatorSettingsCompliance :: !(Maybe Compliance) -- ^ "compliance"
  , authenticatorSettingsUserVerification :: !(Maybe UserVerificationEnum) -- ^ "userVerification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticatorSettings
instance A.FromJSON AuthenticatorSettings where
  parseJSON = A.withObject "AuthenticatorSettings" $ \o ->
    AuthenticatorSettings
      <$> (o .:? "allowedFor")
      <*> (o .:? "tokenLifetimeInMinutes")
      <*> (o .:? "appInstanceId")
      <*> (o .:? "channelBinding")
      <*> (o .:? "compliance")
      <*> (o .:? "userVerification")

-- | ToJSON AuthenticatorSettings
instance A.ToJSON AuthenticatorSettings where
  toJSON AuthenticatorSettings {..} =
   _omitNulls
      [ "allowedFor" .= authenticatorSettingsAllowedFor
      , "tokenLifetimeInMinutes" .= authenticatorSettingsTokenLifetimeInMinutes
      , "appInstanceId" .= authenticatorSettingsAppInstanceId
      , "channelBinding" .= authenticatorSettingsChannelBinding
      , "compliance" .= authenticatorSettingsCompliance
      , "userVerification" .= authenticatorSettingsUserVerification
      ]


-- | Construct a value of type 'AuthenticatorSettings' (by applying it's required fields, if any)
mkAuthenticatorSettings
  :: AuthenticatorSettings
mkAuthenticatorSettings =
  AuthenticatorSettings
  { authenticatorSettingsAllowedFor = Nothing
  , authenticatorSettingsTokenLifetimeInMinutes = Nothing
  , authenticatorSettingsAppInstanceId = Nothing
  , authenticatorSettingsChannelBinding = Nothing
  , authenticatorSettingsCompliance = Nothing
  , authenticatorSettingsUserVerification = Nothing
  }

-- ** AuthorizationServer
-- | AuthorizationServer
data AuthorizationServer = AuthorizationServer
  { authorizationServerLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , authorizationServerAudiences :: !(Maybe [Text]) -- ^ "audiences"
  , authorizationServerCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , authorizationServerCredentials :: !(Maybe AuthorizationServerCredentials) -- ^ "credentials"
  , authorizationServerDescription :: !(Maybe Text) -- ^ "description"
  , authorizationServerId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , authorizationServerIssuer :: !(Maybe Text) -- ^ "issuer"
  , authorizationServerIssuerMode :: !(Maybe E'IssuerMode) -- ^ "issuerMode"
  , authorizationServerLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , authorizationServerName :: !(Maybe Text) -- ^ "name"
  , authorizationServerStatus :: !(Maybe E'Status2) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServer
instance A.FromJSON AuthorizationServer where
  parseJSON = A.withObject "AuthorizationServer" $ \o ->
    AuthorizationServer
      <$> (o .:? "_links")
      <*> (o .:? "audiences")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "issuer")
      <*> (o .:? "issuerMode")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "status")

-- | ToJSON AuthorizationServer
instance A.ToJSON AuthorizationServer where
  toJSON AuthorizationServer {..} =
   _omitNulls
      [ "_links" .= authorizationServerLinks
      , "audiences" .= authorizationServerAudiences
      , "created" .= authorizationServerCreated
      , "credentials" .= authorizationServerCredentials
      , "description" .= authorizationServerDescription
      , "id" .= authorizationServerId
      , "issuer" .= authorizationServerIssuer
      , "issuerMode" .= authorizationServerIssuerMode
      , "lastUpdated" .= authorizationServerLastUpdated
      , "name" .= authorizationServerName
      , "status" .= authorizationServerStatus
      ]


-- | Construct a value of type 'AuthorizationServer' (by applying it's required fields, if any)
mkAuthorizationServer
  :: AuthorizationServer
mkAuthorizationServer =
  AuthorizationServer
  { authorizationServerLinks = Nothing
  , authorizationServerAudiences = Nothing
  , authorizationServerCreated = Nothing
  , authorizationServerCredentials = Nothing
  , authorizationServerDescription = Nothing
  , authorizationServerId = Nothing
  , authorizationServerIssuer = Nothing
  , authorizationServerIssuerMode = Nothing
  , authorizationServerLastUpdated = Nothing
  , authorizationServerName = Nothing
  , authorizationServerStatus = Nothing
  }

-- ** AuthorizationServerCredentials
-- | AuthorizationServerCredentials
data AuthorizationServerCredentials = AuthorizationServerCredentials
  { authorizationServerCredentialsSigning :: !(Maybe AuthorizationServerCredentialsSigningConfig) -- ^ "signing"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServerCredentials
instance A.FromJSON AuthorizationServerCredentials where
  parseJSON = A.withObject "AuthorizationServerCredentials" $ \o ->
    AuthorizationServerCredentials
      <$> (o .:? "signing")

-- | ToJSON AuthorizationServerCredentials
instance A.ToJSON AuthorizationServerCredentials where
  toJSON AuthorizationServerCredentials {..} =
   _omitNulls
      [ "signing" .= authorizationServerCredentialsSigning
      ]


-- | Construct a value of type 'AuthorizationServerCredentials' (by applying it's required fields, if any)
mkAuthorizationServerCredentials
  :: AuthorizationServerCredentials
mkAuthorizationServerCredentials =
  AuthorizationServerCredentials
  { authorizationServerCredentialsSigning = Nothing
  }

-- ** AuthorizationServerCredentialsSigningConfig
-- | AuthorizationServerCredentialsSigningConfig
data AuthorizationServerCredentialsSigningConfig = AuthorizationServerCredentialsSigningConfig
  { authorizationServerCredentialsSigningConfigKid :: !(Maybe Text) -- ^ "kid"
  , authorizationServerCredentialsSigningConfigLastRotated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastRotated"
  , authorizationServerCredentialsSigningConfigNextRotation :: !(Maybe DateTime) -- ^ /ReadOnly/ "nextRotation"
  , authorizationServerCredentialsSigningConfigRotationMode :: !(Maybe AuthorizationServerCredentialsRotationMode) -- ^ "rotationMode"
  , authorizationServerCredentialsSigningConfigUse :: !(Maybe AuthorizationServerCredentialsUse) -- ^ "use"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServerCredentialsSigningConfig
instance A.FromJSON AuthorizationServerCredentialsSigningConfig where
  parseJSON = A.withObject "AuthorizationServerCredentialsSigningConfig" $ \o ->
    AuthorizationServerCredentialsSigningConfig
      <$> (o .:? "kid")
      <*> (o .:? "lastRotated")
      <*> (o .:? "nextRotation")
      <*> (o .:? "rotationMode")
      <*> (o .:? "use")

-- | ToJSON AuthorizationServerCredentialsSigningConfig
instance A.ToJSON AuthorizationServerCredentialsSigningConfig where
  toJSON AuthorizationServerCredentialsSigningConfig {..} =
   _omitNulls
      [ "kid" .= authorizationServerCredentialsSigningConfigKid
      , "lastRotated" .= authorizationServerCredentialsSigningConfigLastRotated
      , "nextRotation" .= authorizationServerCredentialsSigningConfigNextRotation
      , "rotationMode" .= authorizationServerCredentialsSigningConfigRotationMode
      , "use" .= authorizationServerCredentialsSigningConfigUse
      ]


-- | Construct a value of type 'AuthorizationServerCredentialsSigningConfig' (by applying it's required fields, if any)
mkAuthorizationServerCredentialsSigningConfig
  :: AuthorizationServerCredentialsSigningConfig
mkAuthorizationServerCredentialsSigningConfig =
  AuthorizationServerCredentialsSigningConfig
  { authorizationServerCredentialsSigningConfigKid = Nothing
  , authorizationServerCredentialsSigningConfigLastRotated = Nothing
  , authorizationServerCredentialsSigningConfigNextRotation = Nothing
  , authorizationServerCredentialsSigningConfigRotationMode = Nothing
  , authorizationServerCredentialsSigningConfigUse = Nothing
  }

-- ** AuthorizationServerPolicy
-- | AuthorizationServerPolicy
data AuthorizationServerPolicy = AuthorizationServerPolicy
  { authorizationServerPolicyEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , authorizationServerPolicyLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , authorizationServerPolicyConditions :: !(Maybe PolicyRuleConditions) -- ^ "conditions"
  , authorizationServerPolicyCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , authorizationServerPolicyDescription :: !(Maybe Text) -- ^ "description"
  , authorizationServerPolicyId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , authorizationServerPolicyLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , authorizationServerPolicyName :: !(Maybe Text) -- ^ "name"
  , authorizationServerPolicyPriority :: !(Maybe Int) -- ^ "priority"
  , authorizationServerPolicyStatus :: !(Maybe E'Status2) -- ^ "status"
  , authorizationServerPolicySystem :: !(Maybe Bool) -- ^ "system"
  , authorizationServerPolicyType :: !(Maybe PolicyType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServerPolicy
instance A.FromJSON AuthorizationServerPolicy where
  parseJSON = A.withObject "AuthorizationServerPolicy" $ \o ->
    AuthorizationServerPolicy
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "conditions")
      <*> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "priority")
      <*> (o .:? "status")
      <*> (o .:? "system")
      <*> (o .:? "type")

-- | ToJSON AuthorizationServerPolicy
instance A.ToJSON AuthorizationServerPolicy where
  toJSON AuthorizationServerPolicy {..} =
   _omitNulls
      [ "_embedded" .= authorizationServerPolicyEmbedded
      , "_links" .= authorizationServerPolicyLinks
      , "conditions" .= authorizationServerPolicyConditions
      , "created" .= authorizationServerPolicyCreated
      , "description" .= authorizationServerPolicyDescription
      , "id" .= authorizationServerPolicyId
      , "lastUpdated" .= authorizationServerPolicyLastUpdated
      , "name" .= authorizationServerPolicyName
      , "priority" .= authorizationServerPolicyPriority
      , "status" .= authorizationServerPolicyStatus
      , "system" .= authorizationServerPolicySystem
      , "type" .= authorizationServerPolicyType
      ]


-- | Construct a value of type 'AuthorizationServerPolicy' (by applying it's required fields, if any)
mkAuthorizationServerPolicy
  :: AuthorizationServerPolicy
mkAuthorizationServerPolicy =
  AuthorizationServerPolicy
  { authorizationServerPolicyEmbedded = Nothing
  , authorizationServerPolicyLinks = Nothing
  , authorizationServerPolicyConditions = Nothing
  , authorizationServerPolicyCreated = Nothing
  , authorizationServerPolicyDescription = Nothing
  , authorizationServerPolicyId = Nothing
  , authorizationServerPolicyLastUpdated = Nothing
  , authorizationServerPolicyName = Nothing
  , authorizationServerPolicyPriority = Nothing
  , authorizationServerPolicyStatus = Nothing
  , authorizationServerPolicySystem = Nothing
  , authorizationServerPolicyType = Nothing
  }

-- ** AuthorizationServerPolicyRule
-- | AuthorizationServerPolicyRule
data AuthorizationServerPolicyRule = AuthorizationServerPolicyRule
  { authorizationServerPolicyRuleCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , authorizationServerPolicyRuleId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , authorizationServerPolicyRuleName :: !(Maybe Text) -- ^ "name"
  , authorizationServerPolicyRuleLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , authorizationServerPolicyRulePriority :: !(Maybe Int) -- ^ "priority"
  , authorizationServerPolicyRuleStatus :: !(Maybe E'Status2) -- ^ "status"
  , authorizationServerPolicyRuleSystem :: !(Maybe Bool) -- ^ "system"
  , authorizationServerPolicyRuleType :: !(Maybe E'Type5) -- ^ "type"
  , authorizationServerPolicyRuleConditions :: !(Maybe AuthorizationServerPolicyRuleConditions) -- ^ "conditions"
  , authorizationServerPolicyRuleActions :: !(Maybe AuthorizationServerPolicyRuleActions) -- ^ "actions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServerPolicyRule
instance A.FromJSON AuthorizationServerPolicyRule where
  parseJSON = A.withObject "AuthorizationServerPolicyRule" $ \o ->
    AuthorizationServerPolicyRule
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "priority")
      <*> (o .:? "status")
      <*> (o .:? "system")
      <*> (o .:? "type")
      <*> (o .:? "conditions")
      <*> (o .:? "actions")

-- | ToJSON AuthorizationServerPolicyRule
instance A.ToJSON AuthorizationServerPolicyRule where
  toJSON AuthorizationServerPolicyRule {..} =
   _omitNulls
      [ "created" .= authorizationServerPolicyRuleCreated
      , "id" .= authorizationServerPolicyRuleId
      , "name" .= authorizationServerPolicyRuleName
      , "lastUpdated" .= authorizationServerPolicyRuleLastUpdated
      , "priority" .= authorizationServerPolicyRulePriority
      , "status" .= authorizationServerPolicyRuleStatus
      , "system" .= authorizationServerPolicyRuleSystem
      , "type" .= authorizationServerPolicyRuleType
      , "conditions" .= authorizationServerPolicyRuleConditions
      , "actions" .= authorizationServerPolicyRuleActions
      ]


-- | Construct a value of type 'AuthorizationServerPolicyRule' (by applying it's required fields, if any)
mkAuthorizationServerPolicyRule
  :: AuthorizationServerPolicyRule
mkAuthorizationServerPolicyRule =
  AuthorizationServerPolicyRule
  { authorizationServerPolicyRuleCreated = Nothing
  , authorizationServerPolicyRuleId = Nothing
  , authorizationServerPolicyRuleName = Nothing
  , authorizationServerPolicyRuleLastUpdated = Nothing
  , authorizationServerPolicyRulePriority = Nothing
  , authorizationServerPolicyRuleStatus = Nothing
  , authorizationServerPolicyRuleSystem = Nothing
  , authorizationServerPolicyRuleType = Nothing
  , authorizationServerPolicyRuleConditions = Nothing
  , authorizationServerPolicyRuleActions = Nothing
  }

-- ** AuthorizationServerPolicyRuleActions
-- | AuthorizationServerPolicyRuleActions
data AuthorizationServerPolicyRuleActions = AuthorizationServerPolicyRuleActions
  { authorizationServerPolicyRuleActionsToken :: !(Maybe TokenAuthorizationServerPolicyRuleAction) -- ^ "token"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServerPolicyRuleActions
instance A.FromJSON AuthorizationServerPolicyRuleActions where
  parseJSON = A.withObject "AuthorizationServerPolicyRuleActions" $ \o ->
    AuthorizationServerPolicyRuleActions
      <$> (o .:? "token")

-- | ToJSON AuthorizationServerPolicyRuleActions
instance A.ToJSON AuthorizationServerPolicyRuleActions where
  toJSON AuthorizationServerPolicyRuleActions {..} =
   _omitNulls
      [ "token" .= authorizationServerPolicyRuleActionsToken
      ]


-- | Construct a value of type 'AuthorizationServerPolicyRuleActions' (by applying it's required fields, if any)
mkAuthorizationServerPolicyRuleActions
  :: AuthorizationServerPolicyRuleActions
mkAuthorizationServerPolicyRuleActions =
  AuthorizationServerPolicyRuleActions
  { authorizationServerPolicyRuleActionsToken = Nothing
  }

-- ** AuthorizationServerPolicyRuleConditions
-- | AuthorizationServerPolicyRuleConditions
data AuthorizationServerPolicyRuleConditions = AuthorizationServerPolicyRuleConditions
  { authorizationServerPolicyRuleConditionsPeople :: !(Maybe PolicyPeopleCondition) -- ^ "people"
  , authorizationServerPolicyRuleConditionsClients :: !(Maybe ClientPolicyCondition) -- ^ "clients"
  , authorizationServerPolicyRuleConditionsGrantTypes :: !(Maybe GrantTypePolicyRuleCondition) -- ^ "grantTypes"
  , authorizationServerPolicyRuleConditionsScopes :: !(Maybe OAuth2ScopesMediationPolicyRuleCondition) -- ^ "scopes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthorizationServerPolicyRuleConditions
instance A.FromJSON AuthorizationServerPolicyRuleConditions where
  parseJSON = A.withObject "AuthorizationServerPolicyRuleConditions" $ \o ->
    AuthorizationServerPolicyRuleConditions
      <$> (o .:? "people")
      <*> (o .:? "clients")
      <*> (o .:? "grantTypes")
      <*> (o .:? "scopes")

-- | ToJSON AuthorizationServerPolicyRuleConditions
instance A.ToJSON AuthorizationServerPolicyRuleConditions where
  toJSON AuthorizationServerPolicyRuleConditions {..} =
   _omitNulls
      [ "people" .= authorizationServerPolicyRuleConditionsPeople
      , "clients" .= authorizationServerPolicyRuleConditionsClients
      , "grantTypes" .= authorizationServerPolicyRuleConditionsGrantTypes
      , "scopes" .= authorizationServerPolicyRuleConditionsScopes
      ]


-- | Construct a value of type 'AuthorizationServerPolicyRuleConditions' (by applying it's required fields, if any)
mkAuthorizationServerPolicyRuleConditions
  :: AuthorizationServerPolicyRuleConditions
mkAuthorizationServerPolicyRuleConditions =
  AuthorizationServerPolicyRuleConditions
  { authorizationServerPolicyRuleConditionsPeople = Nothing
  , authorizationServerPolicyRuleConditionsClients = Nothing
  , authorizationServerPolicyRuleConditionsGrantTypes = Nothing
  , authorizationServerPolicyRuleConditionsScopes = Nothing
  }

-- ** AutoLoginApplication
-- | AutoLoginApplication
data AutoLoginApplication = AutoLoginApplication
  { autoLoginApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  , autoLoginApplicationSettings :: !(Maybe AutoLoginApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoLoginApplication
instance A.FromJSON AutoLoginApplication where
  parseJSON = A.withObject "AutoLoginApplication" $ \o ->
    AutoLoginApplication
      <$> (o .:? "credentials")
      <*> (o .:? "settings")

-- | ToJSON AutoLoginApplication
instance A.ToJSON AutoLoginApplication where
  toJSON AutoLoginApplication {..} =
   _omitNulls
      [ "credentials" .= autoLoginApplicationCredentials
      , "settings" .= autoLoginApplicationSettings
      ]


-- | Construct a value of type 'AutoLoginApplication' (by applying it's required fields, if any)
mkAutoLoginApplication
  :: AutoLoginApplication
mkAutoLoginApplication =
  AutoLoginApplication
  { autoLoginApplicationCredentials = Nothing
  , autoLoginApplicationSettings = Nothing
  }

-- ** AutoLoginApplicationSettings
-- | AutoLoginApplicationSettings
data AutoLoginApplicationSettings = AutoLoginApplicationSettings
  { autoLoginApplicationSettingsSignOn :: !(Maybe AutoLoginApplicationSettingsSignOn) -- ^ "signOn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoLoginApplicationSettings
instance A.FromJSON AutoLoginApplicationSettings where
  parseJSON = A.withObject "AutoLoginApplicationSettings" $ \o ->
    AutoLoginApplicationSettings
      <$> (o .:? "signOn")

-- | ToJSON AutoLoginApplicationSettings
instance A.ToJSON AutoLoginApplicationSettings where
  toJSON AutoLoginApplicationSettings {..} =
   _omitNulls
      [ "signOn" .= autoLoginApplicationSettingsSignOn
      ]


-- | Construct a value of type 'AutoLoginApplicationSettings' (by applying it's required fields, if any)
mkAutoLoginApplicationSettings
  :: AutoLoginApplicationSettings
mkAutoLoginApplicationSettings =
  AutoLoginApplicationSettings
  { autoLoginApplicationSettingsSignOn = Nothing
  }

-- ** AutoLoginApplicationSettingsSignOn
-- | AutoLoginApplicationSettingsSignOn
data AutoLoginApplicationSettingsSignOn = AutoLoginApplicationSettingsSignOn
  { autoLoginApplicationSettingsSignOnLoginUrl :: !(Maybe Text) -- ^ "loginUrl"
  , autoLoginApplicationSettingsSignOnRedirectUrl :: !(Maybe Text) -- ^ "redirectUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoLoginApplicationSettingsSignOn
instance A.FromJSON AutoLoginApplicationSettingsSignOn where
  parseJSON = A.withObject "AutoLoginApplicationSettingsSignOn" $ \o ->
    AutoLoginApplicationSettingsSignOn
      <$> (o .:? "loginUrl")
      <*> (o .:? "redirectUrl")

-- | ToJSON AutoLoginApplicationSettingsSignOn
instance A.ToJSON AutoLoginApplicationSettingsSignOn where
  toJSON AutoLoginApplicationSettingsSignOn {..} =
   _omitNulls
      [ "loginUrl" .= autoLoginApplicationSettingsSignOnLoginUrl
      , "redirectUrl" .= autoLoginApplicationSettingsSignOnRedirectUrl
      ]


-- | Construct a value of type 'AutoLoginApplicationSettingsSignOn' (by applying it's required fields, if any)
mkAutoLoginApplicationSettingsSignOn
  :: AutoLoginApplicationSettingsSignOn
mkAutoLoginApplicationSettingsSignOn =
  AutoLoginApplicationSettingsSignOn
  { autoLoginApplicationSettingsSignOnLoginUrl = Nothing
  , autoLoginApplicationSettingsSignOnRedirectUrl = Nothing
  }

-- ** BasicApplicationSettings
-- | BasicApplicationSettings
data BasicApplicationSettings = BasicApplicationSettings
  { basicApplicationSettingsApp :: !(Maybe BasicApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicApplicationSettings
instance A.FromJSON BasicApplicationSettings where
  parseJSON = A.withObject "BasicApplicationSettings" $ \o ->
    BasicApplicationSettings
      <$> (o .:? "app")

-- | ToJSON BasicApplicationSettings
instance A.ToJSON BasicApplicationSettings where
  toJSON BasicApplicationSettings {..} =
   _omitNulls
      [ "app" .= basicApplicationSettingsApp
      ]


-- | Construct a value of type 'BasicApplicationSettings' (by applying it's required fields, if any)
mkBasicApplicationSettings
  :: BasicApplicationSettings
mkBasicApplicationSettings =
  BasicApplicationSettings
  { basicApplicationSettingsApp = Nothing
  }

-- ** BasicApplicationSettingsApplication
-- | BasicApplicationSettingsApplication
data BasicApplicationSettingsApplication = BasicApplicationSettingsApplication
  { basicApplicationSettingsApplicationAuthUrl :: !(Maybe Text) -- ^ "authURL"
  , basicApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicApplicationSettingsApplication
instance A.FromJSON BasicApplicationSettingsApplication where
  parseJSON = A.withObject "BasicApplicationSettingsApplication" $ \o ->
    BasicApplicationSettingsApplication
      <$> (o .:? "authURL")
      <*> (o .:? "url")

-- | ToJSON BasicApplicationSettingsApplication
instance A.ToJSON BasicApplicationSettingsApplication where
  toJSON BasicApplicationSettingsApplication {..} =
   _omitNulls
      [ "authURL" .= basicApplicationSettingsApplicationAuthUrl
      , "url" .= basicApplicationSettingsApplicationUrl
      ]


-- | Construct a value of type 'BasicApplicationSettingsApplication' (by applying it's required fields, if any)
mkBasicApplicationSettingsApplication
  :: BasicApplicationSettingsApplication
mkBasicApplicationSettingsApplication =
  BasicApplicationSettingsApplication
  { basicApplicationSettingsApplicationAuthUrl = Nothing
  , basicApplicationSettingsApplicationUrl = Nothing
  }

-- ** BasicAuthApplication
-- | BasicAuthApplication
data BasicAuthApplication = BasicAuthApplication
  { basicAuthApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  , basicAuthApplicationName :: !(Maybe A.Value) -- ^ "name"
  , basicAuthApplicationSettings :: !(Maybe BasicApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicAuthApplication
instance A.FromJSON BasicAuthApplication where
  parseJSON = A.withObject "BasicAuthApplication" $ \o ->
    BasicAuthApplication
      <$> (o .:? "credentials")
      <*> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON BasicAuthApplication
instance A.ToJSON BasicAuthApplication where
  toJSON BasicAuthApplication {..} =
   _omitNulls
      [ "credentials" .= basicAuthApplicationCredentials
      , "name" .= basicAuthApplicationName
      , "settings" .= basicAuthApplicationSettings
      ]


-- | Construct a value of type 'BasicAuthApplication' (by applying it's required fields, if any)
mkBasicAuthApplication
  :: BasicAuthApplication
mkBasicAuthApplication =
  BasicAuthApplication
  { basicAuthApplicationCredentials = Nothing
  , basicAuthApplicationName = Nothing
  , basicAuthApplicationSettings = Nothing
  }

-- ** BeforeScheduledActionPolicyRuleCondition
-- | BeforeScheduledActionPolicyRuleCondition
data BeforeScheduledActionPolicyRuleCondition = BeforeScheduledActionPolicyRuleCondition
  { beforeScheduledActionPolicyRuleConditionDuration :: !(Maybe Duration) -- ^ "duration"
  , beforeScheduledActionPolicyRuleConditionLifecycleAction :: !(Maybe ScheduledUserLifecycleAction) -- ^ "lifecycleAction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BeforeScheduledActionPolicyRuleCondition
instance A.FromJSON BeforeScheduledActionPolicyRuleCondition where
  parseJSON = A.withObject "BeforeScheduledActionPolicyRuleCondition" $ \o ->
    BeforeScheduledActionPolicyRuleCondition
      <$> (o .:? "duration")
      <*> (o .:? "lifecycleAction")

-- | ToJSON BeforeScheduledActionPolicyRuleCondition
instance A.ToJSON BeforeScheduledActionPolicyRuleCondition where
  toJSON BeforeScheduledActionPolicyRuleCondition {..} =
   _omitNulls
      [ "duration" .= beforeScheduledActionPolicyRuleConditionDuration
      , "lifecycleAction" .= beforeScheduledActionPolicyRuleConditionLifecycleAction
      ]


-- | Construct a value of type 'BeforeScheduledActionPolicyRuleCondition' (by applying it's required fields, if any)
mkBeforeScheduledActionPolicyRuleCondition
  :: BeforeScheduledActionPolicyRuleCondition
mkBeforeScheduledActionPolicyRuleCondition =
  BeforeScheduledActionPolicyRuleCondition
  { beforeScheduledActionPolicyRuleConditionDuration = Nothing
  , beforeScheduledActionPolicyRuleConditionLifecycleAction = Nothing
  }

-- ** BookmarkApplication
-- | BookmarkApplication
data BookmarkApplication = BookmarkApplication
  { bookmarkApplicationName :: !(Maybe A.Value) -- ^ "name"
  , bookmarkApplicationSettings :: !(Maybe BookmarkApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BookmarkApplication
instance A.FromJSON BookmarkApplication where
  parseJSON = A.withObject "BookmarkApplication" $ \o ->
    BookmarkApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON BookmarkApplication
instance A.ToJSON BookmarkApplication where
  toJSON BookmarkApplication {..} =
   _omitNulls
      [ "name" .= bookmarkApplicationName
      , "settings" .= bookmarkApplicationSettings
      ]


-- | Construct a value of type 'BookmarkApplication' (by applying it's required fields, if any)
mkBookmarkApplication
  :: BookmarkApplication
mkBookmarkApplication =
  BookmarkApplication
  { bookmarkApplicationName = Nothing
  , bookmarkApplicationSettings = Nothing
  }

-- ** BookmarkApplicationSettings
-- | BookmarkApplicationSettings
data BookmarkApplicationSettings = BookmarkApplicationSettings
  { bookmarkApplicationSettingsApp :: !(Maybe BookmarkApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BookmarkApplicationSettings
instance A.FromJSON BookmarkApplicationSettings where
  parseJSON = A.withObject "BookmarkApplicationSettings" $ \o ->
    BookmarkApplicationSettings
      <$> (o .:? "app")

-- | ToJSON BookmarkApplicationSettings
instance A.ToJSON BookmarkApplicationSettings where
  toJSON BookmarkApplicationSettings {..} =
   _omitNulls
      [ "app" .= bookmarkApplicationSettingsApp
      ]


-- | Construct a value of type 'BookmarkApplicationSettings' (by applying it's required fields, if any)
mkBookmarkApplicationSettings
  :: BookmarkApplicationSettings
mkBookmarkApplicationSettings =
  BookmarkApplicationSettings
  { bookmarkApplicationSettingsApp = Nothing
  }

-- ** BookmarkApplicationSettingsApplication
-- | BookmarkApplicationSettingsApplication
data BookmarkApplicationSettingsApplication = BookmarkApplicationSettingsApplication
  { bookmarkApplicationSettingsApplicationRequestIntegration :: !(Maybe Bool) -- ^ "requestIntegration"
  , bookmarkApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BookmarkApplicationSettingsApplication
instance A.FromJSON BookmarkApplicationSettingsApplication where
  parseJSON = A.withObject "BookmarkApplicationSettingsApplication" $ \o ->
    BookmarkApplicationSettingsApplication
      <$> (o .:? "requestIntegration")
      <*> (o .:? "url")

-- | ToJSON BookmarkApplicationSettingsApplication
instance A.ToJSON BookmarkApplicationSettingsApplication where
  toJSON BookmarkApplicationSettingsApplication {..} =
   _omitNulls
      [ "requestIntegration" .= bookmarkApplicationSettingsApplicationRequestIntegration
      , "url" .= bookmarkApplicationSettingsApplicationUrl
      ]


-- | Construct a value of type 'BookmarkApplicationSettingsApplication' (by applying it's required fields, if any)
mkBookmarkApplicationSettingsApplication
  :: BookmarkApplicationSettingsApplication
mkBookmarkApplicationSettingsApplication =
  BookmarkApplicationSettingsApplication
  { bookmarkApplicationSettingsApplicationRequestIntegration = Nothing
  , bookmarkApplicationSettingsApplicationUrl = Nothing
  }

-- ** Brand
-- | Brand
data Brand = Brand
  { brandId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , brandAgreeToCustomPrivacyPolicy :: !(Maybe Bool) -- ^ "agreeToCustomPrivacyPolicy"
  , brandCustomPrivacyPolicyUrl :: !(Maybe Text) -- ^ "customPrivacyPolicyUrl"
  , brandRemovePoweredByOkta :: !(Maybe Bool) -- ^ "removePoweredByOkta"
  , brandLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Brand
instance A.FromJSON Brand where
  parseJSON = A.withObject "Brand" $ \o ->
    Brand
      <$> (o .:? "id")
      <*> (o .:? "agreeToCustomPrivacyPolicy")
      <*> (o .:? "customPrivacyPolicyUrl")
      <*> (o .:? "removePoweredByOkta")
      <*> (o .:? "_links")

-- | ToJSON Brand
instance A.ToJSON Brand where
  toJSON Brand {..} =
   _omitNulls
      [ "id" .= brandId
      , "agreeToCustomPrivacyPolicy" .= brandAgreeToCustomPrivacyPolicy
      , "customPrivacyPolicyUrl" .= brandCustomPrivacyPolicyUrl
      , "removePoweredByOkta" .= brandRemovePoweredByOkta
      , "_links" .= brandLinks
      ]


-- | Construct a value of type 'Brand' (by applying it's required fields, if any)
mkBrand
  :: Brand
mkBrand =
  Brand
  { brandId = Nothing
  , brandAgreeToCustomPrivacyPolicy = Nothing
  , brandCustomPrivacyPolicyUrl = Nothing
  , brandRemovePoweredByOkta = Nothing
  , brandLinks = Nothing
  }

-- ** BrowserPluginApplication
-- | BrowserPluginApplication
data BrowserPluginApplication = BrowserPluginApplication
  { browserPluginApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BrowserPluginApplication
instance A.FromJSON BrowserPluginApplication where
  parseJSON = A.withObject "BrowserPluginApplication" $ \o ->
    BrowserPluginApplication
      <$> (o .:? "credentials")

-- | ToJSON BrowserPluginApplication
instance A.ToJSON BrowserPluginApplication where
  toJSON BrowserPluginApplication {..} =
   _omitNulls
      [ "credentials" .= browserPluginApplicationCredentials
      ]


-- | Construct a value of type 'BrowserPluginApplication' (by applying it's required fields, if any)
mkBrowserPluginApplication
  :: BrowserPluginApplication
mkBrowserPluginApplication =
  BrowserPluginApplication
  { browserPluginApplicationCredentials = Nothing
  }

-- ** CallUserFactor
-- | CallUserFactor
data CallUserFactor = CallUserFactor
  { callUserFactorProfile :: !(Maybe CallUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CallUserFactor
instance A.FromJSON CallUserFactor where
  parseJSON = A.withObject "CallUserFactor" $ \o ->
    CallUserFactor
      <$> (o .:? "profile")

-- | ToJSON CallUserFactor
instance A.ToJSON CallUserFactor where
  toJSON CallUserFactor {..} =
   _omitNulls
      [ "profile" .= callUserFactorProfile
      ]


-- | Construct a value of type 'CallUserFactor' (by applying it's required fields, if any)
mkCallUserFactor
  :: CallUserFactor
mkCallUserFactor =
  CallUserFactor
  { callUserFactorProfile = Nothing
  }

-- ** CallUserFactorProfile
-- | CallUserFactorProfile
data CallUserFactorProfile = CallUserFactorProfile
  { callUserFactorProfilePhoneExtension :: !(Maybe Text) -- ^ "phoneExtension"
  , callUserFactorProfilePhoneNumber :: !(Maybe Text) -- ^ "phoneNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CallUserFactorProfile
instance A.FromJSON CallUserFactorProfile where
  parseJSON = A.withObject "CallUserFactorProfile" $ \o ->
    CallUserFactorProfile
      <$> (o .:? "phoneExtension")
      <*> (o .:? "phoneNumber")

-- | ToJSON CallUserFactorProfile
instance A.ToJSON CallUserFactorProfile where
  toJSON CallUserFactorProfile {..} =
   _omitNulls
      [ "phoneExtension" .= callUserFactorProfilePhoneExtension
      , "phoneNumber" .= callUserFactorProfilePhoneNumber
      ]


-- | Construct a value of type 'CallUserFactorProfile' (by applying it's required fields, if any)
mkCallUserFactorProfile
  :: CallUserFactorProfile
mkCallUserFactorProfile =
  CallUserFactorProfile
  { callUserFactorProfilePhoneExtension = Nothing
  , callUserFactorProfilePhoneNumber = Nothing
  }

-- ** CapabilitiesCreateObject
-- | CapabilitiesCreateObject
data CapabilitiesCreateObject = CapabilitiesCreateObject
  { capabilitiesCreateObjectLifecycleCreate :: !(Maybe LifecycleCreateSettingObject) -- ^ "lifecycleCreate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CapabilitiesCreateObject
instance A.FromJSON CapabilitiesCreateObject where
  parseJSON = A.withObject "CapabilitiesCreateObject" $ \o ->
    CapabilitiesCreateObject
      <$> (o .:? "lifecycleCreate")

-- | ToJSON CapabilitiesCreateObject
instance A.ToJSON CapabilitiesCreateObject where
  toJSON CapabilitiesCreateObject {..} =
   _omitNulls
      [ "lifecycleCreate" .= capabilitiesCreateObjectLifecycleCreate
      ]


-- | Construct a value of type 'CapabilitiesCreateObject' (by applying it's required fields, if any)
mkCapabilitiesCreateObject
  :: CapabilitiesCreateObject
mkCapabilitiesCreateObject =
  CapabilitiesCreateObject
  { capabilitiesCreateObjectLifecycleCreate = Nothing
  }

-- ** CapabilitiesObject
-- | CapabilitiesObject
data CapabilitiesObject = CapabilitiesObject
  { capabilitiesObjectCreate :: !(Maybe CapabilitiesCreateObject) -- ^ "create"
  , capabilitiesObjectUpdate :: !(Maybe CapabilitiesUpdateObject) -- ^ "update"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CapabilitiesObject
instance A.FromJSON CapabilitiesObject where
  parseJSON = A.withObject "CapabilitiesObject" $ \o ->
    CapabilitiesObject
      <$> (o .:? "create")
      <*> (o .:? "update")

-- | ToJSON CapabilitiesObject
instance A.ToJSON CapabilitiesObject where
  toJSON CapabilitiesObject {..} =
   _omitNulls
      [ "create" .= capabilitiesObjectCreate
      , "update" .= capabilitiesObjectUpdate
      ]


-- | Construct a value of type 'CapabilitiesObject' (by applying it's required fields, if any)
mkCapabilitiesObject
  :: CapabilitiesObject
mkCapabilitiesObject =
  CapabilitiesObject
  { capabilitiesObjectCreate = Nothing
  , capabilitiesObjectUpdate = Nothing
  }

-- ** CapabilitiesUpdateObject
-- | CapabilitiesUpdateObject
data CapabilitiesUpdateObject = CapabilitiesUpdateObject
  { capabilitiesUpdateObjectLifecycleDeactivate :: !(Maybe LifecycleDeactivateSettingObject) -- ^ "lifecycleDeactivate"
  , capabilitiesUpdateObjectPassword :: !(Maybe PasswordSettingObject) -- ^ "password"
  , capabilitiesUpdateObjectProfile :: !(Maybe ProfileSettingObject) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CapabilitiesUpdateObject
instance A.FromJSON CapabilitiesUpdateObject where
  parseJSON = A.withObject "CapabilitiesUpdateObject" $ \o ->
    CapabilitiesUpdateObject
      <$> (o .:? "lifecycleDeactivate")
      <*> (o .:? "password")
      <*> (o .:? "profile")

-- | ToJSON CapabilitiesUpdateObject
instance A.ToJSON CapabilitiesUpdateObject where
  toJSON CapabilitiesUpdateObject {..} =
   _omitNulls
      [ "lifecycleDeactivate" .= capabilitiesUpdateObjectLifecycleDeactivate
      , "password" .= capabilitiesUpdateObjectPassword
      , "profile" .= capabilitiesUpdateObjectProfile
      ]


-- | Construct a value of type 'CapabilitiesUpdateObject' (by applying it's required fields, if any)
mkCapabilitiesUpdateObject
  :: CapabilitiesUpdateObject
mkCapabilitiesUpdateObject =
  CapabilitiesUpdateObject
  { capabilitiesUpdateObjectLifecycleDeactivate = Nothing
  , capabilitiesUpdateObjectPassword = Nothing
  , capabilitiesUpdateObjectProfile = Nothing
  }

-- ** CatalogApplication
-- | CatalogApplication
data CatalogApplication = CatalogApplication
  { catalogApplicationId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , catalogApplicationName :: !(Maybe Text) -- ^ "name"
  , catalogApplicationDisplayName :: !(Maybe Text) -- ^ "displayName"
  , catalogApplicationDescription :: !(Maybe Text) -- ^ "description"
  , catalogApplicationStatus :: !(Maybe CatalogApplicationStatus) -- ^ "status"
  , catalogApplicationLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , catalogApplicationCategory :: !(Maybe Text) -- ^ "category"
  , catalogApplicationVerificationStatus :: !(Maybe Text) -- ^ "verificationStatus"
  , catalogApplicationWebsite :: !(Maybe Text) -- ^ "website"
  , catalogApplicationSignOnModes :: !(Maybe [Text]) -- ^ "signOnModes"
  , catalogApplicationFeatures :: !(Maybe [Text]) -- ^ "features"
  , catalogApplicationLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CatalogApplication
instance A.FromJSON CatalogApplication where
  parseJSON = A.withObject "CatalogApplication" $ \o ->
    CatalogApplication
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "displayName")
      <*> (o .:? "description")
      <*> (o .:? "status")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "category")
      <*> (o .:? "verificationStatus")
      <*> (o .:? "website")
      <*> (o .:? "signOnModes")
      <*> (o .:? "features")
      <*> (o .:? "_links")

-- | ToJSON CatalogApplication
instance A.ToJSON CatalogApplication where
  toJSON CatalogApplication {..} =
   _omitNulls
      [ "id" .= catalogApplicationId
      , "name" .= catalogApplicationName
      , "displayName" .= catalogApplicationDisplayName
      , "description" .= catalogApplicationDescription
      , "status" .= catalogApplicationStatus
      , "lastUpdated" .= catalogApplicationLastUpdated
      , "category" .= catalogApplicationCategory
      , "verificationStatus" .= catalogApplicationVerificationStatus
      , "website" .= catalogApplicationWebsite
      , "signOnModes" .= catalogApplicationSignOnModes
      , "features" .= catalogApplicationFeatures
      , "_links" .= catalogApplicationLinks
      ]


-- | Construct a value of type 'CatalogApplication' (by applying it's required fields, if any)
mkCatalogApplication
  :: CatalogApplication
mkCatalogApplication =
  CatalogApplication
  { catalogApplicationId = Nothing
  , catalogApplicationName = Nothing
  , catalogApplicationDisplayName = Nothing
  , catalogApplicationDescription = Nothing
  , catalogApplicationStatus = Nothing
  , catalogApplicationLastUpdated = Nothing
  , catalogApplicationCategory = Nothing
  , catalogApplicationVerificationStatus = Nothing
  , catalogApplicationWebsite = Nothing
  , catalogApplicationSignOnModes = Nothing
  , catalogApplicationFeatures = Nothing
  , catalogApplicationLinks = Nothing
  }

-- ** ChangePasswordRequest
-- | ChangePasswordRequest
data ChangePasswordRequest = ChangePasswordRequest
  { changePasswordRequestNewPassword :: !(Maybe PasswordCredential) -- ^ "newPassword"
  , changePasswordRequestOldPassword :: !(Maybe PasswordCredential) -- ^ "oldPassword"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChangePasswordRequest
instance A.FromJSON ChangePasswordRequest where
  parseJSON = A.withObject "ChangePasswordRequest" $ \o ->
    ChangePasswordRequest
      <$> (o .:? "newPassword")
      <*> (o .:? "oldPassword")

-- | ToJSON ChangePasswordRequest
instance A.ToJSON ChangePasswordRequest where
  toJSON ChangePasswordRequest {..} =
   _omitNulls
      [ "newPassword" .= changePasswordRequestNewPassword
      , "oldPassword" .= changePasswordRequestOldPassword
      ]


-- | Construct a value of type 'ChangePasswordRequest' (by applying it's required fields, if any)
mkChangePasswordRequest
  :: ChangePasswordRequest
mkChangePasswordRequest =
  ChangePasswordRequest
  { changePasswordRequestNewPassword = Nothing
  , changePasswordRequestOldPassword = Nothing
  }

-- ** ChannelBinding
-- | ChannelBinding
data ChannelBinding = ChannelBinding
  { channelBindingStyle :: !(Maybe Text) -- ^ "style"
  , channelBindingRequired :: !(Maybe RequiredEnum) -- ^ "required"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChannelBinding
instance A.FromJSON ChannelBinding where
  parseJSON = A.withObject "ChannelBinding" $ \o ->
    ChannelBinding
      <$> (o .:? "style")
      <*> (o .:? "required")

-- | ToJSON ChannelBinding
instance A.ToJSON ChannelBinding where
  toJSON ChannelBinding {..} =
   _omitNulls
      [ "style" .= channelBindingStyle
      , "required" .= channelBindingRequired
      ]


-- | Construct a value of type 'ChannelBinding' (by applying it's required fields, if any)
mkChannelBinding
  :: ChannelBinding
mkChannelBinding =
  ChannelBinding
  { channelBindingStyle = Nothing
  , channelBindingRequired = Nothing
  }

-- ** ClientPolicyCondition
-- | ClientPolicyCondition
data ClientPolicyCondition = ClientPolicyCondition
  { clientPolicyConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClientPolicyCondition
instance A.FromJSON ClientPolicyCondition where
  parseJSON = A.withObject "ClientPolicyCondition" $ \o ->
    ClientPolicyCondition
      <$> (o .:? "include")

-- | ToJSON ClientPolicyCondition
instance A.ToJSON ClientPolicyCondition where
  toJSON ClientPolicyCondition {..} =
   _omitNulls
      [ "include" .= clientPolicyConditionInclude
      ]


-- | Construct a value of type 'ClientPolicyCondition' (by applying it's required fields, if any)
mkClientPolicyCondition
  :: ClientPolicyCondition
mkClientPolicyCondition =
  ClientPolicyCondition
  { clientPolicyConditionInclude = Nothing
  }

-- ** Compliance
-- | Compliance
data Compliance = Compliance
  { complianceFips :: !(Maybe FipsEnum) -- ^ "fips"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Compliance
instance A.FromJSON Compliance where
  parseJSON = A.withObject "Compliance" $ \o ->
    Compliance
      <$> (o .:? "fips")

-- | ToJSON Compliance
instance A.ToJSON Compliance where
  toJSON Compliance {..} =
   _omitNulls
      [ "fips" .= complianceFips
      ]


-- | Construct a value of type 'Compliance' (by applying it's required fields, if any)
mkCompliance
  :: Compliance
mkCompliance =
  Compliance
  { complianceFips = Nothing
  }

-- ** ContextPolicyRuleCondition
-- | ContextPolicyRuleCondition
data ContextPolicyRuleCondition = ContextPolicyRuleCondition
  { contextPolicyRuleConditionExpression :: !(Maybe Text) -- ^ "expression"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContextPolicyRuleCondition
instance A.FromJSON ContextPolicyRuleCondition where
  parseJSON = A.withObject "ContextPolicyRuleCondition" $ \o ->
    ContextPolicyRuleCondition
      <$> (o .:? "expression")

-- | ToJSON ContextPolicyRuleCondition
instance A.ToJSON ContextPolicyRuleCondition where
  toJSON ContextPolicyRuleCondition {..} =
   _omitNulls
      [ "expression" .= contextPolicyRuleConditionExpression
      ]


-- | Construct a value of type 'ContextPolicyRuleCondition' (by applying it's required fields, if any)
mkContextPolicyRuleCondition
  :: ContextPolicyRuleCondition
mkContextPolicyRuleCondition =
  ContextPolicyRuleCondition
  { contextPolicyRuleConditionExpression = Nothing
  }

-- ** CreateSessionRequest
-- | CreateSessionRequest
data CreateSessionRequest = CreateSessionRequest
  { createSessionRequestSessionToken :: !(Maybe Text) -- ^ "sessionToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSessionRequest
instance A.FromJSON CreateSessionRequest where
  parseJSON = A.withObject "CreateSessionRequest" $ \o ->
    CreateSessionRequest
      <$> (o .:? "sessionToken")

-- | ToJSON CreateSessionRequest
instance A.ToJSON CreateSessionRequest where
  toJSON CreateSessionRequest {..} =
   _omitNulls
      [ "sessionToken" .= createSessionRequestSessionToken
      ]


-- | Construct a value of type 'CreateSessionRequest' (by applying it's required fields, if any)
mkCreateSessionRequest
  :: CreateSessionRequest
mkCreateSessionRequest =
  CreateSessionRequest
  { createSessionRequestSessionToken = Nothing
  }

-- ** CreateUserRequest
-- | CreateUserRequest
data CreateUserRequest = CreateUserRequest
  { createUserRequestCredentials :: !(Maybe UserCredentials) -- ^ "credentials"
  , createUserRequestGroupIds :: !(Maybe [Text]) -- ^ "groupIds"
  , createUserRequestProfile :: !(Maybe UserProfile) -- ^ "profile"
  , createUserRequestType :: !(Maybe UserType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateUserRequest
instance A.FromJSON CreateUserRequest where
  parseJSON = A.withObject "CreateUserRequest" $ \o ->
    CreateUserRequest
      <$> (o .:? "credentials")
      <*> (o .:? "groupIds")
      <*> (o .:? "profile")
      <*> (o .:? "type")

-- | ToJSON CreateUserRequest
instance A.ToJSON CreateUserRequest where
  toJSON CreateUserRequest {..} =
   _omitNulls
      [ "credentials" .= createUserRequestCredentials
      , "groupIds" .= createUserRequestGroupIds
      , "profile" .= createUserRequestProfile
      , "type" .= createUserRequestType
      ]


-- | Construct a value of type 'CreateUserRequest' (by applying it's required fields, if any)
mkCreateUserRequest
  :: CreateUserRequest
mkCreateUserRequest =
  CreateUserRequest
  { createUserRequestCredentials = Nothing
  , createUserRequestGroupIds = Nothing
  , createUserRequestProfile = Nothing
  , createUserRequestType = Nothing
  }

-- ** Csr
-- | Csr
data Csr = Csr
  { csrCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , csrCsr :: !(Maybe Text) -- ^ /ReadOnly/ "csr"
  , csrId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , csrKty :: !(Maybe Text) -- ^ /ReadOnly/ "kty"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Csr
instance A.FromJSON Csr where
  parseJSON = A.withObject "Csr" $ \o ->
    Csr
      <$> (o .:? "created")
      <*> (o .:? "csr")
      <*> (o .:? "id")
      <*> (o .:? "kty")

-- | ToJSON Csr
instance A.ToJSON Csr where
  toJSON Csr {..} =
   _omitNulls
      [ "created" .= csrCreated
      , "csr" .= csrCsr
      , "id" .= csrId
      , "kty" .= csrKty
      ]


-- | Construct a value of type 'Csr' (by applying it's required fields, if any)
mkCsr
  :: Csr
mkCsr =
  Csr
  { csrCreated = Nothing
  , csrCsr = Nothing
  , csrId = Nothing
  , csrKty = Nothing
  }

-- ** CsrMetadata
-- | CsrMetadata
data CsrMetadata = CsrMetadata
  { csrMetadataSubject :: !(Maybe CsrMetadataSubject) -- ^ "subject"
  , csrMetadataSubjectAltNames :: !(Maybe CsrMetadataSubjectAltNames) -- ^ "subjectAltNames"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CsrMetadata
instance A.FromJSON CsrMetadata where
  parseJSON = A.withObject "CsrMetadata" $ \o ->
    CsrMetadata
      <$> (o .:? "subject")
      <*> (o .:? "subjectAltNames")

-- | ToJSON CsrMetadata
instance A.ToJSON CsrMetadata where
  toJSON CsrMetadata {..} =
   _omitNulls
      [ "subject" .= csrMetadataSubject
      , "subjectAltNames" .= csrMetadataSubjectAltNames
      ]


-- | Construct a value of type 'CsrMetadata' (by applying it's required fields, if any)
mkCsrMetadata
  :: CsrMetadata
mkCsrMetadata =
  CsrMetadata
  { csrMetadataSubject = Nothing
  , csrMetadataSubjectAltNames = Nothing
  }

-- ** CsrMetadataSubject
-- | CsrMetadataSubject
data CsrMetadataSubject = CsrMetadataSubject
  { csrMetadataSubjectCommonName :: !(Maybe Text) -- ^ "commonName"
  , csrMetadataSubjectCountryName :: !(Maybe Text) -- ^ "countryName"
  , csrMetadataSubjectLocalityName :: !(Maybe Text) -- ^ "localityName"
  , csrMetadataSubjectOrganizationName :: !(Maybe Text) -- ^ "organizationName"
  , csrMetadataSubjectOrganizationalUnitName :: !(Maybe Text) -- ^ "organizationalUnitName"
  , csrMetadataSubjectStateOrProvinceName :: !(Maybe Text) -- ^ "stateOrProvinceName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CsrMetadataSubject
instance A.FromJSON CsrMetadataSubject where
  parseJSON = A.withObject "CsrMetadataSubject" $ \o ->
    CsrMetadataSubject
      <$> (o .:? "commonName")
      <*> (o .:? "countryName")
      <*> (o .:? "localityName")
      <*> (o .:? "organizationName")
      <*> (o .:? "organizationalUnitName")
      <*> (o .:? "stateOrProvinceName")

-- | ToJSON CsrMetadataSubject
instance A.ToJSON CsrMetadataSubject where
  toJSON CsrMetadataSubject {..} =
   _omitNulls
      [ "commonName" .= csrMetadataSubjectCommonName
      , "countryName" .= csrMetadataSubjectCountryName
      , "localityName" .= csrMetadataSubjectLocalityName
      , "organizationName" .= csrMetadataSubjectOrganizationName
      , "organizationalUnitName" .= csrMetadataSubjectOrganizationalUnitName
      , "stateOrProvinceName" .= csrMetadataSubjectStateOrProvinceName
      ]


-- | Construct a value of type 'CsrMetadataSubject' (by applying it's required fields, if any)
mkCsrMetadataSubject
  :: CsrMetadataSubject
mkCsrMetadataSubject =
  CsrMetadataSubject
  { csrMetadataSubjectCommonName = Nothing
  , csrMetadataSubjectCountryName = Nothing
  , csrMetadataSubjectLocalityName = Nothing
  , csrMetadataSubjectOrganizationName = Nothing
  , csrMetadataSubjectOrganizationalUnitName = Nothing
  , csrMetadataSubjectStateOrProvinceName = Nothing
  }

-- ** CsrMetadataSubjectAltNames
-- | CsrMetadataSubjectAltNames
data CsrMetadataSubjectAltNames = CsrMetadataSubjectAltNames
  { csrMetadataSubjectAltNamesDnsNames :: !(Maybe [Text]) -- ^ "dnsNames"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CsrMetadataSubjectAltNames
instance A.FromJSON CsrMetadataSubjectAltNames where
  parseJSON = A.withObject "CsrMetadataSubjectAltNames" $ \o ->
    CsrMetadataSubjectAltNames
      <$> (o .:? "dnsNames")

-- | ToJSON CsrMetadataSubjectAltNames
instance A.ToJSON CsrMetadataSubjectAltNames where
  toJSON CsrMetadataSubjectAltNames {..} =
   _omitNulls
      [ "dnsNames" .= csrMetadataSubjectAltNamesDnsNames
      ]


-- | Construct a value of type 'CsrMetadataSubjectAltNames' (by applying it's required fields, if any)
mkCsrMetadataSubjectAltNames
  :: CsrMetadataSubjectAltNames
mkCsrMetadataSubjectAltNames =
  CsrMetadataSubjectAltNames
  { csrMetadataSubjectAltNamesDnsNames = Nothing
  }

-- ** CustomHotpUserFactor
-- | CustomHotpUserFactor
data CustomHotpUserFactor = CustomHotpUserFactor
  { customHotpUserFactorFactorProfileId :: !(Maybe Text) -- ^ "factorProfileId"
  , customHotpUserFactorProfile :: !(Maybe CustomHotpUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomHotpUserFactor
instance A.FromJSON CustomHotpUserFactor where
  parseJSON = A.withObject "CustomHotpUserFactor" $ \o ->
    CustomHotpUserFactor
      <$> (o .:? "factorProfileId")
      <*> (o .:? "profile")

-- | ToJSON CustomHotpUserFactor
instance A.ToJSON CustomHotpUserFactor where
  toJSON CustomHotpUserFactor {..} =
   _omitNulls
      [ "factorProfileId" .= customHotpUserFactorFactorProfileId
      , "profile" .= customHotpUserFactorProfile
      ]


-- | Construct a value of type 'CustomHotpUserFactor' (by applying it's required fields, if any)
mkCustomHotpUserFactor
  :: CustomHotpUserFactor
mkCustomHotpUserFactor =
  CustomHotpUserFactor
  { customHotpUserFactorFactorProfileId = Nothing
  , customHotpUserFactorProfile = Nothing
  }

-- ** CustomHotpUserFactorProfile
-- | CustomHotpUserFactorProfile
data CustomHotpUserFactorProfile = CustomHotpUserFactorProfile
  { customHotpUserFactorProfileSharedSecret :: !(Maybe Text) -- ^ "sharedSecret"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomHotpUserFactorProfile
instance A.FromJSON CustomHotpUserFactorProfile where
  parseJSON = A.withObject "CustomHotpUserFactorProfile" $ \o ->
    CustomHotpUserFactorProfile
      <$> (o .:? "sharedSecret")

-- | ToJSON CustomHotpUserFactorProfile
instance A.ToJSON CustomHotpUserFactorProfile where
  toJSON CustomHotpUserFactorProfile {..} =
   _omitNulls
      [ "sharedSecret" .= customHotpUserFactorProfileSharedSecret
      ]


-- | Construct a value of type 'CustomHotpUserFactorProfile' (by applying it's required fields, if any)
mkCustomHotpUserFactorProfile
  :: CustomHotpUserFactorProfile
mkCustomHotpUserFactorProfile =
  CustomHotpUserFactorProfile
  { customHotpUserFactorProfileSharedSecret = Nothing
  }

-- ** DNSRecord
-- | DNSRecord
data DNSRecord = DNSRecord
  { dNSRecordExpiration :: !(Maybe Text) -- ^ "expiration"
  , dNSRecordFqdn :: !(Maybe Text) -- ^ "fqdn"
  , dNSRecordRecordType :: !(Maybe DNSRecordType) -- ^ "recordType"
  , dNSRecordValues :: !(Maybe [Text]) -- ^ "values"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DNSRecord
instance A.FromJSON DNSRecord where
  parseJSON = A.withObject "DNSRecord" $ \o ->
    DNSRecord
      <$> (o .:? "expiration")
      <*> (o .:? "fqdn")
      <*> (o .:? "recordType")
      <*> (o .:? "values")

-- | ToJSON DNSRecord
instance A.ToJSON DNSRecord where
  toJSON DNSRecord {..} =
   _omitNulls
      [ "expiration" .= dNSRecordExpiration
      , "fqdn" .= dNSRecordFqdn
      , "recordType" .= dNSRecordRecordType
      , "values" .= dNSRecordValues
      ]


-- | Construct a value of type 'DNSRecord' (by applying it's required fields, if any)
mkDNSRecord
  :: DNSRecord
mkDNSRecord =
  DNSRecord
  { dNSRecordExpiration = Nothing
  , dNSRecordFqdn = Nothing
  , dNSRecordRecordType = Nothing
  , dNSRecordValues = Nothing
  }

-- ** DeviceAccessPolicyRuleCondition
-- | DeviceAccessPolicyRuleCondition
data DeviceAccessPolicyRuleCondition = DeviceAccessPolicyRuleCondition
  { deviceAccessPolicyRuleConditionRegistered :: !(Maybe Bool) -- ^ "registered"
  , deviceAccessPolicyRuleConditionManaged :: !(Maybe Bool) -- ^ "managed"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeviceAccessPolicyRuleCondition
instance A.FromJSON DeviceAccessPolicyRuleCondition where
  parseJSON = A.withObject "DeviceAccessPolicyRuleCondition" $ \o ->
    DeviceAccessPolicyRuleCondition
      <$> (o .:? "registered")
      <*> (o .:? "managed")

-- | ToJSON DeviceAccessPolicyRuleCondition
instance A.ToJSON DeviceAccessPolicyRuleCondition where
  toJSON DeviceAccessPolicyRuleCondition {..} =
   _omitNulls
      [ "registered" .= deviceAccessPolicyRuleConditionRegistered
      , "managed" .= deviceAccessPolicyRuleConditionManaged
      ]


-- | Construct a value of type 'DeviceAccessPolicyRuleCondition' (by applying it's required fields, if any)
mkDeviceAccessPolicyRuleCondition
  :: DeviceAccessPolicyRuleCondition
mkDeviceAccessPolicyRuleCondition =
  DeviceAccessPolicyRuleCondition
  { deviceAccessPolicyRuleConditionRegistered = Nothing
  , deviceAccessPolicyRuleConditionManaged = Nothing
  }

-- ** DevicePolicyRuleCondition
-- | DevicePolicyRuleCondition
data DevicePolicyRuleCondition = DevicePolicyRuleCondition
  { devicePolicyRuleConditionMigrated :: !(Maybe Bool) -- ^ "migrated"
  , devicePolicyRuleConditionPlatform :: !(Maybe DevicePolicyRuleConditionPlatform) -- ^ "platform"
  , devicePolicyRuleConditionRooted :: !(Maybe Bool) -- ^ "rooted"
  , devicePolicyRuleConditionTrustLevel :: !(Maybe E'TrustLevel) -- ^ "trustLevel"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DevicePolicyRuleCondition
instance A.FromJSON DevicePolicyRuleCondition where
  parseJSON = A.withObject "DevicePolicyRuleCondition" $ \o ->
    DevicePolicyRuleCondition
      <$> (o .:? "migrated")
      <*> (o .:? "platform")
      <*> (o .:? "rooted")
      <*> (o .:? "trustLevel")

-- | ToJSON DevicePolicyRuleCondition
instance A.ToJSON DevicePolicyRuleCondition where
  toJSON DevicePolicyRuleCondition {..} =
   _omitNulls
      [ "migrated" .= devicePolicyRuleConditionMigrated
      , "platform" .= devicePolicyRuleConditionPlatform
      , "rooted" .= devicePolicyRuleConditionRooted
      , "trustLevel" .= devicePolicyRuleConditionTrustLevel
      ]


-- | Construct a value of type 'DevicePolicyRuleCondition' (by applying it's required fields, if any)
mkDevicePolicyRuleCondition
  :: DevicePolicyRuleCondition
mkDevicePolicyRuleCondition =
  DevicePolicyRuleCondition
  { devicePolicyRuleConditionMigrated = Nothing
  , devicePolicyRuleConditionPlatform = Nothing
  , devicePolicyRuleConditionRooted = Nothing
  , devicePolicyRuleConditionTrustLevel = Nothing
  }

-- ** DevicePolicyRuleConditionPlatform
-- | DevicePolicyRuleConditionPlatform
data DevicePolicyRuleConditionPlatform = DevicePolicyRuleConditionPlatform
  { devicePolicyRuleConditionPlatformSupportedMdmFrameworks :: !(Maybe [E'SupportedMdmFrameworks]) -- ^ "supportedMDMFrameworks"
  , devicePolicyRuleConditionPlatformTypes :: !(Maybe [E'Types]) -- ^ "types"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DevicePolicyRuleConditionPlatform
instance A.FromJSON DevicePolicyRuleConditionPlatform where
  parseJSON = A.withObject "DevicePolicyRuleConditionPlatform" $ \o ->
    DevicePolicyRuleConditionPlatform
      <$> (o .:? "supportedMDMFrameworks")
      <*> (o .:? "types")

-- | ToJSON DevicePolicyRuleConditionPlatform
instance A.ToJSON DevicePolicyRuleConditionPlatform where
  toJSON DevicePolicyRuleConditionPlatform {..} =
   _omitNulls
      [ "supportedMDMFrameworks" .= devicePolicyRuleConditionPlatformSupportedMdmFrameworks
      , "types" .= devicePolicyRuleConditionPlatformTypes
      ]


-- | Construct a value of type 'DevicePolicyRuleConditionPlatform' (by applying it's required fields, if any)
mkDevicePolicyRuleConditionPlatform
  :: DevicePolicyRuleConditionPlatform
mkDevicePolicyRuleConditionPlatform =
  DevicePolicyRuleConditionPlatform
  { devicePolicyRuleConditionPlatformSupportedMdmFrameworks = Nothing
  , devicePolicyRuleConditionPlatformTypes = Nothing
  }

-- ** Domain
-- | Domain
data Domain = Domain
  { domainId :: !(Maybe Text) -- ^ "id"
  , domainCertificateSourceType :: !(Maybe DomainCertificateSourceType) -- ^ "certificateSourceType"
  , domainDomain :: !(Maybe Text) -- ^ "domain"
  , domainDnsRecords :: !(Maybe [DNSRecord]) -- ^ "dnsRecords"
  , domainPublicCertificate :: !(Maybe DomainCertificateMetadata) -- ^ "publicCertificate"
  , domainValidationStatus :: !(Maybe DomainValidationStatus) -- ^ "validationStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Domain
instance A.FromJSON Domain where
  parseJSON = A.withObject "Domain" $ \o ->
    Domain
      <$> (o .:? "id")
      <*> (o .:? "certificateSourceType")
      <*> (o .:? "domain")
      <*> (o .:? "dnsRecords")
      <*> (o .:? "publicCertificate")
      <*> (o .:? "validationStatus")

-- | ToJSON Domain
instance A.ToJSON Domain where
  toJSON Domain {..} =
   _omitNulls
      [ "id" .= domainId
      , "certificateSourceType" .= domainCertificateSourceType
      , "domain" .= domainDomain
      , "dnsRecords" .= domainDnsRecords
      , "publicCertificate" .= domainPublicCertificate
      , "validationStatus" .= domainValidationStatus
      ]


-- | Construct a value of type 'Domain' (by applying it's required fields, if any)
mkDomain
  :: Domain
mkDomain =
  Domain
  { domainId = Nothing
  , domainCertificateSourceType = Nothing
  , domainDomain = Nothing
  , domainDnsRecords = Nothing
  , domainPublicCertificate = Nothing
  , domainValidationStatus = Nothing
  }

-- ** DomainCertificate
-- | DomainCertificate
data DomainCertificate = DomainCertificate
  { domainCertificateCertificate :: !(Maybe Text) -- ^ "certificate"
  , domainCertificateCertificateChain :: !(Maybe Text) -- ^ "certificateChain"
  , domainCertificatePrivateKey :: !(Maybe Text) -- ^ "privateKey"
  , domainCertificateType :: !(Maybe DomainCertificateType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DomainCertificate
instance A.FromJSON DomainCertificate where
  parseJSON = A.withObject "DomainCertificate" $ \o ->
    DomainCertificate
      <$> (o .:? "certificate")
      <*> (o .:? "certificateChain")
      <*> (o .:? "privateKey")
      <*> (o .:? "type")

-- | ToJSON DomainCertificate
instance A.ToJSON DomainCertificate where
  toJSON DomainCertificate {..} =
   _omitNulls
      [ "certificate" .= domainCertificateCertificate
      , "certificateChain" .= domainCertificateCertificateChain
      , "privateKey" .= domainCertificatePrivateKey
      , "type" .= domainCertificateType
      ]


-- | Construct a value of type 'DomainCertificate' (by applying it's required fields, if any)
mkDomainCertificate
  :: DomainCertificate
mkDomainCertificate =
  DomainCertificate
  { domainCertificateCertificate = Nothing
  , domainCertificateCertificateChain = Nothing
  , domainCertificatePrivateKey = Nothing
  , domainCertificateType = Nothing
  }

-- ** DomainCertificateMetadata
-- | DomainCertificateMetadata
data DomainCertificateMetadata = DomainCertificateMetadata
  { domainCertificateMetadataExpiration :: !(Maybe Text) -- ^ "expiration"
  , domainCertificateMetadataFingerprint :: !(Maybe Text) -- ^ "fingerprint"
  , domainCertificateMetadataSubject :: !(Maybe Text) -- ^ "subject"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DomainCertificateMetadata
instance A.FromJSON DomainCertificateMetadata where
  parseJSON = A.withObject "DomainCertificateMetadata" $ \o ->
    DomainCertificateMetadata
      <$> (o .:? "expiration")
      <*> (o .:? "fingerprint")
      <*> (o .:? "subject")

-- | ToJSON DomainCertificateMetadata
instance A.ToJSON DomainCertificateMetadata where
  toJSON DomainCertificateMetadata {..} =
   _omitNulls
      [ "expiration" .= domainCertificateMetadataExpiration
      , "fingerprint" .= domainCertificateMetadataFingerprint
      , "subject" .= domainCertificateMetadataSubject
      ]


-- | Construct a value of type 'DomainCertificateMetadata' (by applying it's required fields, if any)
mkDomainCertificateMetadata
  :: DomainCertificateMetadata
mkDomainCertificateMetadata =
  DomainCertificateMetadata
  { domainCertificateMetadataExpiration = Nothing
  , domainCertificateMetadataFingerprint = Nothing
  , domainCertificateMetadataSubject = Nothing
  }

-- ** DomainListResponse
-- | DomainListResponse
data DomainListResponse = DomainListResponse
  { domainListResponseDomains :: !(Maybe [Domain]) -- ^ "domains"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DomainListResponse
instance A.FromJSON DomainListResponse where
  parseJSON = A.withObject "DomainListResponse" $ \o ->
    DomainListResponse
      <$> (o .:? "domains")

-- | ToJSON DomainListResponse
instance A.ToJSON DomainListResponse where
  toJSON DomainListResponse {..} =
   _omitNulls
      [ "domains" .= domainListResponseDomains
      ]


-- | Construct a value of type 'DomainListResponse' (by applying it's required fields, if any)
mkDomainListResponse
  :: DomainListResponse
mkDomainListResponse =
  DomainListResponse
  { domainListResponseDomains = Nothing
  }

-- ** Duration
-- | Duration
data Duration = Duration
  { durationNumber :: !(Maybe Int) -- ^ "number"
  , durationUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Duration
instance A.FromJSON Duration where
  parseJSON = A.withObject "Duration" $ \o ->
    Duration
      <$> (o .:? "number")
      <*> (o .:? "unit")

-- | ToJSON Duration
instance A.ToJSON Duration where
  toJSON Duration {..} =
   _omitNulls
      [ "number" .= durationNumber
      , "unit" .= durationUnit
      ]


-- | Construct a value of type 'Duration' (by applying it's required fields, if any)
mkDuration
  :: Duration
mkDuration =
  Duration
  { durationNumber = Nothing
  , durationUnit = Nothing
  }

-- ** EmailTemplate
-- | EmailTemplate
data EmailTemplate = EmailTemplate
  { emailTemplateName :: !(Maybe Text) -- ^ /ReadOnly/ "name"
  , emailTemplateLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailTemplate
instance A.FromJSON EmailTemplate where
  parseJSON = A.withObject "EmailTemplate" $ \o ->
    EmailTemplate
      <$> (o .:? "name")
      <*> (o .:? "_links")

-- | ToJSON EmailTemplate
instance A.ToJSON EmailTemplate where
  toJSON EmailTemplate {..} =
   _omitNulls
      [ "name" .= emailTemplateName
      , "_links" .= emailTemplateLinks
      ]


-- | Construct a value of type 'EmailTemplate' (by applying it's required fields, if any)
mkEmailTemplate
  :: EmailTemplate
mkEmailTemplate =
  EmailTemplate
  { emailTemplateName = Nothing
  , emailTemplateLinks = Nothing
  }

-- ** EmailTemplateContent
-- | EmailTemplateContent
data EmailTemplateContent = EmailTemplateContent
  { emailTemplateContentBody :: !(Maybe Text) -- ^ "body"
  , emailTemplateContentFromAddress :: !(Maybe Text) -- ^ "fromAddress"
  , emailTemplateContentFromName :: !(Maybe Text) -- ^ "fromName"
  , emailTemplateContentSubject :: !(Maybe Text) -- ^ "subject"
  , emailTemplateContentLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailTemplateContent
instance A.FromJSON EmailTemplateContent where
  parseJSON = A.withObject "EmailTemplateContent" $ \o ->
    EmailTemplateContent
      <$> (o .:? "body")
      <*> (o .:? "fromAddress")
      <*> (o .:? "fromName")
      <*> (o .:? "subject")
      <*> (o .:? "_links")

-- | ToJSON EmailTemplateContent
instance A.ToJSON EmailTemplateContent where
  toJSON EmailTemplateContent {..} =
   _omitNulls
      [ "body" .= emailTemplateContentBody
      , "fromAddress" .= emailTemplateContentFromAddress
      , "fromName" .= emailTemplateContentFromName
      , "subject" .= emailTemplateContentSubject
      , "_links" .= emailTemplateContentLinks
      ]


-- | Construct a value of type 'EmailTemplateContent' (by applying it's required fields, if any)
mkEmailTemplateContent
  :: EmailTemplateContent
mkEmailTemplateContent =
  EmailTemplateContent
  { emailTemplateContentBody = Nothing
  , emailTemplateContentFromAddress = Nothing
  , emailTemplateContentFromName = Nothing
  , emailTemplateContentSubject = Nothing
  , emailTemplateContentLinks = Nothing
  }

-- ** EmailTemplateCustomization
-- | EmailTemplateCustomization
data EmailTemplateCustomization = EmailTemplateCustomization
  { emailTemplateCustomizationBody :: !(Maybe Text) -- ^ "body"
  , emailTemplateCustomizationLanguage :: !(Maybe Text) -- ^ "language" - unique under each email template
  , emailTemplateCustomizationSubject :: !(Maybe Text) -- ^ "subject"
  , emailTemplateCustomizationId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , emailTemplateCustomizationCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , emailTemplateCustomizationIsDefault :: !(Maybe Bool) -- ^ "isDefault"
  , emailTemplateCustomizationLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , emailTemplateCustomizationLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailTemplateCustomization
instance A.FromJSON EmailTemplateCustomization where
  parseJSON = A.withObject "EmailTemplateCustomization" $ \o ->
    EmailTemplateCustomization
      <$> (o .:? "body")
      <*> (o .:? "language")
      <*> (o .:? "subject")
      <*> (o .:? "id")
      <*> (o .:? "created")
      <*> (o .:? "isDefault")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "_links")

-- | ToJSON EmailTemplateCustomization
instance A.ToJSON EmailTemplateCustomization where
  toJSON EmailTemplateCustomization {..} =
   _omitNulls
      [ "body" .= emailTemplateCustomizationBody
      , "language" .= emailTemplateCustomizationLanguage
      , "subject" .= emailTemplateCustomizationSubject
      , "id" .= emailTemplateCustomizationId
      , "created" .= emailTemplateCustomizationCreated
      , "isDefault" .= emailTemplateCustomizationIsDefault
      , "lastUpdated" .= emailTemplateCustomizationLastUpdated
      , "_links" .= emailTemplateCustomizationLinks
      ]


-- | Construct a value of type 'EmailTemplateCustomization' (by applying it's required fields, if any)
mkEmailTemplateCustomization
  :: EmailTemplateCustomization
mkEmailTemplateCustomization =
  EmailTemplateCustomization
  { emailTemplateCustomizationBody = Nothing
  , emailTemplateCustomizationLanguage = Nothing
  , emailTemplateCustomizationSubject = Nothing
  , emailTemplateCustomizationId = Nothing
  , emailTemplateCustomizationCreated = Nothing
  , emailTemplateCustomizationIsDefault = Nothing
  , emailTemplateCustomizationLastUpdated = Nothing
  , emailTemplateCustomizationLinks = Nothing
  }

-- ** EmailTemplateCustomizationRequest
-- | EmailTemplateCustomizationRequest
data EmailTemplateCustomizationRequest = EmailTemplateCustomizationRequest
  { emailTemplateCustomizationRequestBody :: !(Maybe Text) -- ^ "body"
  , emailTemplateCustomizationRequestLanguage :: !(Maybe Text) -- ^ "language" - unique under each email template
  , emailTemplateCustomizationRequestSubject :: !(Maybe Text) -- ^ "subject"
  , emailTemplateCustomizationRequestIsDefault :: !(Maybe Bool) -- ^ "isDefault"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailTemplateCustomizationRequest
instance A.FromJSON EmailTemplateCustomizationRequest where
  parseJSON = A.withObject "EmailTemplateCustomizationRequest" $ \o ->
    EmailTemplateCustomizationRequest
      <$> (o .:? "body")
      <*> (o .:? "language")
      <*> (o .:? "subject")
      <*> (o .:? "isDefault")

-- | ToJSON EmailTemplateCustomizationRequest
instance A.ToJSON EmailTemplateCustomizationRequest where
  toJSON EmailTemplateCustomizationRequest {..} =
   _omitNulls
      [ "body" .= emailTemplateCustomizationRequestBody
      , "language" .= emailTemplateCustomizationRequestLanguage
      , "subject" .= emailTemplateCustomizationRequestSubject
      , "isDefault" .= emailTemplateCustomizationRequestIsDefault
      ]


-- | Construct a value of type 'EmailTemplateCustomizationRequest' (by applying it's required fields, if any)
mkEmailTemplateCustomizationRequest
  :: EmailTemplateCustomizationRequest
mkEmailTemplateCustomizationRequest =
  EmailTemplateCustomizationRequest
  { emailTemplateCustomizationRequestBody = Nothing
  , emailTemplateCustomizationRequestLanguage = Nothing
  , emailTemplateCustomizationRequestSubject = Nothing
  , emailTemplateCustomizationRequestIsDefault = Nothing
  }

-- ** EmailTemplateTestRequest
-- | EmailTemplateTestRequest
data EmailTemplateTestRequest = EmailTemplateTestRequest
  { emailTemplateTestRequestCustomizationId :: !(Maybe Text) -- ^ "customizationId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailTemplateTestRequest
instance A.FromJSON EmailTemplateTestRequest where
  parseJSON = A.withObject "EmailTemplateTestRequest" $ \o ->
    EmailTemplateTestRequest
      <$> (o .:? "customizationId")

-- | ToJSON EmailTemplateTestRequest
instance A.ToJSON EmailTemplateTestRequest where
  toJSON EmailTemplateTestRequest {..} =
   _omitNulls
      [ "customizationId" .= emailTemplateTestRequestCustomizationId
      ]


-- | Construct a value of type 'EmailTemplateTestRequest' (by applying it's required fields, if any)
mkEmailTemplateTestRequest
  :: EmailTemplateTestRequest
mkEmailTemplateTestRequest =
  EmailTemplateTestRequest
  { emailTemplateTestRequestCustomizationId = Nothing
  }

-- ** EmailUserFactor
-- | EmailUserFactor
data EmailUserFactor = EmailUserFactor
  { emailUserFactorProfile :: !(Maybe EmailUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailUserFactor
instance A.FromJSON EmailUserFactor where
  parseJSON = A.withObject "EmailUserFactor" $ \o ->
    EmailUserFactor
      <$> (o .:? "profile")

-- | ToJSON EmailUserFactor
instance A.ToJSON EmailUserFactor where
  toJSON EmailUserFactor {..} =
   _omitNulls
      [ "profile" .= emailUserFactorProfile
      ]


-- | Construct a value of type 'EmailUserFactor' (by applying it's required fields, if any)
mkEmailUserFactor
  :: EmailUserFactor
mkEmailUserFactor =
  EmailUserFactor
  { emailUserFactorProfile = Nothing
  }

-- ** EmailUserFactorProfile
-- | EmailUserFactorProfile
data EmailUserFactorProfile = EmailUserFactorProfile
  { emailUserFactorProfileEmail :: !(Maybe Text) -- ^ "email"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailUserFactorProfile
instance A.FromJSON EmailUserFactorProfile where
  parseJSON = A.withObject "EmailUserFactorProfile" $ \o ->
    EmailUserFactorProfile
      <$> (o .:? "email")

-- | ToJSON EmailUserFactorProfile
instance A.ToJSON EmailUserFactorProfile where
  toJSON EmailUserFactorProfile {..} =
   _omitNulls
      [ "email" .= emailUserFactorProfileEmail
      ]


-- | Construct a value of type 'EmailUserFactorProfile' (by applying it's required fields, if any)
mkEmailUserFactorProfile
  :: EmailUserFactorProfile
mkEmailUserFactorProfile =
  EmailUserFactorProfile
  { emailUserFactorProfileEmail = Nothing
  }

-- ** EventHook
-- | EventHook
data EventHook = EventHook
  { eventHookLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , eventHookChannel :: !(Maybe EventHookChannel) -- ^ "channel"
  , eventHookCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , eventHookCreatedBy :: !(Maybe Text) -- ^ "createdBy"
  , eventHookEvents :: !(Maybe EventSubscriptions) -- ^ "events"
  , eventHookId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , eventHookLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , eventHookName :: !(Maybe Text) -- ^ "name"
  , eventHookStatus :: !(Maybe E'Status2) -- ^ "status"
  , eventHookVerificationStatus :: !(Maybe E'VerificationStatus) -- ^ "verificationStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventHook
instance A.FromJSON EventHook where
  parseJSON = A.withObject "EventHook" $ \o ->
    EventHook
      <$> (o .:? "_links")
      <*> (o .:? "channel")
      <*> (o .:? "created")
      <*> (o .:? "createdBy")
      <*> (o .:? "events")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "status")
      <*> (o .:? "verificationStatus")

-- | ToJSON EventHook
instance A.ToJSON EventHook where
  toJSON EventHook {..} =
   _omitNulls
      [ "_links" .= eventHookLinks
      , "channel" .= eventHookChannel
      , "created" .= eventHookCreated
      , "createdBy" .= eventHookCreatedBy
      , "events" .= eventHookEvents
      , "id" .= eventHookId
      , "lastUpdated" .= eventHookLastUpdated
      , "name" .= eventHookName
      , "status" .= eventHookStatus
      , "verificationStatus" .= eventHookVerificationStatus
      ]


-- | Construct a value of type 'EventHook' (by applying it's required fields, if any)
mkEventHook
  :: EventHook
mkEventHook =
  EventHook
  { eventHookLinks = Nothing
  , eventHookChannel = Nothing
  , eventHookCreated = Nothing
  , eventHookCreatedBy = Nothing
  , eventHookEvents = Nothing
  , eventHookId = Nothing
  , eventHookLastUpdated = Nothing
  , eventHookName = Nothing
  , eventHookStatus = Nothing
  , eventHookVerificationStatus = Nothing
  }

-- ** EventHookChannel
-- | EventHookChannel
data EventHookChannel = EventHookChannel
  { eventHookChannelConfig :: !(Maybe EventHookChannelConfig) -- ^ "config"
  , eventHookChannelType :: !(Maybe E'Type2) -- ^ "type"
  , eventHookChannelVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventHookChannel
instance A.FromJSON EventHookChannel where
  parseJSON = A.withObject "EventHookChannel" $ \o ->
    EventHookChannel
      <$> (o .:? "config")
      <*> (o .:? "type")
      <*> (o .:? "version")

-- | ToJSON EventHookChannel
instance A.ToJSON EventHookChannel where
  toJSON EventHookChannel {..} =
   _omitNulls
      [ "config" .= eventHookChannelConfig
      , "type" .= eventHookChannelType
      , "version" .= eventHookChannelVersion
      ]


-- | Construct a value of type 'EventHookChannel' (by applying it's required fields, if any)
mkEventHookChannel
  :: EventHookChannel
mkEventHookChannel =
  EventHookChannel
  { eventHookChannelConfig = Nothing
  , eventHookChannelType = Nothing
  , eventHookChannelVersion = Nothing
  }

-- ** EventHookChannelConfig
-- | EventHookChannelConfig
data EventHookChannelConfig = EventHookChannelConfig
  { eventHookChannelConfigAuthScheme :: !(Maybe EventHookChannelConfigAuthScheme) -- ^ "authScheme"
  , eventHookChannelConfigHeaders :: !(Maybe [EventHookChannelConfigHeader]) -- ^ "headers"
  , eventHookChannelConfigUri :: !(Maybe Text) -- ^ "uri"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventHookChannelConfig
instance A.FromJSON EventHookChannelConfig where
  parseJSON = A.withObject "EventHookChannelConfig" $ \o ->
    EventHookChannelConfig
      <$> (o .:? "authScheme")
      <*> (o .:? "headers")
      <*> (o .:? "uri")

-- | ToJSON EventHookChannelConfig
instance A.ToJSON EventHookChannelConfig where
  toJSON EventHookChannelConfig {..} =
   _omitNulls
      [ "authScheme" .= eventHookChannelConfigAuthScheme
      , "headers" .= eventHookChannelConfigHeaders
      , "uri" .= eventHookChannelConfigUri
      ]


-- | Construct a value of type 'EventHookChannelConfig' (by applying it's required fields, if any)
mkEventHookChannelConfig
  :: EventHookChannelConfig
mkEventHookChannelConfig =
  EventHookChannelConfig
  { eventHookChannelConfigAuthScheme = Nothing
  , eventHookChannelConfigHeaders = Nothing
  , eventHookChannelConfigUri = Nothing
  }

-- ** EventHookChannelConfigAuthScheme
-- | EventHookChannelConfigAuthScheme
data EventHookChannelConfigAuthScheme = EventHookChannelConfigAuthScheme
  { eventHookChannelConfigAuthSchemeKey :: !(Maybe Text) -- ^ "key"
  , eventHookChannelConfigAuthSchemeType :: !(Maybe EventHookChannelConfigAuthSchemeType) -- ^ "type"
  , eventHookChannelConfigAuthSchemeValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventHookChannelConfigAuthScheme
instance A.FromJSON EventHookChannelConfigAuthScheme where
  parseJSON = A.withObject "EventHookChannelConfigAuthScheme" $ \o ->
    EventHookChannelConfigAuthScheme
      <$> (o .:? "key")
      <*> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON EventHookChannelConfigAuthScheme
instance A.ToJSON EventHookChannelConfigAuthScheme where
  toJSON EventHookChannelConfigAuthScheme {..} =
   _omitNulls
      [ "key" .= eventHookChannelConfigAuthSchemeKey
      , "type" .= eventHookChannelConfigAuthSchemeType
      , "value" .= eventHookChannelConfigAuthSchemeValue
      ]


-- | Construct a value of type 'EventHookChannelConfigAuthScheme' (by applying it's required fields, if any)
mkEventHookChannelConfigAuthScheme
  :: EventHookChannelConfigAuthScheme
mkEventHookChannelConfigAuthScheme =
  EventHookChannelConfigAuthScheme
  { eventHookChannelConfigAuthSchemeKey = Nothing
  , eventHookChannelConfigAuthSchemeType = Nothing
  , eventHookChannelConfigAuthSchemeValue = Nothing
  }

-- ** EventHookChannelConfigHeader
-- | EventHookChannelConfigHeader
data EventHookChannelConfigHeader = EventHookChannelConfigHeader
  { eventHookChannelConfigHeaderKey :: !(Maybe Text) -- ^ "key"
  , eventHookChannelConfigHeaderValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventHookChannelConfigHeader
instance A.FromJSON EventHookChannelConfigHeader where
  parseJSON = A.withObject "EventHookChannelConfigHeader" $ \o ->
    EventHookChannelConfigHeader
      <$> (o .:? "key")
      <*> (o .:? "value")

-- | ToJSON EventHookChannelConfigHeader
instance A.ToJSON EventHookChannelConfigHeader where
  toJSON EventHookChannelConfigHeader {..} =
   _omitNulls
      [ "key" .= eventHookChannelConfigHeaderKey
      , "value" .= eventHookChannelConfigHeaderValue
      ]


-- | Construct a value of type 'EventHookChannelConfigHeader' (by applying it's required fields, if any)
mkEventHookChannelConfigHeader
  :: EventHookChannelConfigHeader
mkEventHookChannelConfigHeader =
  EventHookChannelConfigHeader
  { eventHookChannelConfigHeaderKey = Nothing
  , eventHookChannelConfigHeaderValue = Nothing
  }

-- ** EventSubscriptions
-- | EventSubscriptions
data EventSubscriptions = EventSubscriptions
  { eventSubscriptionsItems :: !(Maybe [Text]) -- ^ "items"
  , eventSubscriptionsType :: !(Maybe E'Type3) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventSubscriptions
instance A.FromJSON EventSubscriptions where
  parseJSON = A.withObject "EventSubscriptions" $ \o ->
    EventSubscriptions
      <$> (o .:? "items")
      <*> (o .:? "type")

-- | ToJSON EventSubscriptions
instance A.ToJSON EventSubscriptions where
  toJSON EventSubscriptions {..} =
   _omitNulls
      [ "items" .= eventSubscriptionsItems
      , "type" .= eventSubscriptionsType
      ]


-- | Construct a value of type 'EventSubscriptions' (by applying it's required fields, if any)
mkEventSubscriptions
  :: EventSubscriptions
mkEventSubscriptions =
  EventSubscriptions
  { eventSubscriptionsItems = Nothing
  , eventSubscriptionsType = Nothing
  }

-- ** Feature
-- | Feature
data Feature = Feature
  { featureLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , featureDescription :: !(Maybe Text) -- ^ "description"
  , featureId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , featureName :: !(Maybe Text) -- ^ "name"
  , featureStage :: !(Maybe FeatureStage) -- ^ "stage"
  , featureStatus :: !(Maybe EnabledStatus) -- ^ "status"
  , featureType :: !(Maybe FeatureType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Feature
instance A.FromJSON Feature where
  parseJSON = A.withObject "Feature" $ \o ->
    Feature
      <$> (o .:? "_links")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "stage")
      <*> (o .:? "status")
      <*> (o .:? "type")

-- | ToJSON Feature
instance A.ToJSON Feature where
  toJSON Feature {..} =
   _omitNulls
      [ "_links" .= featureLinks
      , "description" .= featureDescription
      , "id" .= featureId
      , "name" .= featureName
      , "stage" .= featureStage
      , "status" .= featureStatus
      , "type" .= featureType
      ]


-- | Construct a value of type 'Feature' (by applying it's required fields, if any)
mkFeature
  :: Feature
mkFeature =
  Feature
  { featureLinks = Nothing
  , featureDescription = Nothing
  , featureId = Nothing
  , featureName = Nothing
  , featureStage = Nothing
  , featureStatus = Nothing
  , featureType = Nothing
  }

-- ** FeatureStage
-- | FeatureStage
data FeatureStage = FeatureStage
  { featureStageState :: !(Maybe FeatureStageState) -- ^ "state"
  , featureStageValue :: !(Maybe FeatureStageValue) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FeatureStage
instance A.FromJSON FeatureStage where
  parseJSON = A.withObject "FeatureStage" $ \o ->
    FeatureStage
      <$> (o .:? "state")
      <*> (o .:? "value")

-- | ToJSON FeatureStage
instance A.ToJSON FeatureStage where
  toJSON FeatureStage {..} =
   _omitNulls
      [ "state" .= featureStageState
      , "value" .= featureStageValue
      ]


-- | Construct a value of type 'FeatureStage' (by applying it's required fields, if any)
mkFeatureStage
  :: FeatureStage
mkFeatureStage =
  FeatureStage
  { featureStageState = Nothing
  , featureStageValue = Nothing
  }

-- ** ForgotPasswordResponse
-- | ForgotPasswordResponse
data ForgotPasswordResponse = ForgotPasswordResponse
  { forgotPasswordResponseResetPasswordUrl :: !(Maybe Text) -- ^ /ReadOnly/ "resetPasswordUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ForgotPasswordResponse
instance A.FromJSON ForgotPasswordResponse where
  parseJSON = A.withObject "ForgotPasswordResponse" $ \o ->
    ForgotPasswordResponse
      <$> (o .:? "resetPasswordUrl")

-- | ToJSON ForgotPasswordResponse
instance A.ToJSON ForgotPasswordResponse where
  toJSON ForgotPasswordResponse {..} =
   _omitNulls
      [ "resetPasswordUrl" .= forgotPasswordResponseResetPasswordUrl
      ]


-- | Construct a value of type 'ForgotPasswordResponse' (by applying it's required fields, if any)
mkForgotPasswordResponse
  :: ForgotPasswordResponse
mkForgotPasswordResponse =
  ForgotPasswordResponse
  { forgotPasswordResponseResetPasswordUrl = Nothing
  }

-- ** GrantTypePolicyRuleCondition
-- | GrantTypePolicyRuleCondition
data GrantTypePolicyRuleCondition = GrantTypePolicyRuleCondition
  { grantTypePolicyRuleConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GrantTypePolicyRuleCondition
instance A.FromJSON GrantTypePolicyRuleCondition where
  parseJSON = A.withObject "GrantTypePolicyRuleCondition" $ \o ->
    GrantTypePolicyRuleCondition
      <$> (o .:? "include")

-- | ToJSON GrantTypePolicyRuleCondition
instance A.ToJSON GrantTypePolicyRuleCondition where
  toJSON GrantTypePolicyRuleCondition {..} =
   _omitNulls
      [ "include" .= grantTypePolicyRuleConditionInclude
      ]


-- | Construct a value of type 'GrantTypePolicyRuleCondition' (by applying it's required fields, if any)
mkGrantTypePolicyRuleCondition
  :: GrantTypePolicyRuleCondition
mkGrantTypePolicyRuleCondition =
  GrantTypePolicyRuleCondition
  { grantTypePolicyRuleConditionInclude = Nothing
  }

-- ** Group
-- | Group
data Group = Group
  { groupEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , groupLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , groupCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , groupId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , groupLastMembershipUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastMembershipUpdated"
  , groupLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , groupObjectClass :: !(Maybe [Text]) -- ^ /ReadOnly/ "objectClass"
  , groupProfile :: !(Maybe GroupProfile) -- ^ "profile"
  , groupType :: !(Maybe GroupType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Group
instance A.FromJSON Group where
  parseJSON = A.withObject "Group" $ \o ->
    Group
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastMembershipUpdated")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "objectClass")
      <*> (o .:? "profile")
      <*> (o .:? "type")

-- | ToJSON Group
instance A.ToJSON Group where
  toJSON Group {..} =
   _omitNulls
      [ "_embedded" .= groupEmbedded
      , "_links" .= groupLinks
      , "created" .= groupCreated
      , "id" .= groupId
      , "lastMembershipUpdated" .= groupLastMembershipUpdated
      , "lastUpdated" .= groupLastUpdated
      , "objectClass" .= groupObjectClass
      , "profile" .= groupProfile
      , "type" .= groupType
      ]


-- | Construct a value of type 'Group' (by applying it's required fields, if any)
mkGroup
  :: Group
mkGroup =
  Group
  { groupEmbedded = Nothing
  , groupLinks = Nothing
  , groupCreated = Nothing
  , groupId = Nothing
  , groupLastMembershipUpdated = Nothing
  , groupLastUpdated = Nothing
  , groupObjectClass = Nothing
  , groupProfile = Nothing
  , groupType = Nothing
  }

-- ** GroupCondition
-- | GroupCondition
data GroupCondition = GroupCondition
  { groupConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , groupConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupCondition
instance A.FromJSON GroupCondition where
  parseJSON = A.withObject "GroupCondition" $ \o ->
    GroupCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON GroupCondition
instance A.ToJSON GroupCondition where
  toJSON GroupCondition {..} =
   _omitNulls
      [ "exclude" .= groupConditionExclude
      , "include" .= groupConditionInclude
      ]


-- | Construct a value of type 'GroupCondition' (by applying it's required fields, if any)
mkGroupCondition
  :: GroupCondition
mkGroupCondition =
  GroupCondition
  { groupConditionExclude = Nothing
  , groupConditionInclude = Nothing
  }

-- ** GroupPolicyRuleCondition
-- | GroupPolicyRuleCondition
data GroupPolicyRuleCondition = GroupPolicyRuleCondition
  { groupPolicyRuleConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , groupPolicyRuleConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupPolicyRuleCondition
instance A.FromJSON GroupPolicyRuleCondition where
  parseJSON = A.withObject "GroupPolicyRuleCondition" $ \o ->
    GroupPolicyRuleCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON GroupPolicyRuleCondition
instance A.ToJSON GroupPolicyRuleCondition where
  toJSON GroupPolicyRuleCondition {..} =
   _omitNulls
      [ "exclude" .= groupPolicyRuleConditionExclude
      , "include" .= groupPolicyRuleConditionInclude
      ]


-- | Construct a value of type 'GroupPolicyRuleCondition' (by applying it's required fields, if any)
mkGroupPolicyRuleCondition
  :: GroupPolicyRuleCondition
mkGroupPolicyRuleCondition =
  GroupPolicyRuleCondition
  { groupPolicyRuleConditionExclude = Nothing
  , groupPolicyRuleConditionInclude = Nothing
  }

-- ** GroupProfile
-- | GroupProfile
data GroupProfile = GroupProfile
  { groupProfileDescription :: !(Maybe Text) -- ^ "description"
  , groupProfileName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupProfile
instance A.FromJSON GroupProfile where
  parseJSON = A.withObject "GroupProfile" $ \o ->
    GroupProfile
      <$> (o .:? "description")
      <*> (o .:? "name")

-- | ToJSON GroupProfile
instance A.ToJSON GroupProfile where
  toJSON GroupProfile {..} =
   _omitNulls
      [ "description" .= groupProfileDescription
      , "name" .= groupProfileName
      ]


-- | Construct a value of type 'GroupProfile' (by applying it's required fields, if any)
mkGroupProfile
  :: GroupProfile
mkGroupProfile =
  GroupProfile
  { groupProfileDescription = Nothing
  , groupProfileName = Nothing
  }

-- ** GroupRule
-- | GroupRule
data GroupRule = GroupRule
  { groupRuleActions :: !(Maybe GroupRuleAction) -- ^ "actions"
  , groupRuleConditions :: !(Maybe GroupRuleConditions) -- ^ "conditions"
  , groupRuleCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , groupRuleId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , groupRuleLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , groupRuleName :: !(Maybe Text) -- ^ "name"
  , groupRuleStatus :: !(Maybe GroupRuleStatus) -- ^ "status"
  , groupRuleType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRule
instance A.FromJSON GroupRule where
  parseJSON = A.withObject "GroupRule" $ \o ->
    GroupRule
      <$> (o .:? "actions")
      <*> (o .:? "conditions")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "status")
      <*> (o .:? "type")

-- | ToJSON GroupRule
instance A.ToJSON GroupRule where
  toJSON GroupRule {..} =
   _omitNulls
      [ "actions" .= groupRuleActions
      , "conditions" .= groupRuleConditions
      , "created" .= groupRuleCreated
      , "id" .= groupRuleId
      , "lastUpdated" .= groupRuleLastUpdated
      , "name" .= groupRuleName
      , "status" .= groupRuleStatus
      , "type" .= groupRuleType
      ]


-- | Construct a value of type 'GroupRule' (by applying it's required fields, if any)
mkGroupRule
  :: GroupRule
mkGroupRule =
  GroupRule
  { groupRuleActions = Nothing
  , groupRuleConditions = Nothing
  , groupRuleCreated = Nothing
  , groupRuleId = Nothing
  , groupRuleLastUpdated = Nothing
  , groupRuleName = Nothing
  , groupRuleStatus = Nothing
  , groupRuleType = Nothing
  }

-- ** GroupRuleAction
-- | GroupRuleAction
data GroupRuleAction = GroupRuleAction
  { groupRuleActionAssignUserToGroups :: !(Maybe GroupRuleGroupAssignment) -- ^ "assignUserToGroups"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleAction
instance A.FromJSON GroupRuleAction where
  parseJSON = A.withObject "GroupRuleAction" $ \o ->
    GroupRuleAction
      <$> (o .:? "assignUserToGroups")

-- | ToJSON GroupRuleAction
instance A.ToJSON GroupRuleAction where
  toJSON GroupRuleAction {..} =
   _omitNulls
      [ "assignUserToGroups" .= groupRuleActionAssignUserToGroups
      ]


-- | Construct a value of type 'GroupRuleAction' (by applying it's required fields, if any)
mkGroupRuleAction
  :: GroupRuleAction
mkGroupRuleAction =
  GroupRuleAction
  { groupRuleActionAssignUserToGroups = Nothing
  }

-- ** GroupRuleConditions
-- | GroupRuleConditions
data GroupRuleConditions = GroupRuleConditions
  { groupRuleConditionsExpression :: !(Maybe GroupRuleExpression) -- ^ "expression"
  , groupRuleConditionsPeople :: !(Maybe GroupRulePeopleCondition) -- ^ "people"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleConditions
instance A.FromJSON GroupRuleConditions where
  parseJSON = A.withObject "GroupRuleConditions" $ \o ->
    GroupRuleConditions
      <$> (o .:? "expression")
      <*> (o .:? "people")

-- | ToJSON GroupRuleConditions
instance A.ToJSON GroupRuleConditions where
  toJSON GroupRuleConditions {..} =
   _omitNulls
      [ "expression" .= groupRuleConditionsExpression
      , "people" .= groupRuleConditionsPeople
      ]


-- | Construct a value of type 'GroupRuleConditions' (by applying it's required fields, if any)
mkGroupRuleConditions
  :: GroupRuleConditions
mkGroupRuleConditions =
  GroupRuleConditions
  { groupRuleConditionsExpression = Nothing
  , groupRuleConditionsPeople = Nothing
  }

-- ** GroupRuleExpression
-- | GroupRuleExpression
data GroupRuleExpression = GroupRuleExpression
  { groupRuleExpressionType :: !(Maybe Text) -- ^ "type"
  , groupRuleExpressionValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleExpression
instance A.FromJSON GroupRuleExpression where
  parseJSON = A.withObject "GroupRuleExpression" $ \o ->
    GroupRuleExpression
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON GroupRuleExpression
instance A.ToJSON GroupRuleExpression where
  toJSON GroupRuleExpression {..} =
   _omitNulls
      [ "type" .= groupRuleExpressionType
      , "value" .= groupRuleExpressionValue
      ]


-- | Construct a value of type 'GroupRuleExpression' (by applying it's required fields, if any)
mkGroupRuleExpression
  :: GroupRuleExpression
mkGroupRuleExpression =
  GroupRuleExpression
  { groupRuleExpressionType = Nothing
  , groupRuleExpressionValue = Nothing
  }

-- ** GroupRuleGroupAssignment
-- | GroupRuleGroupAssignment
data GroupRuleGroupAssignment = GroupRuleGroupAssignment
  { groupRuleGroupAssignmentGroupIds :: !(Maybe [Text]) -- ^ "groupIds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleGroupAssignment
instance A.FromJSON GroupRuleGroupAssignment where
  parseJSON = A.withObject "GroupRuleGroupAssignment" $ \o ->
    GroupRuleGroupAssignment
      <$> (o .:? "groupIds")

-- | ToJSON GroupRuleGroupAssignment
instance A.ToJSON GroupRuleGroupAssignment where
  toJSON GroupRuleGroupAssignment {..} =
   _omitNulls
      [ "groupIds" .= groupRuleGroupAssignmentGroupIds
      ]


-- | Construct a value of type 'GroupRuleGroupAssignment' (by applying it's required fields, if any)
mkGroupRuleGroupAssignment
  :: GroupRuleGroupAssignment
mkGroupRuleGroupAssignment =
  GroupRuleGroupAssignment
  { groupRuleGroupAssignmentGroupIds = Nothing
  }

-- ** GroupRuleGroupCondition
-- | GroupRuleGroupCondition
data GroupRuleGroupCondition = GroupRuleGroupCondition
  { groupRuleGroupConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , groupRuleGroupConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleGroupCondition
instance A.FromJSON GroupRuleGroupCondition where
  parseJSON = A.withObject "GroupRuleGroupCondition" $ \o ->
    GroupRuleGroupCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON GroupRuleGroupCondition
instance A.ToJSON GroupRuleGroupCondition where
  toJSON GroupRuleGroupCondition {..} =
   _omitNulls
      [ "exclude" .= groupRuleGroupConditionExclude
      , "include" .= groupRuleGroupConditionInclude
      ]


-- | Construct a value of type 'GroupRuleGroupCondition' (by applying it's required fields, if any)
mkGroupRuleGroupCondition
  :: GroupRuleGroupCondition
mkGroupRuleGroupCondition =
  GroupRuleGroupCondition
  { groupRuleGroupConditionExclude = Nothing
  , groupRuleGroupConditionInclude = Nothing
  }

-- ** GroupRulePeopleCondition
-- | GroupRulePeopleCondition
data GroupRulePeopleCondition = GroupRulePeopleCondition
  { groupRulePeopleConditionGroups :: !(Maybe GroupRuleGroupCondition) -- ^ "groups"
  , groupRulePeopleConditionUsers :: !(Maybe GroupRuleUserCondition) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRulePeopleCondition
instance A.FromJSON GroupRulePeopleCondition where
  parseJSON = A.withObject "GroupRulePeopleCondition" $ \o ->
    GroupRulePeopleCondition
      <$> (o .:? "groups")
      <*> (o .:? "users")

-- | ToJSON GroupRulePeopleCondition
instance A.ToJSON GroupRulePeopleCondition where
  toJSON GroupRulePeopleCondition {..} =
   _omitNulls
      [ "groups" .= groupRulePeopleConditionGroups
      , "users" .= groupRulePeopleConditionUsers
      ]


-- | Construct a value of type 'GroupRulePeopleCondition' (by applying it's required fields, if any)
mkGroupRulePeopleCondition
  :: GroupRulePeopleCondition
mkGroupRulePeopleCondition =
  GroupRulePeopleCondition
  { groupRulePeopleConditionGroups = Nothing
  , groupRulePeopleConditionUsers = Nothing
  }

-- ** GroupRuleUserCondition
-- | GroupRuleUserCondition
data GroupRuleUserCondition = GroupRuleUserCondition
  { groupRuleUserConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , groupRuleUserConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleUserCondition
instance A.FromJSON GroupRuleUserCondition where
  parseJSON = A.withObject "GroupRuleUserCondition" $ \o ->
    GroupRuleUserCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON GroupRuleUserCondition
instance A.ToJSON GroupRuleUserCondition where
  toJSON GroupRuleUserCondition {..} =
   _omitNulls
      [ "exclude" .= groupRuleUserConditionExclude
      , "include" .= groupRuleUserConditionInclude
      ]


-- | Construct a value of type 'GroupRuleUserCondition' (by applying it's required fields, if any)
mkGroupRuleUserCondition
  :: GroupRuleUserCondition
mkGroupRuleUserCondition =
  GroupRuleUserCondition
  { groupRuleUserConditionExclude = Nothing
  , groupRuleUserConditionInclude = Nothing
  }

-- ** GroupSchema
-- | GroupSchema
data GroupSchema = GroupSchema
  { groupSchemaId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , groupSchemaSchema :: !(Maybe Text) -- ^ /ReadOnly/ "$schema"
  , groupSchemaName :: !(Maybe Text) -- ^ /ReadOnly/ "name"
  , groupSchemaTitle :: !(Maybe Text) -- ^ "title"
  , groupSchemaLastUpdated :: !(Maybe Text) -- ^ /ReadOnly/ "lastUpdated"
  , groupSchemaDescription :: !(Maybe Text) -- ^ "description"
  , groupSchemaCreated :: !(Maybe Text) -- ^ /ReadOnly/ "created"
  , groupSchemaDefinitions :: !(Maybe GroupSchemaDefinitions) -- ^ "definitions"
  , groupSchemaType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  , groupSchemaProperties :: !(Maybe UserSchemaProperties) -- ^ "properties"
  , groupSchemaLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupSchema
instance A.FromJSON GroupSchema where
  parseJSON = A.withObject "GroupSchema" $ \o ->
    GroupSchema
      <$> (o .:? "id")
      <*> (o .:? "$schema")
      <*> (o .:? "name")
      <*> (o .:? "title")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "description")
      <*> (o .:? "created")
      <*> (o .:? "definitions")
      <*> (o .:? "type")
      <*> (o .:? "properties")
      <*> (o .:? "_links")

-- | ToJSON GroupSchema
instance A.ToJSON GroupSchema where
  toJSON GroupSchema {..} =
   _omitNulls
      [ "id" .= groupSchemaId
      , "$schema" .= groupSchemaSchema
      , "name" .= groupSchemaName
      , "title" .= groupSchemaTitle
      , "lastUpdated" .= groupSchemaLastUpdated
      , "description" .= groupSchemaDescription
      , "created" .= groupSchemaCreated
      , "definitions" .= groupSchemaDefinitions
      , "type" .= groupSchemaType
      , "properties" .= groupSchemaProperties
      , "_links" .= groupSchemaLinks
      ]


-- | Construct a value of type 'GroupSchema' (by applying it's required fields, if any)
mkGroupSchema
  :: GroupSchema
mkGroupSchema =
  GroupSchema
  { groupSchemaId = Nothing
  , groupSchemaSchema = Nothing
  , groupSchemaName = Nothing
  , groupSchemaTitle = Nothing
  , groupSchemaLastUpdated = Nothing
  , groupSchemaDescription = Nothing
  , groupSchemaCreated = Nothing
  , groupSchemaDefinitions = Nothing
  , groupSchemaType = Nothing
  , groupSchemaProperties = Nothing
  , groupSchemaLinks = Nothing
  }

-- ** GroupSchemaAttribute
-- | GroupSchemaAttribute
data GroupSchemaAttribute = GroupSchemaAttribute
  { groupSchemaAttributeTitle :: !(Maybe Text) -- ^ "title"
  , groupSchemaAttributeType :: !(Maybe UserSchemaAttributeType) -- ^ "type"
  , groupSchemaAttributeRequired :: !(Maybe Bool) -- ^ "required"
  , groupSchemaAttributeMutability :: !(Maybe Text) -- ^ "mutability"
  , groupSchemaAttributeScope :: !(Maybe UserSchemaAttributeScope) -- ^ "scope"
  , groupSchemaAttributeEnum :: !(Maybe [Text]) -- ^ "enum"
  , groupSchemaAttributeOneOf :: !(Maybe [UserSchemaAttributeEnum]) -- ^ "oneOf"
  , groupSchemaAttributeMinLength :: !(Maybe Int) -- ^ "minLength"
  , groupSchemaAttributeMaxLength :: !(Maybe Int) -- ^ "maxLength"
  , groupSchemaAttributeDescription :: !(Maybe Text) -- ^ "description"
  , groupSchemaAttributePermissions :: !(Maybe [UserSchemaAttributePermission]) -- ^ "permissions"
  , groupSchemaAttributeMaster :: !(Maybe UserSchemaAttributeMaster) -- ^ "master"
  , groupSchemaAttributeUnion :: !(Maybe UserSchemaAttributeUnion) -- ^ "union"
  , groupSchemaAttributeItems :: !(Maybe UserSchemaAttributeItems) -- ^ "items"
  , groupSchemaAttributeUnique :: !(Maybe Text) -- ^ "unique"
  , groupSchemaAttributeExternalName :: !(Maybe Text) -- ^ "externalName"
  , groupSchemaAttributeExternalNamespace :: !(Maybe Text) -- ^ "externalNamespace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupSchemaAttribute
instance A.FromJSON GroupSchemaAttribute where
  parseJSON = A.withObject "GroupSchemaAttribute" $ \o ->
    GroupSchemaAttribute
      <$> (o .:? "title")
      <*> (o .:? "type")
      <*> (o .:? "required")
      <*> (o .:? "mutability")
      <*> (o .:? "scope")
      <*> (o .:? "enum")
      <*> (o .:? "oneOf")
      <*> (o .:? "minLength")
      <*> (o .:? "maxLength")
      <*> (o .:? "description")
      <*> (o .:? "permissions")
      <*> (o .:? "master")
      <*> (o .:? "union")
      <*> (o .:? "items")
      <*> (o .:? "unique")
      <*> (o .:? "externalName")
      <*> (o .:? "externalNamespace")

-- | ToJSON GroupSchemaAttribute
instance A.ToJSON GroupSchemaAttribute where
  toJSON GroupSchemaAttribute {..} =
   _omitNulls
      [ "title" .= groupSchemaAttributeTitle
      , "type" .= groupSchemaAttributeType
      , "required" .= groupSchemaAttributeRequired
      , "mutability" .= groupSchemaAttributeMutability
      , "scope" .= groupSchemaAttributeScope
      , "enum" .= groupSchemaAttributeEnum
      , "oneOf" .= groupSchemaAttributeOneOf
      , "minLength" .= groupSchemaAttributeMinLength
      , "maxLength" .= groupSchemaAttributeMaxLength
      , "description" .= groupSchemaAttributeDescription
      , "permissions" .= groupSchemaAttributePermissions
      , "master" .= groupSchemaAttributeMaster
      , "union" .= groupSchemaAttributeUnion
      , "items" .= groupSchemaAttributeItems
      , "unique" .= groupSchemaAttributeUnique
      , "externalName" .= groupSchemaAttributeExternalName
      , "externalNamespace" .= groupSchemaAttributeExternalNamespace
      ]


-- | Construct a value of type 'GroupSchemaAttribute' (by applying it's required fields, if any)
mkGroupSchemaAttribute
  :: GroupSchemaAttribute
mkGroupSchemaAttribute =
  GroupSchemaAttribute
  { groupSchemaAttributeTitle = Nothing
  , groupSchemaAttributeType = Nothing
  , groupSchemaAttributeRequired = Nothing
  , groupSchemaAttributeMutability = Nothing
  , groupSchemaAttributeScope = Nothing
  , groupSchemaAttributeEnum = Nothing
  , groupSchemaAttributeOneOf = Nothing
  , groupSchemaAttributeMinLength = Nothing
  , groupSchemaAttributeMaxLength = Nothing
  , groupSchemaAttributeDescription = Nothing
  , groupSchemaAttributePermissions = Nothing
  , groupSchemaAttributeMaster = Nothing
  , groupSchemaAttributeUnion = Nothing
  , groupSchemaAttributeItems = Nothing
  , groupSchemaAttributeUnique = Nothing
  , groupSchemaAttributeExternalName = Nothing
  , groupSchemaAttributeExternalNamespace = Nothing
  }

-- ** GroupSchemaBase
-- | GroupSchemaBase
data GroupSchemaBase = GroupSchemaBase
  { groupSchemaBaseId :: !(Maybe Text) -- ^ "id"
  , groupSchemaBaseType :: !(Maybe Text) -- ^ "type"
  , groupSchemaBaseProperties :: !(Maybe GroupSchemaBaseProperties) -- ^ "properties"
  , groupSchemaBaseRequired :: !(Maybe [Text]) -- ^ "required"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupSchemaBase
instance A.FromJSON GroupSchemaBase where
  parseJSON = A.withObject "GroupSchemaBase" $ \o ->
    GroupSchemaBase
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "properties")
      <*> (o .:? "required")

-- | ToJSON GroupSchemaBase
instance A.ToJSON GroupSchemaBase where
  toJSON GroupSchemaBase {..} =
   _omitNulls
      [ "id" .= groupSchemaBaseId
      , "type" .= groupSchemaBaseType
      , "properties" .= groupSchemaBaseProperties
      , "required" .= groupSchemaBaseRequired
      ]


-- | Construct a value of type 'GroupSchemaBase' (by applying it's required fields, if any)
mkGroupSchemaBase
  :: GroupSchemaBase
mkGroupSchemaBase =
  GroupSchemaBase
  { groupSchemaBaseId = Nothing
  , groupSchemaBaseType = Nothing
  , groupSchemaBaseProperties = Nothing
  , groupSchemaBaseRequired = Nothing
  }

-- ** GroupSchemaBaseProperties
-- | GroupSchemaBaseProperties
data GroupSchemaBaseProperties = GroupSchemaBaseProperties
  { groupSchemaBasePropertiesName :: !(Maybe GroupSchemaAttribute) -- ^ "name"
  , groupSchemaBasePropertiesDescription :: !(Maybe GroupSchemaAttribute) -- ^ "description"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupSchemaBaseProperties
instance A.FromJSON GroupSchemaBaseProperties where
  parseJSON = A.withObject "GroupSchemaBaseProperties" $ \o ->
    GroupSchemaBaseProperties
      <$> (o .:? "name")
      <*> (o .:? "description")

-- | ToJSON GroupSchemaBaseProperties
instance A.ToJSON GroupSchemaBaseProperties where
  toJSON GroupSchemaBaseProperties {..} =
   _omitNulls
      [ "name" .= groupSchemaBasePropertiesName
      , "description" .= groupSchemaBasePropertiesDescription
      ]


-- | Construct a value of type 'GroupSchemaBaseProperties' (by applying it's required fields, if any)
mkGroupSchemaBaseProperties
  :: GroupSchemaBaseProperties
mkGroupSchemaBaseProperties =
  GroupSchemaBaseProperties
  { groupSchemaBasePropertiesName = Nothing
  , groupSchemaBasePropertiesDescription = Nothing
  }

-- ** GroupSchemaCustom
-- | GroupSchemaCustom
data GroupSchemaCustom = GroupSchemaCustom
  { groupSchemaCustomId :: !(Maybe Text) -- ^ "id"
  , groupSchemaCustomType :: !(Maybe Text) -- ^ "type"
  , groupSchemaCustomProperties :: !(Maybe (Map.Map String GroupSchemaAttribute)) -- ^ "properties"
  , groupSchemaCustomRequired :: !(Maybe [Text]) -- ^ "required"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupSchemaCustom
instance A.FromJSON GroupSchemaCustom where
  parseJSON = A.withObject "GroupSchemaCustom" $ \o ->
    GroupSchemaCustom
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "properties")
      <*> (o .:? "required")

-- | ToJSON GroupSchemaCustom
instance A.ToJSON GroupSchemaCustom where
  toJSON GroupSchemaCustom {..} =
   _omitNulls
      [ "id" .= groupSchemaCustomId
      , "type" .= groupSchemaCustomType
      , "properties" .= groupSchemaCustomProperties
      , "required" .= groupSchemaCustomRequired
      ]


-- | Construct a value of type 'GroupSchemaCustom' (by applying it's required fields, if any)
mkGroupSchemaCustom
  :: GroupSchemaCustom
mkGroupSchemaCustom =
  GroupSchemaCustom
  { groupSchemaCustomId = Nothing
  , groupSchemaCustomType = Nothing
  , groupSchemaCustomProperties = Nothing
  , groupSchemaCustomRequired = Nothing
  }

-- ** GroupSchemaDefinitions
-- | GroupSchemaDefinitions
data GroupSchemaDefinitions = GroupSchemaDefinitions
  { groupSchemaDefinitionsBase :: !(Maybe GroupSchemaBase) -- ^ "base"
  , groupSchemaDefinitionsCustom :: !(Maybe GroupSchemaCustom) -- ^ "custom"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupSchemaDefinitions
instance A.FromJSON GroupSchemaDefinitions where
  parseJSON = A.withObject "GroupSchemaDefinitions" $ \o ->
    GroupSchemaDefinitions
      <$> (o .:? "base")
      <*> (o .:? "custom")

-- | ToJSON GroupSchemaDefinitions
instance A.ToJSON GroupSchemaDefinitions where
  toJSON GroupSchemaDefinitions {..} =
   _omitNulls
      [ "base" .= groupSchemaDefinitionsBase
      , "custom" .= groupSchemaDefinitionsCustom
      ]


-- | Construct a value of type 'GroupSchemaDefinitions' (by applying it's required fields, if any)
mkGroupSchemaDefinitions
  :: GroupSchemaDefinitions
mkGroupSchemaDefinitions =
  GroupSchemaDefinitions
  { groupSchemaDefinitionsBase = Nothing
  , groupSchemaDefinitionsCustom = Nothing
  }

-- ** HardwareUserFactor
-- | HardwareUserFactor
data HardwareUserFactor = HardwareUserFactor
  { hardwareUserFactorProfile :: !(Maybe HardwareUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HardwareUserFactor
instance A.FromJSON HardwareUserFactor where
  parseJSON = A.withObject "HardwareUserFactor" $ \o ->
    HardwareUserFactor
      <$> (o .:? "profile")

-- | ToJSON HardwareUserFactor
instance A.ToJSON HardwareUserFactor where
  toJSON HardwareUserFactor {..} =
   _omitNulls
      [ "profile" .= hardwareUserFactorProfile
      ]


-- | Construct a value of type 'HardwareUserFactor' (by applying it's required fields, if any)
mkHardwareUserFactor
  :: HardwareUserFactor
mkHardwareUserFactor =
  HardwareUserFactor
  { hardwareUserFactorProfile = Nothing
  }

-- ** HardwareUserFactorProfile
-- | HardwareUserFactorProfile
data HardwareUserFactorProfile = HardwareUserFactorProfile
  { hardwareUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HardwareUserFactorProfile
instance A.FromJSON HardwareUserFactorProfile where
  parseJSON = A.withObject "HardwareUserFactorProfile" $ \o ->
    HardwareUserFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON HardwareUserFactorProfile
instance A.ToJSON HardwareUserFactorProfile where
  toJSON HardwareUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= hardwareUserFactorProfileCredentialId
      ]


-- | Construct a value of type 'HardwareUserFactorProfile' (by applying it's required fields, if any)
mkHardwareUserFactorProfile
  :: HardwareUserFactorProfile
mkHardwareUserFactorProfile =
  HardwareUserFactorProfile
  { hardwareUserFactorProfileCredentialId = Nothing
  }

-- ** IdentityProvider
-- | IdentityProvider
data IdentityProvider = IdentityProvider
  { identityProviderLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , identityProviderCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , identityProviderId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , identityProviderIssuerMode :: !(Maybe E'IssuerMode) -- ^ "issuerMode"
  , identityProviderLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , identityProviderName :: !(Maybe Text) -- ^ "name"
  , identityProviderPolicy :: !(Maybe IdentityProviderPolicy) -- ^ "policy"
  , identityProviderProtocol :: !(Maybe Protocol) -- ^ "protocol"
  , identityProviderStatus :: !(Maybe E'Status2) -- ^ "status"
  , identityProviderType :: !(Maybe E'Type4) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProvider
instance A.FromJSON IdentityProvider where
  parseJSON = A.withObject "IdentityProvider" $ \o ->
    IdentityProvider
      <$> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "issuerMode")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "policy")
      <*> (o .:? "protocol")
      <*> (o .:? "status")
      <*> (o .:? "type")

-- | ToJSON IdentityProvider
instance A.ToJSON IdentityProvider where
  toJSON IdentityProvider {..} =
   _omitNulls
      [ "_links" .= identityProviderLinks
      , "created" .= identityProviderCreated
      , "id" .= identityProviderId
      , "issuerMode" .= identityProviderIssuerMode
      , "lastUpdated" .= identityProviderLastUpdated
      , "name" .= identityProviderName
      , "policy" .= identityProviderPolicy
      , "protocol" .= identityProviderProtocol
      , "status" .= identityProviderStatus
      , "type" .= identityProviderType
      ]


-- | Construct a value of type 'IdentityProvider' (by applying it's required fields, if any)
mkIdentityProvider
  :: IdentityProvider
mkIdentityProvider =
  IdentityProvider
  { identityProviderLinks = Nothing
  , identityProviderCreated = Nothing
  , identityProviderId = Nothing
  , identityProviderIssuerMode = Nothing
  , identityProviderLastUpdated = Nothing
  , identityProviderName = Nothing
  , identityProviderPolicy = Nothing
  , identityProviderProtocol = Nothing
  , identityProviderStatus = Nothing
  , identityProviderType = Nothing
  }

-- ** IdentityProviderApplicationUser
-- | IdentityProviderApplicationUser
data IdentityProviderApplicationUser = IdentityProviderApplicationUser
  { identityProviderApplicationUserEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , identityProviderApplicationUserLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , identityProviderApplicationUserCreated :: !(Maybe Text) -- ^ "created"
  , identityProviderApplicationUserExternalId :: !(Maybe Text) -- ^ "externalId"
  , identityProviderApplicationUserId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , identityProviderApplicationUserLastUpdated :: !(Maybe Text) -- ^ "lastUpdated"
  , identityProviderApplicationUserProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderApplicationUser
instance A.FromJSON IdentityProviderApplicationUser where
  parseJSON = A.withObject "IdentityProviderApplicationUser" $ \o ->
    IdentityProviderApplicationUser
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "externalId")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "profile")

-- | ToJSON IdentityProviderApplicationUser
instance A.ToJSON IdentityProviderApplicationUser where
  toJSON IdentityProviderApplicationUser {..} =
   _omitNulls
      [ "_embedded" .= identityProviderApplicationUserEmbedded
      , "_links" .= identityProviderApplicationUserLinks
      , "created" .= identityProviderApplicationUserCreated
      , "externalId" .= identityProviderApplicationUserExternalId
      , "id" .= identityProviderApplicationUserId
      , "lastUpdated" .= identityProviderApplicationUserLastUpdated
      , "profile" .= identityProviderApplicationUserProfile
      ]


-- | Construct a value of type 'IdentityProviderApplicationUser' (by applying it's required fields, if any)
mkIdentityProviderApplicationUser
  :: IdentityProviderApplicationUser
mkIdentityProviderApplicationUser =
  IdentityProviderApplicationUser
  { identityProviderApplicationUserEmbedded = Nothing
  , identityProviderApplicationUserLinks = Nothing
  , identityProviderApplicationUserCreated = Nothing
  , identityProviderApplicationUserExternalId = Nothing
  , identityProviderApplicationUserId = Nothing
  , identityProviderApplicationUserLastUpdated = Nothing
  , identityProviderApplicationUserProfile = Nothing
  }

-- ** IdentityProviderCredentials
-- | IdentityProviderCredentials
data IdentityProviderCredentials = IdentityProviderCredentials
  { identityProviderCredentialsClient :: !(Maybe IdentityProviderCredentialsClient) -- ^ "client"
  , identityProviderCredentialsSigning :: !(Maybe IdentityProviderCredentialsSigning) -- ^ "signing"
  , identityProviderCredentialsTrust :: !(Maybe IdentityProviderCredentialsTrust) -- ^ "trust"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderCredentials
instance A.FromJSON IdentityProviderCredentials where
  parseJSON = A.withObject "IdentityProviderCredentials" $ \o ->
    IdentityProviderCredentials
      <$> (o .:? "client")
      <*> (o .:? "signing")
      <*> (o .:? "trust")

-- | ToJSON IdentityProviderCredentials
instance A.ToJSON IdentityProviderCredentials where
  toJSON IdentityProviderCredentials {..} =
   _omitNulls
      [ "client" .= identityProviderCredentialsClient
      , "signing" .= identityProviderCredentialsSigning
      , "trust" .= identityProviderCredentialsTrust
      ]


-- | Construct a value of type 'IdentityProviderCredentials' (by applying it's required fields, if any)
mkIdentityProviderCredentials
  :: IdentityProviderCredentials
mkIdentityProviderCredentials =
  IdentityProviderCredentials
  { identityProviderCredentialsClient = Nothing
  , identityProviderCredentialsSigning = Nothing
  , identityProviderCredentialsTrust = Nothing
  }

-- ** IdentityProviderCredentialsClient
-- | IdentityProviderCredentialsClient
data IdentityProviderCredentialsClient = IdentityProviderCredentialsClient
  { identityProviderCredentialsClientClientId :: !(Maybe Text) -- ^ "client_id"
  , identityProviderCredentialsClientClientSecret :: !(Maybe Text) -- ^ "client_secret"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderCredentialsClient
instance A.FromJSON IdentityProviderCredentialsClient where
  parseJSON = A.withObject "IdentityProviderCredentialsClient" $ \o ->
    IdentityProviderCredentialsClient
      <$> (o .:? "client_id")
      <*> (o .:? "client_secret")

-- | ToJSON IdentityProviderCredentialsClient
instance A.ToJSON IdentityProviderCredentialsClient where
  toJSON IdentityProviderCredentialsClient {..} =
   _omitNulls
      [ "client_id" .= identityProviderCredentialsClientClientId
      , "client_secret" .= identityProviderCredentialsClientClientSecret
      ]


-- | Construct a value of type 'IdentityProviderCredentialsClient' (by applying it's required fields, if any)
mkIdentityProviderCredentialsClient
  :: IdentityProviderCredentialsClient
mkIdentityProviderCredentialsClient =
  IdentityProviderCredentialsClient
  { identityProviderCredentialsClientClientId = Nothing
  , identityProviderCredentialsClientClientSecret = Nothing
  }

-- ** IdentityProviderCredentialsSigning
-- | IdentityProviderCredentialsSigning
data IdentityProviderCredentialsSigning = IdentityProviderCredentialsSigning
  { identityProviderCredentialsSigningKid :: !(Maybe Text) -- ^ "kid"
  , identityProviderCredentialsSigningPrivateKey :: !(Maybe Text) -- ^ "privateKey"
  , identityProviderCredentialsSigningTeamId :: !(Maybe Text) -- ^ "teamId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderCredentialsSigning
instance A.FromJSON IdentityProviderCredentialsSigning where
  parseJSON = A.withObject "IdentityProviderCredentialsSigning" $ \o ->
    IdentityProviderCredentialsSigning
      <$> (o .:? "kid")
      <*> (o .:? "privateKey")
      <*> (o .:? "teamId")

-- | ToJSON IdentityProviderCredentialsSigning
instance A.ToJSON IdentityProviderCredentialsSigning where
  toJSON IdentityProviderCredentialsSigning {..} =
   _omitNulls
      [ "kid" .= identityProviderCredentialsSigningKid
      , "privateKey" .= identityProviderCredentialsSigningPrivateKey
      , "teamId" .= identityProviderCredentialsSigningTeamId
      ]


-- | Construct a value of type 'IdentityProviderCredentialsSigning' (by applying it's required fields, if any)
mkIdentityProviderCredentialsSigning
  :: IdentityProviderCredentialsSigning
mkIdentityProviderCredentialsSigning =
  IdentityProviderCredentialsSigning
  { identityProviderCredentialsSigningKid = Nothing
  , identityProviderCredentialsSigningPrivateKey = Nothing
  , identityProviderCredentialsSigningTeamId = Nothing
  }

-- ** IdentityProviderCredentialsTrust
-- | IdentityProviderCredentialsTrust
data IdentityProviderCredentialsTrust = IdentityProviderCredentialsTrust
  { identityProviderCredentialsTrustAudience :: !(Maybe Text) -- ^ "audience"
  , identityProviderCredentialsTrustIssuer :: !(Maybe Text) -- ^ "issuer"
  , identityProviderCredentialsTrustKid :: !(Maybe Text) -- ^ "kid"
  , identityProviderCredentialsTrustRevocation :: !(Maybe E'Revocation) -- ^ "revocation"
  , identityProviderCredentialsTrustRevocationCacheLifetime :: !(Maybe Int) -- ^ "revocationCacheLifetime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderCredentialsTrust
instance A.FromJSON IdentityProviderCredentialsTrust where
  parseJSON = A.withObject "IdentityProviderCredentialsTrust" $ \o ->
    IdentityProviderCredentialsTrust
      <$> (o .:? "audience")
      <*> (o .:? "issuer")
      <*> (o .:? "kid")
      <*> (o .:? "revocation")
      <*> (o .:? "revocationCacheLifetime")

-- | ToJSON IdentityProviderCredentialsTrust
instance A.ToJSON IdentityProviderCredentialsTrust where
  toJSON IdentityProviderCredentialsTrust {..} =
   _omitNulls
      [ "audience" .= identityProviderCredentialsTrustAudience
      , "issuer" .= identityProviderCredentialsTrustIssuer
      , "kid" .= identityProviderCredentialsTrustKid
      , "revocation" .= identityProviderCredentialsTrustRevocation
      , "revocationCacheLifetime" .= identityProviderCredentialsTrustRevocationCacheLifetime
      ]


-- | Construct a value of type 'IdentityProviderCredentialsTrust' (by applying it's required fields, if any)
mkIdentityProviderCredentialsTrust
  :: IdentityProviderCredentialsTrust
mkIdentityProviderCredentialsTrust =
  IdentityProviderCredentialsTrust
  { identityProviderCredentialsTrustAudience = Nothing
  , identityProviderCredentialsTrustIssuer = Nothing
  , identityProviderCredentialsTrustKid = Nothing
  , identityProviderCredentialsTrustRevocation = Nothing
  , identityProviderCredentialsTrustRevocationCacheLifetime = Nothing
  }

-- ** IdentityProviderPolicy
-- | IdentityProviderPolicy
data IdentityProviderPolicy = IdentityProviderPolicy
  { identityProviderPolicyAccountLink :: !(Maybe PolicyAccountLink) -- ^ "accountLink"
  , identityProviderPolicyMaxClockSkew :: !(Maybe Int) -- ^ "maxClockSkew"
  , identityProviderPolicyProvisioning :: !(Maybe Provisioning) -- ^ "provisioning"
  , identityProviderPolicySubject :: !(Maybe PolicySubject) -- ^ "subject"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderPolicy
instance A.FromJSON IdentityProviderPolicy where
  parseJSON = A.withObject "IdentityProviderPolicy" $ \o ->
    IdentityProviderPolicy
      <$> (o .:? "accountLink")
      <*> (o .:? "maxClockSkew")
      <*> (o .:? "provisioning")
      <*> (o .:? "subject")

-- | ToJSON IdentityProviderPolicy
instance A.ToJSON IdentityProviderPolicy where
  toJSON IdentityProviderPolicy {..} =
   _omitNulls
      [ "accountLink" .= identityProviderPolicyAccountLink
      , "maxClockSkew" .= identityProviderPolicyMaxClockSkew
      , "provisioning" .= identityProviderPolicyProvisioning
      , "subject" .= identityProviderPolicySubject
      ]


-- | Construct a value of type 'IdentityProviderPolicy' (by applying it's required fields, if any)
mkIdentityProviderPolicy
  :: IdentityProviderPolicy
mkIdentityProviderPolicy =
  IdentityProviderPolicy
  { identityProviderPolicyAccountLink = Nothing
  , identityProviderPolicyMaxClockSkew = Nothing
  , identityProviderPolicyProvisioning = Nothing
  , identityProviderPolicySubject = Nothing
  }

-- ** IdentityProviderPolicyRuleCondition
-- | IdentityProviderPolicyRuleCondition
data IdentityProviderPolicyRuleCondition = IdentityProviderPolicyRuleCondition
  { identityProviderPolicyRuleConditionIdpIds :: !(Maybe [Text]) -- ^ "idpIds"
  , identityProviderPolicyRuleConditionProvider :: !(Maybe E'Provider) -- ^ "provider"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdentityProviderPolicyRuleCondition
instance A.FromJSON IdentityProviderPolicyRuleCondition where
  parseJSON = A.withObject "IdentityProviderPolicyRuleCondition" $ \o ->
    IdentityProviderPolicyRuleCondition
      <$> (o .:? "idpIds")
      <*> (o .:? "provider")

-- | ToJSON IdentityProviderPolicyRuleCondition
instance A.ToJSON IdentityProviderPolicyRuleCondition where
  toJSON IdentityProviderPolicyRuleCondition {..} =
   _omitNulls
      [ "idpIds" .= identityProviderPolicyRuleConditionIdpIds
      , "provider" .= identityProviderPolicyRuleConditionProvider
      ]


-- | Construct a value of type 'IdentityProviderPolicyRuleCondition' (by applying it's required fields, if any)
mkIdentityProviderPolicyRuleCondition
  :: IdentityProviderPolicyRuleCondition
mkIdentityProviderPolicyRuleCondition =
  IdentityProviderPolicyRuleCondition
  { identityProviderPolicyRuleConditionIdpIds = Nothing
  , identityProviderPolicyRuleConditionProvider = Nothing
  }

-- ** IdpPolicyRuleAction
-- | IdpPolicyRuleAction
data IdpPolicyRuleAction = IdpPolicyRuleAction
  { idpPolicyRuleActionProviders :: !(Maybe [IdpPolicyRuleActionProvider]) -- ^ "providers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdpPolicyRuleAction
instance A.FromJSON IdpPolicyRuleAction where
  parseJSON = A.withObject "IdpPolicyRuleAction" $ \o ->
    IdpPolicyRuleAction
      <$> (o .:? "providers")

-- | ToJSON IdpPolicyRuleAction
instance A.ToJSON IdpPolicyRuleAction where
  toJSON IdpPolicyRuleAction {..} =
   _omitNulls
      [ "providers" .= idpPolicyRuleActionProviders
      ]


-- | Construct a value of type 'IdpPolicyRuleAction' (by applying it's required fields, if any)
mkIdpPolicyRuleAction
  :: IdpPolicyRuleAction
mkIdpPolicyRuleAction =
  IdpPolicyRuleAction
  { idpPolicyRuleActionProviders = Nothing
  }

-- ** IdpPolicyRuleActionProvider
-- | IdpPolicyRuleActionProvider
data IdpPolicyRuleActionProvider = IdpPolicyRuleActionProvider
  { idpPolicyRuleActionProviderId :: !(Maybe Text) -- ^ "id"
  , idpPolicyRuleActionProviderType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdpPolicyRuleActionProvider
instance A.FromJSON IdpPolicyRuleActionProvider where
  parseJSON = A.withObject "IdpPolicyRuleActionProvider" $ \o ->
    IdpPolicyRuleActionProvider
      <$> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON IdpPolicyRuleActionProvider
instance A.ToJSON IdpPolicyRuleActionProvider where
  toJSON IdpPolicyRuleActionProvider {..} =
   _omitNulls
      [ "id" .= idpPolicyRuleActionProviderId
      , "type" .= idpPolicyRuleActionProviderType
      ]


-- | Construct a value of type 'IdpPolicyRuleActionProvider' (by applying it's required fields, if any)
mkIdpPolicyRuleActionProvider
  :: IdpPolicyRuleActionProvider
mkIdpPolicyRuleActionProvider =
  IdpPolicyRuleActionProvider
  { idpPolicyRuleActionProviderId = Nothing
  , idpPolicyRuleActionProviderType = Nothing
  }

-- ** ImageUploadResponse
-- | ImageUploadResponse
data ImageUploadResponse = ImageUploadResponse
  { imageUploadResponseUrl :: !(Maybe Text) -- ^ /ReadOnly/ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageUploadResponse
instance A.FromJSON ImageUploadResponse where
  parseJSON = A.withObject "ImageUploadResponse" $ \o ->
    ImageUploadResponse
      <$> (o .:? "url")

-- | ToJSON ImageUploadResponse
instance A.ToJSON ImageUploadResponse where
  toJSON ImageUploadResponse {..} =
   _omitNulls
      [ "url" .= imageUploadResponseUrl
      ]


-- | Construct a value of type 'ImageUploadResponse' (by applying it's required fields, if any)
mkImageUploadResponse
  :: ImageUploadResponse
mkImageUploadResponse =
  ImageUploadResponse
  { imageUploadResponseUrl = Nothing
  }

-- ** InactivityPolicyRuleCondition
-- | InactivityPolicyRuleCondition
data InactivityPolicyRuleCondition = InactivityPolicyRuleCondition
  { inactivityPolicyRuleConditionNumber :: !(Maybe Int) -- ^ "number"
  , inactivityPolicyRuleConditionUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InactivityPolicyRuleCondition
instance A.FromJSON InactivityPolicyRuleCondition where
  parseJSON = A.withObject "InactivityPolicyRuleCondition" $ \o ->
    InactivityPolicyRuleCondition
      <$> (o .:? "number")
      <*> (o .:? "unit")

-- | ToJSON InactivityPolicyRuleCondition
instance A.ToJSON InactivityPolicyRuleCondition where
  toJSON InactivityPolicyRuleCondition {..} =
   _omitNulls
      [ "number" .= inactivityPolicyRuleConditionNumber
      , "unit" .= inactivityPolicyRuleConditionUnit
      ]


-- | Construct a value of type 'InactivityPolicyRuleCondition' (by applying it's required fields, if any)
mkInactivityPolicyRuleCondition
  :: InactivityPolicyRuleCondition
mkInactivityPolicyRuleCondition =
  InactivityPolicyRuleCondition
  { inactivityPolicyRuleConditionNumber = Nothing
  , inactivityPolicyRuleConditionUnit = Nothing
  }

-- ** InlineHook
-- | InlineHook
data InlineHook = InlineHook
  { inlineHookLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , inlineHookChannel :: !(Maybe InlineHookChannel) -- ^ "channel"
  , inlineHookCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , inlineHookId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , inlineHookLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , inlineHookName :: !(Maybe Text) -- ^ "name"
  , inlineHookStatus :: !(Maybe InlineHookStatus) -- ^ "status"
  , inlineHookType :: !(Maybe InlineHookType) -- ^ "type"
  , inlineHookVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHook
instance A.FromJSON InlineHook where
  parseJSON = A.withObject "InlineHook" $ \o ->
    InlineHook
      <$> (o .:? "_links")
      <*> (o .:? "channel")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "status")
      <*> (o .:? "type")
      <*> (o .:? "version")

-- | ToJSON InlineHook
instance A.ToJSON InlineHook where
  toJSON InlineHook {..} =
   _omitNulls
      [ "_links" .= inlineHookLinks
      , "channel" .= inlineHookChannel
      , "created" .= inlineHookCreated
      , "id" .= inlineHookId
      , "lastUpdated" .= inlineHookLastUpdated
      , "name" .= inlineHookName
      , "status" .= inlineHookStatus
      , "type" .= inlineHookType
      , "version" .= inlineHookVersion
      ]


-- | Construct a value of type 'InlineHook' (by applying it's required fields, if any)
mkInlineHook
  :: InlineHook
mkInlineHook =
  InlineHook
  { inlineHookLinks = Nothing
  , inlineHookChannel = Nothing
  , inlineHookCreated = Nothing
  , inlineHookId = Nothing
  , inlineHookLastUpdated = Nothing
  , inlineHookName = Nothing
  , inlineHookStatus = Nothing
  , inlineHookType = Nothing
  , inlineHookVersion = Nothing
  }

-- ** InlineHookChannel
-- | InlineHookChannel
data InlineHookChannel = InlineHookChannel
  { inlineHookChannelConfig :: !(Maybe InlineHookChannelConfig) -- ^ "config"
  , inlineHookChannelType :: !(Maybe E'Type2) -- ^ "type"
  , inlineHookChannelVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookChannel
instance A.FromJSON InlineHookChannel where
  parseJSON = A.withObject "InlineHookChannel" $ \o ->
    InlineHookChannel
      <$> (o .:? "config")
      <*> (o .:? "type")
      <*> (o .:? "version")

-- | ToJSON InlineHookChannel
instance A.ToJSON InlineHookChannel where
  toJSON InlineHookChannel {..} =
   _omitNulls
      [ "config" .= inlineHookChannelConfig
      , "type" .= inlineHookChannelType
      , "version" .= inlineHookChannelVersion
      ]


-- | Construct a value of type 'InlineHookChannel' (by applying it's required fields, if any)
mkInlineHookChannel
  :: InlineHookChannel
mkInlineHookChannel =
  InlineHookChannel
  { inlineHookChannelConfig = Nothing
  , inlineHookChannelType = Nothing
  , inlineHookChannelVersion = Nothing
  }

-- ** InlineHookChannelConfig
-- | InlineHookChannelConfig
data InlineHookChannelConfig = InlineHookChannelConfig
  { inlineHookChannelConfigAuthScheme :: !(Maybe InlineHookChannelConfigAuthScheme) -- ^ "authScheme"
  , inlineHookChannelConfigHeaders :: !(Maybe [InlineHookChannelConfigHeaders]) -- ^ "headers"
  , inlineHookChannelConfigUri :: !(Maybe Text) -- ^ "uri"
  , inlineHookChannelConfigMethod :: !(Maybe Text) -- ^ "method"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookChannelConfig
instance A.FromJSON InlineHookChannelConfig where
  parseJSON = A.withObject "InlineHookChannelConfig" $ \o ->
    InlineHookChannelConfig
      <$> (o .:? "authScheme")
      <*> (o .:? "headers")
      <*> (o .:? "uri")
      <*> (o .:? "method")

-- | ToJSON InlineHookChannelConfig
instance A.ToJSON InlineHookChannelConfig where
  toJSON InlineHookChannelConfig {..} =
   _omitNulls
      [ "authScheme" .= inlineHookChannelConfigAuthScheme
      , "headers" .= inlineHookChannelConfigHeaders
      , "uri" .= inlineHookChannelConfigUri
      , "method" .= inlineHookChannelConfigMethod
      ]


-- | Construct a value of type 'InlineHookChannelConfig' (by applying it's required fields, if any)
mkInlineHookChannelConfig
  :: InlineHookChannelConfig
mkInlineHookChannelConfig =
  InlineHookChannelConfig
  { inlineHookChannelConfigAuthScheme = Nothing
  , inlineHookChannelConfigHeaders = Nothing
  , inlineHookChannelConfigUri = Nothing
  , inlineHookChannelConfigMethod = Nothing
  }

-- ** InlineHookChannelConfigAuthScheme
-- | InlineHookChannelConfigAuthScheme
data InlineHookChannelConfigAuthScheme = InlineHookChannelConfigAuthScheme
  { inlineHookChannelConfigAuthSchemeKey :: !(Maybe Text) -- ^ "key"
  , inlineHookChannelConfigAuthSchemeType :: !(Maybe Text) -- ^ "type"
  , inlineHookChannelConfigAuthSchemeValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookChannelConfigAuthScheme
instance A.FromJSON InlineHookChannelConfigAuthScheme where
  parseJSON = A.withObject "InlineHookChannelConfigAuthScheme" $ \o ->
    InlineHookChannelConfigAuthScheme
      <$> (o .:? "key")
      <*> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON InlineHookChannelConfigAuthScheme
instance A.ToJSON InlineHookChannelConfigAuthScheme where
  toJSON InlineHookChannelConfigAuthScheme {..} =
   _omitNulls
      [ "key" .= inlineHookChannelConfigAuthSchemeKey
      , "type" .= inlineHookChannelConfigAuthSchemeType
      , "value" .= inlineHookChannelConfigAuthSchemeValue
      ]


-- | Construct a value of type 'InlineHookChannelConfigAuthScheme' (by applying it's required fields, if any)
mkInlineHookChannelConfigAuthScheme
  :: InlineHookChannelConfigAuthScheme
mkInlineHookChannelConfigAuthScheme =
  InlineHookChannelConfigAuthScheme
  { inlineHookChannelConfigAuthSchemeKey = Nothing
  , inlineHookChannelConfigAuthSchemeType = Nothing
  , inlineHookChannelConfigAuthSchemeValue = Nothing
  }

-- ** InlineHookChannelConfigHeaders
-- | InlineHookChannelConfigHeaders
data InlineHookChannelConfigHeaders = InlineHookChannelConfigHeaders
  { inlineHookChannelConfigHeadersKey :: !(Maybe Text) -- ^ "key"
  , inlineHookChannelConfigHeadersValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookChannelConfigHeaders
instance A.FromJSON InlineHookChannelConfigHeaders where
  parseJSON = A.withObject "InlineHookChannelConfigHeaders" $ \o ->
    InlineHookChannelConfigHeaders
      <$> (o .:? "key")
      <*> (o .:? "value")

-- | ToJSON InlineHookChannelConfigHeaders
instance A.ToJSON InlineHookChannelConfigHeaders where
  toJSON InlineHookChannelConfigHeaders {..} =
   _omitNulls
      [ "key" .= inlineHookChannelConfigHeadersKey
      , "value" .= inlineHookChannelConfigHeadersValue
      ]


-- | Construct a value of type 'InlineHookChannelConfigHeaders' (by applying it's required fields, if any)
mkInlineHookChannelConfigHeaders
  :: InlineHookChannelConfigHeaders
mkInlineHookChannelConfigHeaders =
  InlineHookChannelConfigHeaders
  { inlineHookChannelConfigHeadersKey = Nothing
  , inlineHookChannelConfigHeadersValue = Nothing
  }

-- ** InlineHookResponse
-- | InlineHookResponse
data InlineHookResponse = InlineHookResponse
  { inlineHookResponseCommands :: !(Maybe [InlineHookResponseCommands]) -- ^ "commands"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookResponse
instance A.FromJSON InlineHookResponse where
  parseJSON = A.withObject "InlineHookResponse" $ \o ->
    InlineHookResponse
      <$> (o .:? "commands")

-- | ToJSON InlineHookResponse
instance A.ToJSON InlineHookResponse where
  toJSON InlineHookResponse {..} =
   _omitNulls
      [ "commands" .= inlineHookResponseCommands
      ]


-- | Construct a value of type 'InlineHookResponse' (by applying it's required fields, if any)
mkInlineHookResponse
  :: InlineHookResponse
mkInlineHookResponse =
  InlineHookResponse
  { inlineHookResponseCommands = Nothing
  }

-- ** InlineHookResponseCommandValue
-- | InlineHookResponseCommandValue
data InlineHookResponseCommandValue = InlineHookResponseCommandValue
  { inlineHookResponseCommandValueOp :: !(Maybe Text) -- ^ "op"
  , inlineHookResponseCommandValuePath :: !(Maybe Text) -- ^ "path"
  , inlineHookResponseCommandValueValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookResponseCommandValue
instance A.FromJSON InlineHookResponseCommandValue where
  parseJSON = A.withObject "InlineHookResponseCommandValue" $ \o ->
    InlineHookResponseCommandValue
      <$> (o .:? "op")
      <*> (o .:? "path")
      <*> (o .:? "value")

-- | ToJSON InlineHookResponseCommandValue
instance A.ToJSON InlineHookResponseCommandValue where
  toJSON InlineHookResponseCommandValue {..} =
   _omitNulls
      [ "op" .= inlineHookResponseCommandValueOp
      , "path" .= inlineHookResponseCommandValuePath
      , "value" .= inlineHookResponseCommandValueValue
      ]


-- | Construct a value of type 'InlineHookResponseCommandValue' (by applying it's required fields, if any)
mkInlineHookResponseCommandValue
  :: InlineHookResponseCommandValue
mkInlineHookResponseCommandValue =
  InlineHookResponseCommandValue
  { inlineHookResponseCommandValueOp = Nothing
  , inlineHookResponseCommandValuePath = Nothing
  , inlineHookResponseCommandValueValue = Nothing
  }

-- ** InlineHookResponseCommands
-- | InlineHookResponseCommands
data InlineHookResponseCommands = InlineHookResponseCommands
  { inlineHookResponseCommandsType :: !(Maybe Text) -- ^ "type"
  , inlineHookResponseCommandsValue :: !(Maybe [InlineHookResponseCommandValue]) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineHookResponseCommands
instance A.FromJSON InlineHookResponseCommands where
  parseJSON = A.withObject "InlineHookResponseCommands" $ \o ->
    InlineHookResponseCommands
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON InlineHookResponseCommands
instance A.ToJSON InlineHookResponseCommands where
  toJSON InlineHookResponseCommands {..} =
   _omitNulls
      [ "type" .= inlineHookResponseCommandsType
      , "value" .= inlineHookResponseCommandsValue
      ]


-- | Construct a value of type 'InlineHookResponseCommands' (by applying it's required fields, if any)
mkInlineHookResponseCommands
  :: InlineHookResponseCommands
mkInlineHookResponseCommands =
  InlineHookResponseCommands
  { inlineHookResponseCommandsType = Nothing
  , inlineHookResponseCommandsValue = Nothing
  }

-- ** IonField
-- | IonField
data IonField = IonField
  { ionFieldForm :: !(Maybe IonForm) -- ^ "form"
  , ionFieldLabel :: !(Maybe Text) -- ^ "label"
  , ionFieldMutable :: !(Maybe Bool) -- ^ "mutable"
  , ionFieldName :: !(Maybe Text) -- ^ "name"
  , ionFieldRequired :: !(Maybe Bool) -- ^ "required"
  , ionFieldSecret :: !(Maybe Bool) -- ^ "secret"
  , ionFieldType :: !(Maybe Text) -- ^ "type"
  , ionFieldValue :: !(Maybe (Map.Map String A.Value)) -- ^ "value"
  , ionFieldVisible :: !(Maybe Bool) -- ^ "visible"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IonField
instance A.FromJSON IonField where
  parseJSON = A.withObject "IonField" $ \o ->
    IonField
      <$> (o .:? "form")
      <*> (o .:? "label")
      <*> (o .:? "mutable")
      <*> (o .:? "name")
      <*> (o .:? "required")
      <*> (o .:? "secret")
      <*> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "visible")

-- | ToJSON IonField
instance A.ToJSON IonField where
  toJSON IonField {..} =
   _omitNulls
      [ "form" .= ionFieldForm
      , "label" .= ionFieldLabel
      , "mutable" .= ionFieldMutable
      , "name" .= ionFieldName
      , "required" .= ionFieldRequired
      , "secret" .= ionFieldSecret
      , "type" .= ionFieldType
      , "value" .= ionFieldValue
      , "visible" .= ionFieldVisible
      ]


-- | Construct a value of type 'IonField' (by applying it's required fields, if any)
mkIonField
  :: IonField
mkIonField =
  IonField
  { ionFieldForm = Nothing
  , ionFieldLabel = Nothing
  , ionFieldMutable = Nothing
  , ionFieldName = Nothing
  , ionFieldRequired = Nothing
  , ionFieldSecret = Nothing
  , ionFieldType = Nothing
  , ionFieldValue = Nothing
  , ionFieldVisible = Nothing
  }

-- ** IonForm
-- | IonForm
data IonForm = IonForm
  { ionFormAccepts :: !(Maybe Text) -- ^ "accepts"
  , ionFormHref :: !(Maybe Text) -- ^ "href"
  , ionFormMethod :: !(Maybe Text) -- ^ "method"
  , ionFormName :: !(Maybe Text) -- ^ "name"
  , ionFormProduces :: !(Maybe Text) -- ^ "produces"
  , ionFormRefresh :: !(Maybe Int) -- ^ "refresh"
  , ionFormRel :: !(Maybe [Text]) -- ^ "rel"
  , ionFormRelatesTo :: !(Maybe [Text]) -- ^ "relatesTo"
  , ionFormValue :: !(Maybe [IonField]) -- ^ /ReadOnly/ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IonForm
instance A.FromJSON IonForm where
  parseJSON = A.withObject "IonForm" $ \o ->
    IonForm
      <$> (o .:? "accepts")
      <*> (o .:? "href")
      <*> (o .:? "method")
      <*> (o .:? "name")
      <*> (o .:? "produces")
      <*> (o .:? "refresh")
      <*> (o .:? "rel")
      <*> (o .:? "relatesTo")
      <*> (o .:? "value")

-- | ToJSON IonForm
instance A.ToJSON IonForm where
  toJSON IonForm {..} =
   _omitNulls
      [ "accepts" .= ionFormAccepts
      , "href" .= ionFormHref
      , "method" .= ionFormMethod
      , "name" .= ionFormName
      , "produces" .= ionFormProduces
      , "refresh" .= ionFormRefresh
      , "rel" .= ionFormRel
      , "relatesTo" .= ionFormRelatesTo
      , "value" .= ionFormValue
      ]


-- | Construct a value of type 'IonForm' (by applying it's required fields, if any)
mkIonForm
  :: IonForm
mkIonForm =
  IonForm
  { ionFormAccepts = Nothing
  , ionFormHref = Nothing
  , ionFormMethod = Nothing
  , ionFormName = Nothing
  , ionFormProduces = Nothing
  , ionFormRefresh = Nothing
  , ionFormRel = Nothing
  , ionFormRelatesTo = Nothing
  , ionFormValue = Nothing
  }

-- ** JsonWebKey
-- | JsonWebKey
data JsonWebKey = JsonWebKey
  { jsonWebKeyLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , jsonWebKeyAlg :: !(Maybe Text) -- ^ "alg"
  , jsonWebKeyCreated :: !(Maybe DateTime) -- ^ "created"
  , jsonWebKeyE :: !(Maybe Text) -- ^ "e"
  , jsonWebKeyExpiresAt :: !(Maybe DateTime) -- ^ "expiresAt"
  , jsonWebKeyKeyOps :: !(Maybe [Text]) -- ^ "key_ops"
  , jsonWebKeyKid :: !(Maybe Text) -- ^ "kid"
  , jsonWebKeyKty :: !(Maybe Text) -- ^ "kty"
  , jsonWebKeyLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , jsonWebKeyN :: !(Maybe Text) -- ^ "n"
  , jsonWebKeyStatus :: !(Maybe Text) -- ^ "status"
  , jsonWebKeyUse :: !(Maybe Text) -- ^ "use"
  , jsonWebKeyX5c :: !(Maybe [Text]) -- ^ "x5c"
  , jsonWebKeyX5t :: !(Maybe Text) -- ^ "x5t"
  , jsonWebKeyX5tS256 :: !(Maybe Text) -- ^ "x5t#S256"
  , jsonWebKeyX5u :: !(Maybe Text) -- ^ "x5u"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonWebKey
instance A.FromJSON JsonWebKey where
  parseJSON = A.withObject "JsonWebKey" $ \o ->
    JsonWebKey
      <$> (o .:? "_links")
      <*> (o .:? "alg")
      <*> (o .:? "created")
      <*> (o .:? "e")
      <*> (o .:? "expiresAt")
      <*> (o .:? "key_ops")
      <*> (o .:? "kid")
      <*> (o .:? "kty")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "n")
      <*> (o .:? "status")
      <*> (o .:? "use")
      <*> (o .:? "x5c")
      <*> (o .:? "x5t")
      <*> (o .:? "x5t#S256")
      <*> (o .:? "x5u")

-- | ToJSON JsonWebKey
instance A.ToJSON JsonWebKey where
  toJSON JsonWebKey {..} =
   _omitNulls
      [ "_links" .= jsonWebKeyLinks
      , "alg" .= jsonWebKeyAlg
      , "created" .= jsonWebKeyCreated
      , "e" .= jsonWebKeyE
      , "expiresAt" .= jsonWebKeyExpiresAt
      , "key_ops" .= jsonWebKeyKeyOps
      , "kid" .= jsonWebKeyKid
      , "kty" .= jsonWebKeyKty
      , "lastUpdated" .= jsonWebKeyLastUpdated
      , "n" .= jsonWebKeyN
      , "status" .= jsonWebKeyStatus
      , "use" .= jsonWebKeyUse
      , "x5c" .= jsonWebKeyX5c
      , "x5t" .= jsonWebKeyX5t
      , "x5t#S256" .= jsonWebKeyX5tS256
      , "x5u" .= jsonWebKeyX5u
      ]


-- | Construct a value of type 'JsonWebKey' (by applying it's required fields, if any)
mkJsonWebKey
  :: JsonWebKey
mkJsonWebKey =
  JsonWebKey
  { jsonWebKeyLinks = Nothing
  , jsonWebKeyAlg = Nothing
  , jsonWebKeyCreated = Nothing
  , jsonWebKeyE = Nothing
  , jsonWebKeyExpiresAt = Nothing
  , jsonWebKeyKeyOps = Nothing
  , jsonWebKeyKid = Nothing
  , jsonWebKeyKty = Nothing
  , jsonWebKeyLastUpdated = Nothing
  , jsonWebKeyN = Nothing
  , jsonWebKeyStatus = Nothing
  , jsonWebKeyUse = Nothing
  , jsonWebKeyX5c = Nothing
  , jsonWebKeyX5t = Nothing
  , jsonWebKeyX5tS256 = Nothing
  , jsonWebKeyX5u = Nothing
  }

-- ** JwkUse
-- | JwkUse
data JwkUse = JwkUse
  { jwkUseUse :: !(Maybe E'Use) -- ^ "use"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JwkUse
instance A.FromJSON JwkUse where
  parseJSON = A.withObject "JwkUse" $ \o ->
    JwkUse
      <$> (o .:? "use")

-- | ToJSON JwkUse
instance A.ToJSON JwkUse where
  toJSON JwkUse {..} =
   _omitNulls
      [ "use" .= jwkUseUse
      ]


-- | Construct a value of type 'JwkUse' (by applying it's required fields, if any)
mkJwkUse
  :: JwkUse
mkJwkUse =
  JwkUse
  { jwkUseUse = Nothing
  }

-- ** LifecycleCreateSettingObject
-- | LifecycleCreateSettingObject
data LifecycleCreateSettingObject = LifecycleCreateSettingObject
  { lifecycleCreateSettingObjectStatus :: !(Maybe EnabledStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LifecycleCreateSettingObject
instance A.FromJSON LifecycleCreateSettingObject where
  parseJSON = A.withObject "LifecycleCreateSettingObject" $ \o ->
    LifecycleCreateSettingObject
      <$> (o .:? "status")

-- | ToJSON LifecycleCreateSettingObject
instance A.ToJSON LifecycleCreateSettingObject where
  toJSON LifecycleCreateSettingObject {..} =
   _omitNulls
      [ "status" .= lifecycleCreateSettingObjectStatus
      ]


-- | Construct a value of type 'LifecycleCreateSettingObject' (by applying it's required fields, if any)
mkLifecycleCreateSettingObject
  :: LifecycleCreateSettingObject
mkLifecycleCreateSettingObject =
  LifecycleCreateSettingObject
  { lifecycleCreateSettingObjectStatus = Nothing
  }

-- ** LifecycleDeactivateSettingObject
-- | LifecycleDeactivateSettingObject
data LifecycleDeactivateSettingObject = LifecycleDeactivateSettingObject
  { lifecycleDeactivateSettingObjectStatus :: !(Maybe EnabledStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LifecycleDeactivateSettingObject
instance A.FromJSON LifecycleDeactivateSettingObject where
  parseJSON = A.withObject "LifecycleDeactivateSettingObject" $ \o ->
    LifecycleDeactivateSettingObject
      <$> (o .:? "status")

-- | ToJSON LifecycleDeactivateSettingObject
instance A.ToJSON LifecycleDeactivateSettingObject where
  toJSON LifecycleDeactivateSettingObject {..} =
   _omitNulls
      [ "status" .= lifecycleDeactivateSettingObjectStatus
      ]


-- | Construct a value of type 'LifecycleDeactivateSettingObject' (by applying it's required fields, if any)
mkLifecycleDeactivateSettingObject
  :: LifecycleDeactivateSettingObject
mkLifecycleDeactivateSettingObject =
  LifecycleDeactivateSettingObject
  { lifecycleDeactivateSettingObjectStatus = Nothing
  }

-- ** LifecycleExpirationPolicyRuleCondition
-- | LifecycleExpirationPolicyRuleCondition
data LifecycleExpirationPolicyRuleCondition = LifecycleExpirationPolicyRuleCondition
  { lifecycleExpirationPolicyRuleConditionLifecycleStatus :: !(Maybe Text) -- ^ "lifecycleStatus"
  , lifecycleExpirationPolicyRuleConditionNumber :: !(Maybe Int) -- ^ "number"
  , lifecycleExpirationPolicyRuleConditionUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LifecycleExpirationPolicyRuleCondition
instance A.FromJSON LifecycleExpirationPolicyRuleCondition where
  parseJSON = A.withObject "LifecycleExpirationPolicyRuleCondition" $ \o ->
    LifecycleExpirationPolicyRuleCondition
      <$> (o .:? "lifecycleStatus")
      <*> (o .:? "number")
      <*> (o .:? "unit")

-- | ToJSON LifecycleExpirationPolicyRuleCondition
instance A.ToJSON LifecycleExpirationPolicyRuleCondition where
  toJSON LifecycleExpirationPolicyRuleCondition {..} =
   _omitNulls
      [ "lifecycleStatus" .= lifecycleExpirationPolicyRuleConditionLifecycleStatus
      , "number" .= lifecycleExpirationPolicyRuleConditionNumber
      , "unit" .= lifecycleExpirationPolicyRuleConditionUnit
      ]


-- | Construct a value of type 'LifecycleExpirationPolicyRuleCondition' (by applying it's required fields, if any)
mkLifecycleExpirationPolicyRuleCondition
  :: LifecycleExpirationPolicyRuleCondition
mkLifecycleExpirationPolicyRuleCondition =
  LifecycleExpirationPolicyRuleCondition
  { lifecycleExpirationPolicyRuleConditionLifecycleStatus = Nothing
  , lifecycleExpirationPolicyRuleConditionNumber = Nothing
  , lifecycleExpirationPolicyRuleConditionUnit = Nothing
  }

-- ** LinkedObject
-- | LinkedObject
data LinkedObject = LinkedObject
  { linkedObjectLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , linkedObjectAssociated :: !(Maybe LinkedObjectDetails) -- ^ "associated"
  , linkedObjectPrimary :: !(Maybe LinkedObjectDetails) -- ^ "primary"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkedObject
instance A.FromJSON LinkedObject where
  parseJSON = A.withObject "LinkedObject" $ \o ->
    LinkedObject
      <$> (o .:? "_links")
      <*> (o .:? "associated")
      <*> (o .:? "primary")

-- | ToJSON LinkedObject
instance A.ToJSON LinkedObject where
  toJSON LinkedObject {..} =
   _omitNulls
      [ "_links" .= linkedObjectLinks
      , "associated" .= linkedObjectAssociated
      , "primary" .= linkedObjectPrimary
      ]


-- | Construct a value of type 'LinkedObject' (by applying it's required fields, if any)
mkLinkedObject
  :: LinkedObject
mkLinkedObject =
  LinkedObject
  { linkedObjectLinks = Nothing
  , linkedObjectAssociated = Nothing
  , linkedObjectPrimary = Nothing
  }

-- ** LinkedObjectDetails
-- | LinkedObjectDetails
data LinkedObjectDetails = LinkedObjectDetails
  { linkedObjectDetailsDescription :: !(Maybe Text) -- ^ "description"
  , linkedObjectDetailsName :: !(Maybe Text) -- ^ "name"
  , linkedObjectDetailsTitle :: !(Maybe Text) -- ^ "title"
  , linkedObjectDetailsType :: !(Maybe LinkedObjectDetailsType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkedObjectDetails
instance A.FromJSON LinkedObjectDetails where
  parseJSON = A.withObject "LinkedObjectDetails" $ \o ->
    LinkedObjectDetails
      <$> (o .:? "description")
      <*> (o .:? "name")
      <*> (o .:? "title")
      <*> (o .:? "type")

-- | ToJSON LinkedObjectDetails
instance A.ToJSON LinkedObjectDetails where
  toJSON LinkedObjectDetails {..} =
   _omitNulls
      [ "description" .= linkedObjectDetailsDescription
      , "name" .= linkedObjectDetailsName
      , "title" .= linkedObjectDetailsTitle
      , "type" .= linkedObjectDetailsType
      ]


-- | Construct a value of type 'LinkedObjectDetails' (by applying it's required fields, if any)
mkLinkedObjectDetails
  :: LinkedObjectDetails
mkLinkedObjectDetails =
  LinkedObjectDetails
  { linkedObjectDetailsDescription = Nothing
  , linkedObjectDetailsName = Nothing
  , linkedObjectDetailsTitle = Nothing
  , linkedObjectDetailsType = Nothing
  }

-- ** LogActor
-- | LogActor
data LogActor = LogActor
  { logActorAlternateId :: !(Maybe Text) -- ^ /ReadOnly/ "alternateId"
  , logActorDetail :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "detail"
  , logActorDisplayName :: !(Maybe Text) -- ^ /ReadOnly/ "displayName"
  , logActorId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , logActorType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogActor
instance A.FromJSON LogActor where
  parseJSON = A.withObject "LogActor" $ \o ->
    LogActor
      <$> (o .:? "alternateId")
      <*> (o .:? "detail")
      <*> (o .:? "displayName")
      <*> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogActor
instance A.ToJSON LogActor where
  toJSON LogActor {..} =
   _omitNulls
      [ "alternateId" .= logActorAlternateId
      , "detail" .= logActorDetail
      , "displayName" .= logActorDisplayName
      , "id" .= logActorId
      , "type" .= logActorType
      ]


-- | Construct a value of type 'LogActor' (by applying it's required fields, if any)
mkLogActor
  :: LogActor
mkLogActor =
  LogActor
  { logActorAlternateId = Nothing
  , logActorDetail = Nothing
  , logActorDisplayName = Nothing
  , logActorId = Nothing
  , logActorType = Nothing
  }

-- ** LogAuthenticationContext
-- | LogAuthenticationContext
data LogAuthenticationContext = LogAuthenticationContext
  { logAuthenticationContextAuthenticationProvider :: !(Maybe LogAuthenticationProvider) -- ^ "authenticationProvider"
  , logAuthenticationContextAuthenticationStep :: !(Maybe Int) -- ^ /ReadOnly/ "authenticationStep"
  , logAuthenticationContextCredentialProvider :: !(Maybe LogCredentialProvider) -- ^ "credentialProvider"
  , logAuthenticationContextCredentialType :: !(Maybe LogCredentialType) -- ^ "credentialType"
  , logAuthenticationContextExternalSessionId :: !(Maybe Text) -- ^ /ReadOnly/ "externalSessionId"
  , logAuthenticationContextInterface :: !(Maybe Text) -- ^ /ReadOnly/ "interface"
  , logAuthenticationContextIssuer :: !(Maybe LogIssuer) -- ^ "issuer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogAuthenticationContext
instance A.FromJSON LogAuthenticationContext where
  parseJSON = A.withObject "LogAuthenticationContext" $ \o ->
    LogAuthenticationContext
      <$> (o .:? "authenticationProvider")
      <*> (o .:? "authenticationStep")
      <*> (o .:? "credentialProvider")
      <*> (o .:? "credentialType")
      <*> (o .:? "externalSessionId")
      <*> (o .:? "interface")
      <*> (o .:? "issuer")

-- | ToJSON LogAuthenticationContext
instance A.ToJSON LogAuthenticationContext where
  toJSON LogAuthenticationContext {..} =
   _omitNulls
      [ "authenticationProvider" .= logAuthenticationContextAuthenticationProvider
      , "authenticationStep" .= logAuthenticationContextAuthenticationStep
      , "credentialProvider" .= logAuthenticationContextCredentialProvider
      , "credentialType" .= logAuthenticationContextCredentialType
      , "externalSessionId" .= logAuthenticationContextExternalSessionId
      , "interface" .= logAuthenticationContextInterface
      , "issuer" .= logAuthenticationContextIssuer
      ]


-- | Construct a value of type 'LogAuthenticationContext' (by applying it's required fields, if any)
mkLogAuthenticationContext
  :: LogAuthenticationContext
mkLogAuthenticationContext =
  LogAuthenticationContext
  { logAuthenticationContextAuthenticationProvider = Nothing
  , logAuthenticationContextAuthenticationStep = Nothing
  , logAuthenticationContextCredentialProvider = Nothing
  , logAuthenticationContextCredentialType = Nothing
  , logAuthenticationContextExternalSessionId = Nothing
  , logAuthenticationContextInterface = Nothing
  , logAuthenticationContextIssuer = Nothing
  }

-- ** LogClient
-- | LogClient
data LogClient = LogClient
  { logClientDevice :: !(Maybe Text) -- ^ /ReadOnly/ "device"
  , logClientGeographicalContext :: !(Maybe LogGeographicalContext) -- ^ "geographicalContext"
  , logClientId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , logClientIpAddress :: !(Maybe Text) -- ^ /ReadOnly/ "ipAddress"
  , logClientUserAgent :: !(Maybe LogUserAgent) -- ^ "userAgent"
  , logClientZone :: !(Maybe Text) -- ^ /ReadOnly/ "zone"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogClient
instance A.FromJSON LogClient where
  parseJSON = A.withObject "LogClient" $ \o ->
    LogClient
      <$> (o .:? "device")
      <*> (o .:? "geographicalContext")
      <*> (o .:? "id")
      <*> (o .:? "ipAddress")
      <*> (o .:? "userAgent")
      <*> (o .:? "zone")

-- | ToJSON LogClient
instance A.ToJSON LogClient where
  toJSON LogClient {..} =
   _omitNulls
      [ "device" .= logClientDevice
      , "geographicalContext" .= logClientGeographicalContext
      , "id" .= logClientId
      , "ipAddress" .= logClientIpAddress
      , "userAgent" .= logClientUserAgent
      , "zone" .= logClientZone
      ]


-- | Construct a value of type 'LogClient' (by applying it's required fields, if any)
mkLogClient
  :: LogClient
mkLogClient =
  LogClient
  { logClientDevice = Nothing
  , logClientGeographicalContext = Nothing
  , logClientId = Nothing
  , logClientIpAddress = Nothing
  , logClientUserAgent = Nothing
  , logClientZone = Nothing
  }

-- ** LogDebugContext
-- | LogDebugContext
data LogDebugContext = LogDebugContext
  { logDebugContextDebugData :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "debugData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogDebugContext
instance A.FromJSON LogDebugContext where
  parseJSON = A.withObject "LogDebugContext" $ \o ->
    LogDebugContext
      <$> (o .:? "debugData")

-- | ToJSON LogDebugContext
instance A.ToJSON LogDebugContext where
  toJSON LogDebugContext {..} =
   _omitNulls
      [ "debugData" .= logDebugContextDebugData
      ]


-- | Construct a value of type 'LogDebugContext' (by applying it's required fields, if any)
mkLogDebugContext
  :: LogDebugContext
mkLogDebugContext =
  LogDebugContext
  { logDebugContextDebugData = Nothing
  }

-- ** LogEvent
-- | LogEvent
data LogEvent = LogEvent
  { logEventActor :: !(Maybe LogActor) -- ^ "actor"
  , logEventAuthenticationContext :: !(Maybe LogAuthenticationContext) -- ^ "authenticationContext"
  , logEventClient :: !(Maybe LogClient) -- ^ "client"
  , logEventDebugContext :: !(Maybe LogDebugContext) -- ^ "debugContext"
  , logEventDisplayMessage :: !(Maybe Text) -- ^ /ReadOnly/ "displayMessage"
  , logEventEventType :: !(Maybe Text) -- ^ /ReadOnly/ "eventType"
  , logEventLegacyEventType :: !(Maybe Text) -- ^ /ReadOnly/ "legacyEventType"
  , logEventOutcome :: !(Maybe LogOutcome) -- ^ "outcome"
  , logEventPublished :: !(Maybe DateTime) -- ^ /ReadOnly/ "published"
  , logEventRequest :: !(Maybe LogRequest) -- ^ "request"
  , logEventSecurityContext :: !(Maybe LogSecurityContext) -- ^ "securityContext"
  , logEventSeverity :: !(Maybe LogSeverity) -- ^ "severity"
  , logEventTarget :: !(Maybe [LogTarget]) -- ^ /ReadOnly/ "target"
  , logEventTransaction :: !(Maybe LogTransaction) -- ^ "transaction"
  , logEventUuid :: !(Maybe Text) -- ^ /ReadOnly/ "uuid"
  , logEventVersion :: !(Maybe Text) -- ^ /ReadOnly/ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogEvent
instance A.FromJSON LogEvent where
  parseJSON = A.withObject "LogEvent" $ \o ->
    LogEvent
      <$> (o .:? "actor")
      <*> (o .:? "authenticationContext")
      <*> (o .:? "client")
      <*> (o .:? "debugContext")
      <*> (o .:? "displayMessage")
      <*> (o .:? "eventType")
      <*> (o .:? "legacyEventType")
      <*> (o .:? "outcome")
      <*> (o .:? "published")
      <*> (o .:? "request")
      <*> (o .:? "securityContext")
      <*> (o .:? "severity")
      <*> (o .:? "target")
      <*> (o .:? "transaction")
      <*> (o .:? "uuid")
      <*> (o .:? "version")

-- | ToJSON LogEvent
instance A.ToJSON LogEvent where
  toJSON LogEvent {..} =
   _omitNulls
      [ "actor" .= logEventActor
      , "authenticationContext" .= logEventAuthenticationContext
      , "client" .= logEventClient
      , "debugContext" .= logEventDebugContext
      , "displayMessage" .= logEventDisplayMessage
      , "eventType" .= logEventEventType
      , "legacyEventType" .= logEventLegacyEventType
      , "outcome" .= logEventOutcome
      , "published" .= logEventPublished
      , "request" .= logEventRequest
      , "securityContext" .= logEventSecurityContext
      , "severity" .= logEventSeverity
      , "target" .= logEventTarget
      , "transaction" .= logEventTransaction
      , "uuid" .= logEventUuid
      , "version" .= logEventVersion
      ]


-- | Construct a value of type 'LogEvent' (by applying it's required fields, if any)
mkLogEvent
  :: LogEvent
mkLogEvent =
  LogEvent
  { logEventActor = Nothing
  , logEventAuthenticationContext = Nothing
  , logEventClient = Nothing
  , logEventDebugContext = Nothing
  , logEventDisplayMessage = Nothing
  , logEventEventType = Nothing
  , logEventLegacyEventType = Nothing
  , logEventOutcome = Nothing
  , logEventPublished = Nothing
  , logEventRequest = Nothing
  , logEventSecurityContext = Nothing
  , logEventSeverity = Nothing
  , logEventTarget = Nothing
  , logEventTransaction = Nothing
  , logEventUuid = Nothing
  , logEventVersion = Nothing
  }

-- ** LogGeographicalContext
-- | LogGeographicalContext
data LogGeographicalContext = LogGeographicalContext
  { logGeographicalContextCity :: !(Maybe Text) -- ^ /ReadOnly/ "city"
  , logGeographicalContextCountry :: !(Maybe Text) -- ^ /ReadOnly/ "country"
  , logGeographicalContextGeolocation :: !(Maybe LogGeolocation) -- ^ "geolocation"
  , logGeographicalContextPostalCode :: !(Maybe Text) -- ^ /ReadOnly/ "postalCode"
  , logGeographicalContextState :: !(Maybe Text) -- ^ /ReadOnly/ "state"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogGeographicalContext
instance A.FromJSON LogGeographicalContext where
  parseJSON = A.withObject "LogGeographicalContext" $ \o ->
    LogGeographicalContext
      <$> (o .:? "city")
      <*> (o .:? "country")
      <*> (o .:? "geolocation")
      <*> (o .:? "postalCode")
      <*> (o .:? "state")

-- | ToJSON LogGeographicalContext
instance A.ToJSON LogGeographicalContext where
  toJSON LogGeographicalContext {..} =
   _omitNulls
      [ "city" .= logGeographicalContextCity
      , "country" .= logGeographicalContextCountry
      , "geolocation" .= logGeographicalContextGeolocation
      , "postalCode" .= logGeographicalContextPostalCode
      , "state" .= logGeographicalContextState
      ]


-- | Construct a value of type 'LogGeographicalContext' (by applying it's required fields, if any)
mkLogGeographicalContext
  :: LogGeographicalContext
mkLogGeographicalContext =
  LogGeographicalContext
  { logGeographicalContextCity = Nothing
  , logGeographicalContextCountry = Nothing
  , logGeographicalContextGeolocation = Nothing
  , logGeographicalContextPostalCode = Nothing
  , logGeographicalContextState = Nothing
  }

-- ** LogGeolocation
-- | LogGeolocation
data LogGeolocation = LogGeolocation
  { logGeolocationLat :: !(Maybe Double) -- ^ /ReadOnly/ "lat"
  , logGeolocationLon :: !(Maybe Double) -- ^ /ReadOnly/ "lon"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogGeolocation
instance A.FromJSON LogGeolocation where
  parseJSON = A.withObject "LogGeolocation" $ \o ->
    LogGeolocation
      <$> (o .:? "lat")
      <*> (o .:? "lon")

-- | ToJSON LogGeolocation
instance A.ToJSON LogGeolocation where
  toJSON LogGeolocation {..} =
   _omitNulls
      [ "lat" .= logGeolocationLat
      , "lon" .= logGeolocationLon
      ]


-- | Construct a value of type 'LogGeolocation' (by applying it's required fields, if any)
mkLogGeolocation
  :: LogGeolocation
mkLogGeolocation =
  LogGeolocation
  { logGeolocationLat = Nothing
  , logGeolocationLon = Nothing
  }

-- ** LogIpAddress
-- | LogIpAddress
data LogIpAddress = LogIpAddress
  { logIpAddressGeographicalContext :: !(Maybe LogGeographicalContext) -- ^ "geographicalContext"
  , logIpAddressIp :: !(Maybe Text) -- ^ /ReadOnly/ "ip"
  , logIpAddressSource :: !(Maybe Text) -- ^ /ReadOnly/ "source"
  , logIpAddressVersion :: !(Maybe Text) -- ^ /ReadOnly/ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogIpAddress
instance A.FromJSON LogIpAddress where
  parseJSON = A.withObject "LogIpAddress" $ \o ->
    LogIpAddress
      <$> (o .:? "geographicalContext")
      <*> (o .:? "ip")
      <*> (o .:? "source")
      <*> (o .:? "version")

-- | ToJSON LogIpAddress
instance A.ToJSON LogIpAddress where
  toJSON LogIpAddress {..} =
   _omitNulls
      [ "geographicalContext" .= logIpAddressGeographicalContext
      , "ip" .= logIpAddressIp
      , "source" .= logIpAddressSource
      , "version" .= logIpAddressVersion
      ]


-- | Construct a value of type 'LogIpAddress' (by applying it's required fields, if any)
mkLogIpAddress
  :: LogIpAddress
mkLogIpAddress =
  LogIpAddress
  { logIpAddressGeographicalContext = Nothing
  , logIpAddressIp = Nothing
  , logIpAddressSource = Nothing
  , logIpAddressVersion = Nothing
  }

-- ** LogIssuer
-- | LogIssuer
data LogIssuer = LogIssuer
  { logIssuerId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , logIssuerType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogIssuer
instance A.FromJSON LogIssuer where
  parseJSON = A.withObject "LogIssuer" $ \o ->
    LogIssuer
      <$> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogIssuer
instance A.ToJSON LogIssuer where
  toJSON LogIssuer {..} =
   _omitNulls
      [ "id" .= logIssuerId
      , "type" .= logIssuerType
      ]


-- | Construct a value of type 'LogIssuer' (by applying it's required fields, if any)
mkLogIssuer
  :: LogIssuer
mkLogIssuer =
  LogIssuer
  { logIssuerId = Nothing
  , logIssuerType = Nothing
  }

-- ** LogOutcome
-- | LogOutcome
data LogOutcome = LogOutcome
  { logOutcomeReason :: !(Maybe Text) -- ^ /ReadOnly/ "reason"
  , logOutcomeResult :: !(Maybe Text) -- ^ /ReadOnly/ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogOutcome
instance A.FromJSON LogOutcome where
  parseJSON = A.withObject "LogOutcome" $ \o ->
    LogOutcome
      <$> (o .:? "reason")
      <*> (o .:? "result")

-- | ToJSON LogOutcome
instance A.ToJSON LogOutcome where
  toJSON LogOutcome {..} =
   _omitNulls
      [ "reason" .= logOutcomeReason
      , "result" .= logOutcomeResult
      ]


-- | Construct a value of type 'LogOutcome' (by applying it's required fields, if any)
mkLogOutcome
  :: LogOutcome
mkLogOutcome =
  LogOutcome
  { logOutcomeReason = Nothing
  , logOutcomeResult = Nothing
  }

-- ** LogRequest
-- | LogRequest
data LogRequest = LogRequest
  { logRequestIpChain :: !(Maybe [LogIpAddress]) -- ^ /ReadOnly/ "ipChain"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogRequest
instance A.FromJSON LogRequest where
  parseJSON = A.withObject "LogRequest" $ \o ->
    LogRequest
      <$> (o .:? "ipChain")

-- | ToJSON LogRequest
instance A.ToJSON LogRequest where
  toJSON LogRequest {..} =
   _omitNulls
      [ "ipChain" .= logRequestIpChain
      ]


-- | Construct a value of type 'LogRequest' (by applying it's required fields, if any)
mkLogRequest
  :: LogRequest
mkLogRequest =
  LogRequest
  { logRequestIpChain = Nothing
  }

-- ** LogSecurityContext
-- | LogSecurityContext
data LogSecurityContext = LogSecurityContext
  { logSecurityContextAsNumber :: !(Maybe Int) -- ^ /ReadOnly/ "asNumber"
  , logSecurityContextAsOrg :: !(Maybe Text) -- ^ /ReadOnly/ "asOrg"
  , logSecurityContextDomain :: !(Maybe Text) -- ^ /ReadOnly/ "domain"
  , logSecurityContextIsProxy :: !(Maybe Bool) -- ^ /ReadOnly/ "isProxy"
  , logSecurityContextIsp :: !(Maybe Text) -- ^ /ReadOnly/ "isp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogSecurityContext
instance A.FromJSON LogSecurityContext where
  parseJSON = A.withObject "LogSecurityContext" $ \o ->
    LogSecurityContext
      <$> (o .:? "asNumber")
      <*> (o .:? "asOrg")
      <*> (o .:? "domain")
      <*> (o .:? "isProxy")
      <*> (o .:? "isp")

-- | ToJSON LogSecurityContext
instance A.ToJSON LogSecurityContext where
  toJSON LogSecurityContext {..} =
   _omitNulls
      [ "asNumber" .= logSecurityContextAsNumber
      , "asOrg" .= logSecurityContextAsOrg
      , "domain" .= logSecurityContextDomain
      , "isProxy" .= logSecurityContextIsProxy
      , "isp" .= logSecurityContextIsp
      ]


-- | Construct a value of type 'LogSecurityContext' (by applying it's required fields, if any)
mkLogSecurityContext
  :: LogSecurityContext
mkLogSecurityContext =
  LogSecurityContext
  { logSecurityContextAsNumber = Nothing
  , logSecurityContextAsOrg = Nothing
  , logSecurityContextDomain = Nothing
  , logSecurityContextIsProxy = Nothing
  , logSecurityContextIsp = Nothing
  }

-- ** LogTarget
-- | LogTarget
data LogTarget = LogTarget
  { logTargetAlternateId :: !(Maybe Text) -- ^ /ReadOnly/ "alternateId"
  , logTargetDetailEntry :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "detailEntry"
  , logTargetDisplayName :: !(Maybe Text) -- ^ /ReadOnly/ "displayName"
  , logTargetId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , logTargetType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogTarget
instance A.FromJSON LogTarget where
  parseJSON = A.withObject "LogTarget" $ \o ->
    LogTarget
      <$> (o .:? "alternateId")
      <*> (o .:? "detailEntry")
      <*> (o .:? "displayName")
      <*> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogTarget
instance A.ToJSON LogTarget where
  toJSON LogTarget {..} =
   _omitNulls
      [ "alternateId" .= logTargetAlternateId
      , "detailEntry" .= logTargetDetailEntry
      , "displayName" .= logTargetDisplayName
      , "id" .= logTargetId
      , "type" .= logTargetType
      ]


-- | Construct a value of type 'LogTarget' (by applying it's required fields, if any)
mkLogTarget
  :: LogTarget
mkLogTarget =
  LogTarget
  { logTargetAlternateId = Nothing
  , logTargetDetailEntry = Nothing
  , logTargetDisplayName = Nothing
  , logTargetId = Nothing
  , logTargetType = Nothing
  }

-- ** LogTransaction
-- | LogTransaction
data LogTransaction = LogTransaction
  { logTransactionDetail :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "detail"
  , logTransactionId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , logTransactionType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogTransaction
instance A.FromJSON LogTransaction where
  parseJSON = A.withObject "LogTransaction" $ \o ->
    LogTransaction
      <$> (o .:? "detail")
      <*> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogTransaction
instance A.ToJSON LogTransaction where
  toJSON LogTransaction {..} =
   _omitNulls
      [ "detail" .= logTransactionDetail
      , "id" .= logTransactionId
      , "type" .= logTransactionType
      ]


-- | Construct a value of type 'LogTransaction' (by applying it's required fields, if any)
mkLogTransaction
  :: LogTransaction
mkLogTransaction =
  LogTransaction
  { logTransactionDetail = Nothing
  , logTransactionId = Nothing
  , logTransactionType = Nothing
  }

-- ** LogUserAgent
-- | LogUserAgent
data LogUserAgent = LogUserAgent
  { logUserAgentBrowser :: !(Maybe Text) -- ^ /ReadOnly/ "browser"
  , logUserAgentOs :: !(Maybe Text) -- ^ /ReadOnly/ "os"
  , logUserAgentRawUserAgent :: !(Maybe Text) -- ^ /ReadOnly/ "rawUserAgent"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogUserAgent
instance A.FromJSON LogUserAgent where
  parseJSON = A.withObject "LogUserAgent" $ \o ->
    LogUserAgent
      <$> (o .:? "browser")
      <*> (o .:? "os")
      <*> (o .:? "rawUserAgent")

-- | ToJSON LogUserAgent
instance A.ToJSON LogUserAgent where
  toJSON LogUserAgent {..} =
   _omitNulls
      [ "browser" .= logUserAgentBrowser
      , "os" .= logUserAgentOs
      , "rawUserAgent" .= logUserAgentRawUserAgent
      ]


-- | Construct a value of type 'LogUserAgent' (by applying it's required fields, if any)
mkLogUserAgent
  :: LogUserAgent
mkLogUserAgent =
  LogUserAgent
  { logUserAgentBrowser = Nothing
  , logUserAgentOs = Nothing
  , logUserAgentRawUserAgent = Nothing
  }

-- ** MDMEnrollmentPolicyRuleCondition
-- | MDMEnrollmentPolicyRuleCondition
data MDMEnrollmentPolicyRuleCondition = MDMEnrollmentPolicyRuleCondition
  { mDMEnrollmentPolicyRuleConditionBlockNonSafeAndroid :: !(Maybe Bool) -- ^ "blockNonSafeAndroid"
  , mDMEnrollmentPolicyRuleConditionEnrollment :: !(Maybe E'Enrollment) -- ^ "enrollment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MDMEnrollmentPolicyRuleCondition
instance A.FromJSON MDMEnrollmentPolicyRuleCondition where
  parseJSON = A.withObject "MDMEnrollmentPolicyRuleCondition" $ \o ->
    MDMEnrollmentPolicyRuleCondition
      <$> (o .:? "blockNonSafeAndroid")
      <*> (o .:? "enrollment")

-- | ToJSON MDMEnrollmentPolicyRuleCondition
instance A.ToJSON MDMEnrollmentPolicyRuleCondition where
  toJSON MDMEnrollmentPolicyRuleCondition {..} =
   _omitNulls
      [ "blockNonSafeAndroid" .= mDMEnrollmentPolicyRuleConditionBlockNonSafeAndroid
      , "enrollment" .= mDMEnrollmentPolicyRuleConditionEnrollment
      ]


-- | Construct a value of type 'MDMEnrollmentPolicyRuleCondition' (by applying it's required fields, if any)
mkMDMEnrollmentPolicyRuleCondition
  :: MDMEnrollmentPolicyRuleCondition
mkMDMEnrollmentPolicyRuleCondition =
  MDMEnrollmentPolicyRuleCondition
  { mDMEnrollmentPolicyRuleConditionBlockNonSafeAndroid = Nothing
  , mDMEnrollmentPolicyRuleConditionEnrollment = Nothing
  }

-- ** NetworkZone
-- | NetworkZone
data NetworkZone = NetworkZone
  { networkZoneType :: !(Maybe NetworkZoneType) -- ^ "type"
  , networkZoneId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , networkZoneName :: !(Maybe Text) -- ^ "name"
  , networkZoneSystem :: !(Maybe Bool) -- ^ "system"
  , networkZoneUsage :: !(Maybe NetworkZoneUsage) -- ^ "usage"
  , networkZoneStatus :: !(Maybe NetworkZoneStatus) -- ^ "status"
  , networkZoneProxyType :: !(Maybe Text) -- ^ "proxyType"
  , networkZoneLocations :: !(Maybe [NetworkZoneLocation]) -- ^ "locations"
  , networkZoneGateways :: !(Maybe [NetworkZoneAddress]) -- ^ "gateways"
  , networkZoneProxies :: !(Maybe [NetworkZoneAddress]) -- ^ "proxies"
  , networkZoneAsns :: !(Maybe [Text]) -- ^ "asns"
  , networkZoneCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , networkZoneLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , networkZoneLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkZone
instance A.FromJSON NetworkZone where
  parseJSON = A.withObject "NetworkZone" $ \o ->
    NetworkZone
      <$> (o .:? "type")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "system")
      <*> (o .:? "usage")
      <*> (o .:? "status")
      <*> (o .:? "proxyType")
      <*> (o .:? "locations")
      <*> (o .:? "gateways")
      <*> (o .:? "proxies")
      <*> (o .:? "asns")
      <*> (o .:? "created")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "_links")

-- | ToJSON NetworkZone
instance A.ToJSON NetworkZone where
  toJSON NetworkZone {..} =
   _omitNulls
      [ "type" .= networkZoneType
      , "id" .= networkZoneId
      , "name" .= networkZoneName
      , "system" .= networkZoneSystem
      , "usage" .= networkZoneUsage
      , "status" .= networkZoneStatus
      , "proxyType" .= networkZoneProxyType
      , "locations" .= networkZoneLocations
      , "gateways" .= networkZoneGateways
      , "proxies" .= networkZoneProxies
      , "asns" .= networkZoneAsns
      , "created" .= networkZoneCreated
      , "lastUpdated" .= networkZoneLastUpdated
      , "_links" .= networkZoneLinks
      ]


-- | Construct a value of type 'NetworkZone' (by applying it's required fields, if any)
mkNetworkZone
  :: NetworkZone
mkNetworkZone =
  NetworkZone
  { networkZoneType = Nothing
  , networkZoneId = Nothing
  , networkZoneName = Nothing
  , networkZoneSystem = Nothing
  , networkZoneUsage = Nothing
  , networkZoneStatus = Nothing
  , networkZoneProxyType = Nothing
  , networkZoneLocations = Nothing
  , networkZoneGateways = Nothing
  , networkZoneProxies = Nothing
  , networkZoneAsns = Nothing
  , networkZoneCreated = Nothing
  , networkZoneLastUpdated = Nothing
  , networkZoneLinks = Nothing
  }

-- ** NetworkZoneAddress
-- | NetworkZoneAddress
data NetworkZoneAddress = NetworkZoneAddress
  { networkZoneAddressType :: !(Maybe NetworkZoneAddressType) -- ^ "type"
  , networkZoneAddressValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkZoneAddress
instance A.FromJSON NetworkZoneAddress where
  parseJSON = A.withObject "NetworkZoneAddress" $ \o ->
    NetworkZoneAddress
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON NetworkZoneAddress
instance A.ToJSON NetworkZoneAddress where
  toJSON NetworkZoneAddress {..} =
   _omitNulls
      [ "type" .= networkZoneAddressType
      , "value" .= networkZoneAddressValue
      ]


-- | Construct a value of type 'NetworkZoneAddress' (by applying it's required fields, if any)
mkNetworkZoneAddress
  :: NetworkZoneAddress
mkNetworkZoneAddress =
  NetworkZoneAddress
  { networkZoneAddressType = Nothing
  , networkZoneAddressValue = Nothing
  }

-- ** NetworkZoneLocation
-- | NetworkZoneLocation
data NetworkZoneLocation = NetworkZoneLocation
  { networkZoneLocationCountry :: !(Maybe Text) -- ^ "country"
  , networkZoneLocationRegion :: !(Maybe Text) -- ^ "region"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkZoneLocation
instance A.FromJSON NetworkZoneLocation where
  parseJSON = A.withObject "NetworkZoneLocation" $ \o ->
    NetworkZoneLocation
      <$> (o .:? "country")
      <*> (o .:? "region")

-- | ToJSON NetworkZoneLocation
instance A.ToJSON NetworkZoneLocation where
  toJSON NetworkZoneLocation {..} =
   _omitNulls
      [ "country" .= networkZoneLocationCountry
      , "region" .= networkZoneLocationRegion
      ]


-- | Construct a value of type 'NetworkZoneLocation' (by applying it's required fields, if any)
mkNetworkZoneLocation
  :: NetworkZoneLocation
mkNetworkZoneLocation =
  NetworkZoneLocation
  { networkZoneLocationCountry = Nothing
  , networkZoneLocationRegion = Nothing
  }

-- ** OAuth2Actor
-- | OAuth2Actor
data OAuth2Actor = OAuth2Actor
  { oAuth2ActorId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , oAuth2ActorType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2Actor
instance A.FromJSON OAuth2Actor where
  parseJSON = A.withObject "OAuth2Actor" $ \o ->
    OAuth2Actor
      <$> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON OAuth2Actor
instance A.ToJSON OAuth2Actor where
  toJSON OAuth2Actor {..} =
   _omitNulls
      [ "id" .= oAuth2ActorId
      , "type" .= oAuth2ActorType
      ]


-- | Construct a value of type 'OAuth2Actor' (by applying it's required fields, if any)
mkOAuth2Actor
  :: OAuth2Actor
mkOAuth2Actor =
  OAuth2Actor
  { oAuth2ActorId = Nothing
  , oAuth2ActorType = Nothing
  }

-- ** OAuth2Claim
-- | OAuth2Claim
data OAuth2Claim = OAuth2Claim
  { oAuth2ClaimLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , oAuth2ClaimAlwaysIncludeInToken :: !(Maybe Bool) -- ^ "alwaysIncludeInToken"
  , oAuth2ClaimClaimType :: !(Maybe E'ClaimType) -- ^ "claimType"
  , oAuth2ClaimConditions :: !(Maybe OAuth2ClaimConditions) -- ^ "conditions"
  , oAuth2ClaimGroupFilterType :: !(Maybe E'GroupFilterType) -- ^ "group_filter_type"
  , oAuth2ClaimId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , oAuth2ClaimName :: !(Maybe Text) -- ^ "name"
  , oAuth2ClaimStatus :: !(Maybe E'Status2) -- ^ "status"
  , oAuth2ClaimSystem :: !(Maybe Bool) -- ^ "system"
  , oAuth2ClaimValue :: !(Maybe Text) -- ^ "value"
  , oAuth2ClaimValueType :: !(Maybe E'ValueType) -- ^ "valueType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2Claim
instance A.FromJSON OAuth2Claim where
  parseJSON = A.withObject "OAuth2Claim" $ \o ->
    OAuth2Claim
      <$> (o .:? "_links")
      <*> (o .:? "alwaysIncludeInToken")
      <*> (o .:? "claimType")
      <*> (o .:? "conditions")
      <*> (o .:? "group_filter_type")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "status")
      <*> (o .:? "system")
      <*> (o .:? "value")
      <*> (o .:? "valueType")

-- | ToJSON OAuth2Claim
instance A.ToJSON OAuth2Claim where
  toJSON OAuth2Claim {..} =
   _omitNulls
      [ "_links" .= oAuth2ClaimLinks
      , "alwaysIncludeInToken" .= oAuth2ClaimAlwaysIncludeInToken
      , "claimType" .= oAuth2ClaimClaimType
      , "conditions" .= oAuth2ClaimConditions
      , "group_filter_type" .= oAuth2ClaimGroupFilterType
      , "id" .= oAuth2ClaimId
      , "name" .= oAuth2ClaimName
      , "status" .= oAuth2ClaimStatus
      , "system" .= oAuth2ClaimSystem
      , "value" .= oAuth2ClaimValue
      , "valueType" .= oAuth2ClaimValueType
      ]


-- | Construct a value of type 'OAuth2Claim' (by applying it's required fields, if any)
mkOAuth2Claim
  :: OAuth2Claim
mkOAuth2Claim =
  OAuth2Claim
  { oAuth2ClaimLinks = Nothing
  , oAuth2ClaimAlwaysIncludeInToken = Nothing
  , oAuth2ClaimClaimType = Nothing
  , oAuth2ClaimConditions = Nothing
  , oAuth2ClaimGroupFilterType = Nothing
  , oAuth2ClaimId = Nothing
  , oAuth2ClaimName = Nothing
  , oAuth2ClaimStatus = Nothing
  , oAuth2ClaimSystem = Nothing
  , oAuth2ClaimValue = Nothing
  , oAuth2ClaimValueType = Nothing
  }

-- ** OAuth2ClaimConditions
-- | OAuth2ClaimConditions
data OAuth2ClaimConditions = OAuth2ClaimConditions
  { oAuth2ClaimConditionsScopes :: !(Maybe [Text]) -- ^ "scopes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2ClaimConditions
instance A.FromJSON OAuth2ClaimConditions where
  parseJSON = A.withObject "OAuth2ClaimConditions" $ \o ->
    OAuth2ClaimConditions
      <$> (o .:? "scopes")

-- | ToJSON OAuth2ClaimConditions
instance A.ToJSON OAuth2ClaimConditions where
  toJSON OAuth2ClaimConditions {..} =
   _omitNulls
      [ "scopes" .= oAuth2ClaimConditionsScopes
      ]


-- | Construct a value of type 'OAuth2ClaimConditions' (by applying it's required fields, if any)
mkOAuth2ClaimConditions
  :: OAuth2ClaimConditions
mkOAuth2ClaimConditions =
  OAuth2ClaimConditions
  { oAuth2ClaimConditionsScopes = Nothing
  }

-- ** OAuth2Client
-- | OAuth2Client
data OAuth2Client = OAuth2Client
  { oAuth2ClientLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , oAuth2ClientClientId :: !(Maybe Text) -- ^ /ReadOnly/ "client_id"
  , oAuth2ClientClientName :: !(Maybe Text) -- ^ /ReadOnly/ "client_name"
  , oAuth2ClientClientUri :: !(Maybe Text) -- ^ /ReadOnly/ "client_uri"
  , oAuth2ClientLogoUri :: !(Maybe Text) -- ^ /ReadOnly/ "logo_uri"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2Client
instance A.FromJSON OAuth2Client where
  parseJSON = A.withObject "OAuth2Client" $ \o ->
    OAuth2Client
      <$> (o .:? "_links")
      <*> (o .:? "client_id")
      <*> (o .:? "client_name")
      <*> (o .:? "client_uri")
      <*> (o .:? "logo_uri")

-- | ToJSON OAuth2Client
instance A.ToJSON OAuth2Client where
  toJSON OAuth2Client {..} =
   _omitNulls
      [ "_links" .= oAuth2ClientLinks
      , "client_id" .= oAuth2ClientClientId
      , "client_name" .= oAuth2ClientClientName
      , "client_uri" .= oAuth2ClientClientUri
      , "logo_uri" .= oAuth2ClientLogoUri
      ]


-- | Construct a value of type 'OAuth2Client' (by applying it's required fields, if any)
mkOAuth2Client
  :: OAuth2Client
mkOAuth2Client =
  OAuth2Client
  { oAuth2ClientLinks = Nothing
  , oAuth2ClientClientId = Nothing
  , oAuth2ClientClientName = Nothing
  , oAuth2ClientClientUri = Nothing
  , oAuth2ClientLogoUri = Nothing
  }

-- ** OAuth2RefreshToken
-- | OAuth2RefreshToken
data OAuth2RefreshToken = OAuth2RefreshToken
  { oAuth2RefreshTokenEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , oAuth2RefreshTokenLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , oAuth2RefreshTokenClientId :: !(Maybe Text) -- ^ "clientId"
  , oAuth2RefreshTokenCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , oAuth2RefreshTokenCreatedBy :: !(Maybe OAuth2Actor) -- ^ "createdBy"
  , oAuth2RefreshTokenExpiresAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiresAt"
  , oAuth2RefreshTokenId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , oAuth2RefreshTokenIssuer :: !(Maybe Text) -- ^ "issuer"
  , oAuth2RefreshTokenLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , oAuth2RefreshTokenScopes :: !(Maybe [Text]) -- ^ "scopes"
  , oAuth2RefreshTokenStatus :: !(Maybe E'Status3) -- ^ "status"
  , oAuth2RefreshTokenUserId :: !(Maybe Text) -- ^ "userId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2RefreshToken
instance A.FromJSON OAuth2RefreshToken where
  parseJSON = A.withObject "OAuth2RefreshToken" $ \o ->
    OAuth2RefreshToken
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "clientId")
      <*> (o .:? "created")
      <*> (o .:? "createdBy")
      <*> (o .:? "expiresAt")
      <*> (o .:? "id")
      <*> (o .:? "issuer")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "scopes")
      <*> (o .:? "status")
      <*> (o .:? "userId")

-- | ToJSON OAuth2RefreshToken
instance A.ToJSON OAuth2RefreshToken where
  toJSON OAuth2RefreshToken {..} =
   _omitNulls
      [ "_embedded" .= oAuth2RefreshTokenEmbedded
      , "_links" .= oAuth2RefreshTokenLinks
      , "clientId" .= oAuth2RefreshTokenClientId
      , "created" .= oAuth2RefreshTokenCreated
      , "createdBy" .= oAuth2RefreshTokenCreatedBy
      , "expiresAt" .= oAuth2RefreshTokenExpiresAt
      , "id" .= oAuth2RefreshTokenId
      , "issuer" .= oAuth2RefreshTokenIssuer
      , "lastUpdated" .= oAuth2RefreshTokenLastUpdated
      , "scopes" .= oAuth2RefreshTokenScopes
      , "status" .= oAuth2RefreshTokenStatus
      , "userId" .= oAuth2RefreshTokenUserId
      ]


-- | Construct a value of type 'OAuth2RefreshToken' (by applying it's required fields, if any)
mkOAuth2RefreshToken
  :: OAuth2RefreshToken
mkOAuth2RefreshToken =
  OAuth2RefreshToken
  { oAuth2RefreshTokenEmbedded = Nothing
  , oAuth2RefreshTokenLinks = Nothing
  , oAuth2RefreshTokenClientId = Nothing
  , oAuth2RefreshTokenCreated = Nothing
  , oAuth2RefreshTokenCreatedBy = Nothing
  , oAuth2RefreshTokenExpiresAt = Nothing
  , oAuth2RefreshTokenId = Nothing
  , oAuth2RefreshTokenIssuer = Nothing
  , oAuth2RefreshTokenLastUpdated = Nothing
  , oAuth2RefreshTokenScopes = Nothing
  , oAuth2RefreshTokenStatus = Nothing
  , oAuth2RefreshTokenUserId = Nothing
  }

-- ** OAuth2Scope
-- | OAuth2Scope
data OAuth2Scope = OAuth2Scope
  { oAuth2ScopeConsent :: !(Maybe E'Consent) -- ^ "consent"
  , oAuth2ScopeDefault :: !(Maybe Bool) -- ^ "default"
  , oAuth2ScopeDescription :: !(Maybe Text) -- ^ "description"
  , oAuth2ScopeDisplayName :: !(Maybe Text) -- ^ "displayName"
  , oAuth2ScopeId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , oAuth2ScopeMetadataPublish :: !(Maybe E'MetadataPublish) -- ^ "metadataPublish"
  , oAuth2ScopeName :: !(Maybe Text) -- ^ "name"
  , oAuth2ScopeSystem :: !(Maybe Bool) -- ^ "system"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2Scope
instance A.FromJSON OAuth2Scope where
  parseJSON = A.withObject "OAuth2Scope" $ \o ->
    OAuth2Scope
      <$> (o .:? "consent")
      <*> (o .:? "default")
      <*> (o .:? "description")
      <*> (o .:? "displayName")
      <*> (o .:? "id")
      <*> (o .:? "metadataPublish")
      <*> (o .:? "name")
      <*> (o .:? "system")

-- | ToJSON OAuth2Scope
instance A.ToJSON OAuth2Scope where
  toJSON OAuth2Scope {..} =
   _omitNulls
      [ "consent" .= oAuth2ScopeConsent
      , "default" .= oAuth2ScopeDefault
      , "description" .= oAuth2ScopeDescription
      , "displayName" .= oAuth2ScopeDisplayName
      , "id" .= oAuth2ScopeId
      , "metadataPublish" .= oAuth2ScopeMetadataPublish
      , "name" .= oAuth2ScopeName
      , "system" .= oAuth2ScopeSystem
      ]


-- | Construct a value of type 'OAuth2Scope' (by applying it's required fields, if any)
mkOAuth2Scope
  :: OAuth2Scope
mkOAuth2Scope =
  OAuth2Scope
  { oAuth2ScopeConsent = Nothing
  , oAuth2ScopeDefault = Nothing
  , oAuth2ScopeDescription = Nothing
  , oAuth2ScopeDisplayName = Nothing
  , oAuth2ScopeId = Nothing
  , oAuth2ScopeMetadataPublish = Nothing
  , oAuth2ScopeName = Nothing
  , oAuth2ScopeSystem = Nothing
  }

-- ** OAuth2ScopeConsentGrant
-- | OAuth2ScopeConsentGrant
data OAuth2ScopeConsentGrant = OAuth2ScopeConsentGrant
  { oAuth2ScopeConsentGrantEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , oAuth2ScopeConsentGrantLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , oAuth2ScopeConsentGrantClientId :: !(Maybe Text) -- ^ "clientId"
  , oAuth2ScopeConsentGrantUserId :: !(Maybe Text) -- ^ "userId"
  , oAuth2ScopeConsentGrantCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , oAuth2ScopeConsentGrantCreatedBy :: !(Maybe OAuth2Actor) -- ^ "createdBy"
  , oAuth2ScopeConsentGrantId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , oAuth2ScopeConsentGrantIssuer :: !(Maybe Text) -- ^ "issuer"
  , oAuth2ScopeConsentGrantLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , oAuth2ScopeConsentGrantScopeId :: !(Maybe Text) -- ^ "scopeId"
  , oAuth2ScopeConsentGrantSource :: !(Maybe OAuth2ScopeConsentGrantSource) -- ^ "source"
  , oAuth2ScopeConsentGrantStatus :: !(Maybe OAuth2ScopeConsentGrantStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2ScopeConsentGrant
instance A.FromJSON OAuth2ScopeConsentGrant where
  parseJSON = A.withObject "OAuth2ScopeConsentGrant" $ \o ->
    OAuth2ScopeConsentGrant
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "clientId")
      <*> (o .:? "userId")
      <*> (o .:? "created")
      <*> (o .:? "createdBy")
      <*> (o .:? "id")
      <*> (o .:? "issuer")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "scopeId")
      <*> (o .:? "source")
      <*> (o .:? "status")

-- | ToJSON OAuth2ScopeConsentGrant
instance A.ToJSON OAuth2ScopeConsentGrant where
  toJSON OAuth2ScopeConsentGrant {..} =
   _omitNulls
      [ "_embedded" .= oAuth2ScopeConsentGrantEmbedded
      , "_links" .= oAuth2ScopeConsentGrantLinks
      , "clientId" .= oAuth2ScopeConsentGrantClientId
      , "userId" .= oAuth2ScopeConsentGrantUserId
      , "created" .= oAuth2ScopeConsentGrantCreated
      , "createdBy" .= oAuth2ScopeConsentGrantCreatedBy
      , "id" .= oAuth2ScopeConsentGrantId
      , "issuer" .= oAuth2ScopeConsentGrantIssuer
      , "lastUpdated" .= oAuth2ScopeConsentGrantLastUpdated
      , "scopeId" .= oAuth2ScopeConsentGrantScopeId
      , "source" .= oAuth2ScopeConsentGrantSource
      , "status" .= oAuth2ScopeConsentGrantStatus
      ]


-- | Construct a value of type 'OAuth2ScopeConsentGrant' (by applying it's required fields, if any)
mkOAuth2ScopeConsentGrant
  :: OAuth2ScopeConsentGrant
mkOAuth2ScopeConsentGrant =
  OAuth2ScopeConsentGrant
  { oAuth2ScopeConsentGrantEmbedded = Nothing
  , oAuth2ScopeConsentGrantLinks = Nothing
  , oAuth2ScopeConsentGrantClientId = Nothing
  , oAuth2ScopeConsentGrantUserId = Nothing
  , oAuth2ScopeConsentGrantCreated = Nothing
  , oAuth2ScopeConsentGrantCreatedBy = Nothing
  , oAuth2ScopeConsentGrantId = Nothing
  , oAuth2ScopeConsentGrantIssuer = Nothing
  , oAuth2ScopeConsentGrantLastUpdated = Nothing
  , oAuth2ScopeConsentGrantScopeId = Nothing
  , oAuth2ScopeConsentGrantSource = Nothing
  , oAuth2ScopeConsentGrantStatus = Nothing
  }

-- ** OAuth2ScopesMediationPolicyRuleCondition
-- | OAuth2ScopesMediationPolicyRuleCondition
data OAuth2ScopesMediationPolicyRuleCondition = OAuth2ScopesMediationPolicyRuleCondition
  { oAuth2ScopesMediationPolicyRuleConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2ScopesMediationPolicyRuleCondition
instance A.FromJSON OAuth2ScopesMediationPolicyRuleCondition where
  parseJSON = A.withObject "OAuth2ScopesMediationPolicyRuleCondition" $ \o ->
    OAuth2ScopesMediationPolicyRuleCondition
      <$> (o .:? "include")

-- | ToJSON OAuth2ScopesMediationPolicyRuleCondition
instance A.ToJSON OAuth2ScopesMediationPolicyRuleCondition where
  toJSON OAuth2ScopesMediationPolicyRuleCondition {..} =
   _omitNulls
      [ "include" .= oAuth2ScopesMediationPolicyRuleConditionInclude
      ]


-- | Construct a value of type 'OAuth2ScopesMediationPolicyRuleCondition' (by applying it's required fields, if any)
mkOAuth2ScopesMediationPolicyRuleCondition
  :: OAuth2ScopesMediationPolicyRuleCondition
mkOAuth2ScopesMediationPolicyRuleCondition =
  OAuth2ScopesMediationPolicyRuleCondition
  { oAuth2ScopesMediationPolicyRuleConditionInclude = Nothing
  }

-- ** OAuth2Token
-- | OAuth2Token
data OAuth2Token = OAuth2Token
  { oAuth2TokenEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , oAuth2TokenLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , oAuth2TokenClientId :: !(Maybe Text) -- ^ "clientId"
  , oAuth2TokenCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , oAuth2TokenExpiresAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiresAt"
  , oAuth2TokenId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , oAuth2TokenIssuer :: !(Maybe Text) -- ^ "issuer"
  , oAuth2TokenLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , oAuth2TokenScopes :: !(Maybe [Text]) -- ^ "scopes"
  , oAuth2TokenStatus :: !(Maybe E'Status3) -- ^ "status"
  , oAuth2TokenUserId :: !(Maybe Text) -- ^ "userId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuth2Token
instance A.FromJSON OAuth2Token where
  parseJSON = A.withObject "OAuth2Token" $ \o ->
    OAuth2Token
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "clientId")
      <*> (o .:? "created")
      <*> (o .:? "expiresAt")
      <*> (o .:? "id")
      <*> (o .:? "issuer")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "scopes")
      <*> (o .:? "status")
      <*> (o .:? "userId")

-- | ToJSON OAuth2Token
instance A.ToJSON OAuth2Token where
  toJSON OAuth2Token {..} =
   _omitNulls
      [ "_embedded" .= oAuth2TokenEmbedded
      , "_links" .= oAuth2TokenLinks
      , "clientId" .= oAuth2TokenClientId
      , "created" .= oAuth2TokenCreated
      , "expiresAt" .= oAuth2TokenExpiresAt
      , "id" .= oAuth2TokenId
      , "issuer" .= oAuth2TokenIssuer
      , "lastUpdated" .= oAuth2TokenLastUpdated
      , "scopes" .= oAuth2TokenScopes
      , "status" .= oAuth2TokenStatus
      , "userId" .= oAuth2TokenUserId
      ]


-- | Construct a value of type 'OAuth2Token' (by applying it's required fields, if any)
mkOAuth2Token
  :: OAuth2Token
mkOAuth2Token =
  OAuth2Token
  { oAuth2TokenEmbedded = Nothing
  , oAuth2TokenLinks = Nothing
  , oAuth2TokenClientId = Nothing
  , oAuth2TokenCreated = Nothing
  , oAuth2TokenExpiresAt = Nothing
  , oAuth2TokenId = Nothing
  , oAuth2TokenIssuer = Nothing
  , oAuth2TokenLastUpdated = Nothing
  , oAuth2TokenScopes = Nothing
  , oAuth2TokenStatus = Nothing
  , oAuth2TokenUserId = Nothing
  }

-- ** OAuthApplicationCredentials
-- | OAuthApplicationCredentials
data OAuthApplicationCredentials = OAuthApplicationCredentials
  { oAuthApplicationCredentialsOauthClient :: !(Maybe ApplicationCredentialsOAuthClient) -- ^ "oauthClient"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuthApplicationCredentials
instance A.FromJSON OAuthApplicationCredentials where
  parseJSON = A.withObject "OAuthApplicationCredentials" $ \o ->
    OAuthApplicationCredentials
      <$> (o .:? "oauthClient")

-- | ToJSON OAuthApplicationCredentials
instance A.ToJSON OAuthApplicationCredentials where
  toJSON OAuthApplicationCredentials {..} =
   _omitNulls
      [ "oauthClient" .= oAuthApplicationCredentialsOauthClient
      ]


-- | Construct a value of type 'OAuthApplicationCredentials' (by applying it's required fields, if any)
mkOAuthApplicationCredentials
  :: OAuthApplicationCredentials
mkOAuthApplicationCredentials =
  OAuthApplicationCredentials
  { oAuthApplicationCredentialsOauthClient = Nothing
  }

-- ** OktaSignOnPolicy
-- | OktaSignOnPolicy
data OktaSignOnPolicy = OktaSignOnPolicy
  { oktaSignOnPolicyConditions :: !(Maybe OktaSignOnPolicyConditions) -- ^ "conditions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicy
instance A.FromJSON OktaSignOnPolicy where
  parseJSON = A.withObject "OktaSignOnPolicy" $ \o ->
    OktaSignOnPolicy
      <$> (o .:? "conditions")

-- | ToJSON OktaSignOnPolicy
instance A.ToJSON OktaSignOnPolicy where
  toJSON OktaSignOnPolicy {..} =
   _omitNulls
      [ "conditions" .= oktaSignOnPolicyConditions
      ]


-- | Construct a value of type 'OktaSignOnPolicy' (by applying it's required fields, if any)
mkOktaSignOnPolicy
  :: OktaSignOnPolicy
mkOktaSignOnPolicy =
  OktaSignOnPolicy
  { oktaSignOnPolicyConditions = Nothing
  }

-- ** OktaSignOnPolicyConditions
-- | OktaSignOnPolicyConditions
data OktaSignOnPolicyConditions = OktaSignOnPolicyConditions
  { oktaSignOnPolicyConditionsPeople :: !(Maybe PolicyPeopleCondition) -- ^ "people"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicyConditions
instance A.FromJSON OktaSignOnPolicyConditions where
  parseJSON = A.withObject "OktaSignOnPolicyConditions" $ \o ->
    OktaSignOnPolicyConditions
      <$> (o .:? "people")

-- | ToJSON OktaSignOnPolicyConditions
instance A.ToJSON OktaSignOnPolicyConditions where
  toJSON OktaSignOnPolicyConditions {..} =
   _omitNulls
      [ "people" .= oktaSignOnPolicyConditionsPeople
      ]


-- | Construct a value of type 'OktaSignOnPolicyConditions' (by applying it's required fields, if any)
mkOktaSignOnPolicyConditions
  :: OktaSignOnPolicyConditions
mkOktaSignOnPolicyConditions =
  OktaSignOnPolicyConditions
  { oktaSignOnPolicyConditionsPeople = Nothing
  }

-- ** OktaSignOnPolicyRule
-- | OktaSignOnPolicyRule
data OktaSignOnPolicyRule = OktaSignOnPolicyRule
  { oktaSignOnPolicyRuleActions :: !(Maybe OktaSignOnPolicyRuleActions) -- ^ "actions"
  , oktaSignOnPolicyRuleConditions :: !(Maybe OktaSignOnPolicyRuleConditions) -- ^ "conditions"
  , oktaSignOnPolicyRuleName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicyRule
instance A.FromJSON OktaSignOnPolicyRule where
  parseJSON = A.withObject "OktaSignOnPolicyRule" $ \o ->
    OktaSignOnPolicyRule
      <$> (o .:? "actions")
      <*> (o .:? "conditions")
      <*> (o .:? "name")

-- | ToJSON OktaSignOnPolicyRule
instance A.ToJSON OktaSignOnPolicyRule where
  toJSON OktaSignOnPolicyRule {..} =
   _omitNulls
      [ "actions" .= oktaSignOnPolicyRuleActions
      , "conditions" .= oktaSignOnPolicyRuleConditions
      , "name" .= oktaSignOnPolicyRuleName
      ]


-- | Construct a value of type 'OktaSignOnPolicyRule' (by applying it's required fields, if any)
mkOktaSignOnPolicyRule
  :: OktaSignOnPolicyRule
mkOktaSignOnPolicyRule =
  OktaSignOnPolicyRule
  { oktaSignOnPolicyRuleActions = Nothing
  , oktaSignOnPolicyRuleConditions = Nothing
  , oktaSignOnPolicyRuleName = Nothing
  }

-- ** OktaSignOnPolicyRuleActions
-- | OktaSignOnPolicyRuleActions
data OktaSignOnPolicyRuleActions = OktaSignOnPolicyRuleActions
  { oktaSignOnPolicyRuleActionsSignon :: !(Maybe OktaSignOnPolicyRuleSignonActions) -- ^ "signon"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicyRuleActions
instance A.FromJSON OktaSignOnPolicyRuleActions where
  parseJSON = A.withObject "OktaSignOnPolicyRuleActions" $ \o ->
    OktaSignOnPolicyRuleActions
      <$> (o .:? "signon")

-- | ToJSON OktaSignOnPolicyRuleActions
instance A.ToJSON OktaSignOnPolicyRuleActions where
  toJSON OktaSignOnPolicyRuleActions {..} =
   _omitNulls
      [ "signon" .= oktaSignOnPolicyRuleActionsSignon
      ]


-- | Construct a value of type 'OktaSignOnPolicyRuleActions' (by applying it's required fields, if any)
mkOktaSignOnPolicyRuleActions
  :: OktaSignOnPolicyRuleActions
mkOktaSignOnPolicyRuleActions =
  OktaSignOnPolicyRuleActions
  { oktaSignOnPolicyRuleActionsSignon = Nothing
  }

-- ** OktaSignOnPolicyRuleConditions
-- | OktaSignOnPolicyRuleConditions
data OktaSignOnPolicyRuleConditions = OktaSignOnPolicyRuleConditions
  { oktaSignOnPolicyRuleConditionsAuthContext :: !(Maybe PolicyRuleAuthContextCondition) -- ^ "authContext"
  , oktaSignOnPolicyRuleConditionsNetwork :: !(Maybe PolicyNetworkCondition) -- ^ "network"
  , oktaSignOnPolicyRuleConditionsPeople :: !(Maybe PolicyPeopleCondition) -- ^ "people"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicyRuleConditions
instance A.FromJSON OktaSignOnPolicyRuleConditions where
  parseJSON = A.withObject "OktaSignOnPolicyRuleConditions" $ \o ->
    OktaSignOnPolicyRuleConditions
      <$> (o .:? "authContext")
      <*> (o .:? "network")
      <*> (o .:? "people")

-- | ToJSON OktaSignOnPolicyRuleConditions
instance A.ToJSON OktaSignOnPolicyRuleConditions where
  toJSON OktaSignOnPolicyRuleConditions {..} =
   _omitNulls
      [ "authContext" .= oktaSignOnPolicyRuleConditionsAuthContext
      , "network" .= oktaSignOnPolicyRuleConditionsNetwork
      , "people" .= oktaSignOnPolicyRuleConditionsPeople
      ]


-- | Construct a value of type 'OktaSignOnPolicyRuleConditions' (by applying it's required fields, if any)
mkOktaSignOnPolicyRuleConditions
  :: OktaSignOnPolicyRuleConditions
mkOktaSignOnPolicyRuleConditions =
  OktaSignOnPolicyRuleConditions
  { oktaSignOnPolicyRuleConditionsAuthContext = Nothing
  , oktaSignOnPolicyRuleConditionsNetwork = Nothing
  , oktaSignOnPolicyRuleConditionsPeople = Nothing
  }

-- ** OktaSignOnPolicyRuleSignonActions
-- | OktaSignOnPolicyRuleSignonActions
data OktaSignOnPolicyRuleSignonActions = OktaSignOnPolicyRuleSignonActions
  { oktaSignOnPolicyRuleSignonActionsAccess :: !(Maybe E'Access) -- ^ "access"
  , oktaSignOnPolicyRuleSignonActionsFactorLifetime :: !(Maybe Int) -- ^ "factorLifetime"
  , oktaSignOnPolicyRuleSignonActionsFactorPromptMode :: !(Maybe E'FactorPromptMode) -- ^ "factorPromptMode"
  , oktaSignOnPolicyRuleSignonActionsRememberDeviceByDefault :: !(Maybe Bool) -- ^ "rememberDeviceByDefault"
  , oktaSignOnPolicyRuleSignonActionsRequireFactor :: !(Maybe Bool) -- ^ "requireFactor"
  , oktaSignOnPolicyRuleSignonActionsSession :: !(Maybe OktaSignOnPolicyRuleSignonSessionActions) -- ^ "session"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicyRuleSignonActions
instance A.FromJSON OktaSignOnPolicyRuleSignonActions where
  parseJSON = A.withObject "OktaSignOnPolicyRuleSignonActions" $ \o ->
    OktaSignOnPolicyRuleSignonActions
      <$> (o .:? "access")
      <*> (o .:? "factorLifetime")
      <*> (o .:? "factorPromptMode")
      <*> (o .:? "rememberDeviceByDefault")
      <*> (o .:? "requireFactor")
      <*> (o .:? "session")

-- | ToJSON OktaSignOnPolicyRuleSignonActions
instance A.ToJSON OktaSignOnPolicyRuleSignonActions where
  toJSON OktaSignOnPolicyRuleSignonActions {..} =
   _omitNulls
      [ "access" .= oktaSignOnPolicyRuleSignonActionsAccess
      , "factorLifetime" .= oktaSignOnPolicyRuleSignonActionsFactorLifetime
      , "factorPromptMode" .= oktaSignOnPolicyRuleSignonActionsFactorPromptMode
      , "rememberDeviceByDefault" .= oktaSignOnPolicyRuleSignonActionsRememberDeviceByDefault
      , "requireFactor" .= oktaSignOnPolicyRuleSignonActionsRequireFactor
      , "session" .= oktaSignOnPolicyRuleSignonActionsSession
      ]


-- | Construct a value of type 'OktaSignOnPolicyRuleSignonActions' (by applying it's required fields, if any)
mkOktaSignOnPolicyRuleSignonActions
  :: OktaSignOnPolicyRuleSignonActions
mkOktaSignOnPolicyRuleSignonActions =
  OktaSignOnPolicyRuleSignonActions
  { oktaSignOnPolicyRuleSignonActionsAccess = Nothing
  , oktaSignOnPolicyRuleSignonActionsFactorLifetime = Nothing
  , oktaSignOnPolicyRuleSignonActionsFactorPromptMode = Nothing
  , oktaSignOnPolicyRuleSignonActionsRememberDeviceByDefault = Nothing
  , oktaSignOnPolicyRuleSignonActionsRequireFactor = Nothing
  , oktaSignOnPolicyRuleSignonActionsSession = Nothing
  }

-- ** OktaSignOnPolicyRuleSignonSessionActions
-- | OktaSignOnPolicyRuleSignonSessionActions
data OktaSignOnPolicyRuleSignonSessionActions = OktaSignOnPolicyRuleSignonSessionActions
  { oktaSignOnPolicyRuleSignonSessionActionsMaxSessionIdleMinutes :: !(Maybe Int) -- ^ "maxSessionIdleMinutes"
  , oktaSignOnPolicyRuleSignonSessionActionsMaxSessionLifetimeMinutes :: !(Maybe Int) -- ^ "maxSessionLifetimeMinutes"
  , oktaSignOnPolicyRuleSignonSessionActionsUsePersistentCookie :: !(Maybe Bool) -- ^ "usePersistentCookie"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OktaSignOnPolicyRuleSignonSessionActions
instance A.FromJSON OktaSignOnPolicyRuleSignonSessionActions where
  parseJSON = A.withObject "OktaSignOnPolicyRuleSignonSessionActions" $ \o ->
    OktaSignOnPolicyRuleSignonSessionActions
      <$> (o .:? "maxSessionIdleMinutes")
      <*> (o .:? "maxSessionLifetimeMinutes")
      <*> (o .:? "usePersistentCookie")

-- | ToJSON OktaSignOnPolicyRuleSignonSessionActions
instance A.ToJSON OktaSignOnPolicyRuleSignonSessionActions where
  toJSON OktaSignOnPolicyRuleSignonSessionActions {..} =
   _omitNulls
      [ "maxSessionIdleMinutes" .= oktaSignOnPolicyRuleSignonSessionActionsMaxSessionIdleMinutes
      , "maxSessionLifetimeMinutes" .= oktaSignOnPolicyRuleSignonSessionActionsMaxSessionLifetimeMinutes
      , "usePersistentCookie" .= oktaSignOnPolicyRuleSignonSessionActionsUsePersistentCookie
      ]


-- | Construct a value of type 'OktaSignOnPolicyRuleSignonSessionActions' (by applying it's required fields, if any)
mkOktaSignOnPolicyRuleSignonSessionActions
  :: OktaSignOnPolicyRuleSignonSessionActions
mkOktaSignOnPolicyRuleSignonSessionActions =
  OktaSignOnPolicyRuleSignonSessionActions
  { oktaSignOnPolicyRuleSignonSessionActionsMaxSessionIdleMinutes = Nothing
  , oktaSignOnPolicyRuleSignonSessionActionsMaxSessionLifetimeMinutes = Nothing
  , oktaSignOnPolicyRuleSignonSessionActionsUsePersistentCookie = Nothing
  }

-- ** OpenIdConnectApplication
-- | OpenIdConnectApplication
data OpenIdConnectApplication = OpenIdConnectApplication
  { openIdConnectApplicationCredentials :: !(Maybe OAuthApplicationCredentials) -- ^ "credentials"
  , openIdConnectApplicationName :: !(Maybe A.Value) -- ^ "name"
  , openIdConnectApplicationSettings :: !(Maybe OpenIdConnectApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplication
instance A.FromJSON OpenIdConnectApplication where
  parseJSON = A.withObject "OpenIdConnectApplication" $ \o ->
    OpenIdConnectApplication
      <$> (o .:? "credentials")
      <*> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON OpenIdConnectApplication
instance A.ToJSON OpenIdConnectApplication where
  toJSON OpenIdConnectApplication {..} =
   _omitNulls
      [ "credentials" .= openIdConnectApplicationCredentials
      , "name" .= openIdConnectApplicationName
      , "settings" .= openIdConnectApplicationSettings
      ]


-- | Construct a value of type 'OpenIdConnectApplication' (by applying it's required fields, if any)
mkOpenIdConnectApplication
  :: OpenIdConnectApplication
mkOpenIdConnectApplication =
  OpenIdConnectApplication
  { openIdConnectApplicationCredentials = Nothing
  , openIdConnectApplicationName = Nothing
  , openIdConnectApplicationSettings = Nothing
  }

-- ** OpenIdConnectApplicationIdpInitiatedLogin
-- | OpenIdConnectApplicationIdpInitiatedLogin
data OpenIdConnectApplicationIdpInitiatedLogin = OpenIdConnectApplicationIdpInitiatedLogin
  { openIdConnectApplicationIdpInitiatedLoginMode :: !(Maybe Text) -- ^ "mode"
  , openIdConnectApplicationIdpInitiatedLoginDefaultScope :: !(Maybe [Text]) -- ^ "default_scope"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationIdpInitiatedLogin
instance A.FromJSON OpenIdConnectApplicationIdpInitiatedLogin where
  parseJSON = A.withObject "OpenIdConnectApplicationIdpInitiatedLogin" $ \o ->
    OpenIdConnectApplicationIdpInitiatedLogin
      <$> (o .:? "mode")
      <*> (o .:? "default_scope")

-- | ToJSON OpenIdConnectApplicationIdpInitiatedLogin
instance A.ToJSON OpenIdConnectApplicationIdpInitiatedLogin where
  toJSON OpenIdConnectApplicationIdpInitiatedLogin {..} =
   _omitNulls
      [ "mode" .= openIdConnectApplicationIdpInitiatedLoginMode
      , "default_scope" .= openIdConnectApplicationIdpInitiatedLoginDefaultScope
      ]


-- | Construct a value of type 'OpenIdConnectApplicationIdpInitiatedLogin' (by applying it's required fields, if any)
mkOpenIdConnectApplicationIdpInitiatedLogin
  :: OpenIdConnectApplicationIdpInitiatedLogin
mkOpenIdConnectApplicationIdpInitiatedLogin =
  OpenIdConnectApplicationIdpInitiatedLogin
  { openIdConnectApplicationIdpInitiatedLoginMode = Nothing
  , openIdConnectApplicationIdpInitiatedLoginDefaultScope = Nothing
  }

-- ** OpenIdConnectApplicationSettings
-- | OpenIdConnectApplicationSettings
data OpenIdConnectApplicationSettings = OpenIdConnectApplicationSettings
  { openIdConnectApplicationSettingsOauthClient :: !(Maybe OpenIdConnectApplicationSettingsClient) -- ^ "oauthClient"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationSettings
instance A.FromJSON OpenIdConnectApplicationSettings where
  parseJSON = A.withObject "OpenIdConnectApplicationSettings" $ \o ->
    OpenIdConnectApplicationSettings
      <$> (o .:? "oauthClient")

-- | ToJSON OpenIdConnectApplicationSettings
instance A.ToJSON OpenIdConnectApplicationSettings where
  toJSON OpenIdConnectApplicationSettings {..} =
   _omitNulls
      [ "oauthClient" .= openIdConnectApplicationSettingsOauthClient
      ]


-- | Construct a value of type 'OpenIdConnectApplicationSettings' (by applying it's required fields, if any)
mkOpenIdConnectApplicationSettings
  :: OpenIdConnectApplicationSettings
mkOpenIdConnectApplicationSettings =
  OpenIdConnectApplicationSettings
  { openIdConnectApplicationSettingsOauthClient = Nothing
  }

-- ** OpenIdConnectApplicationSettingsClient
-- | OpenIdConnectApplicationSettingsClient
data OpenIdConnectApplicationSettingsClient = OpenIdConnectApplicationSettingsClient
  { openIdConnectApplicationSettingsClientApplicationType :: !(Maybe OpenIdConnectApplicationType) -- ^ "application_type"
  , openIdConnectApplicationSettingsClientClientUri :: !(Maybe Text) -- ^ "client_uri"
  , openIdConnectApplicationSettingsClientConsentMethod :: !(Maybe OpenIdConnectApplicationConsentMethod) -- ^ "consent_method"
  , openIdConnectApplicationSettingsClientGrantTypes :: !(Maybe [OAuthGrantType]) -- ^ "grant_types"
  , openIdConnectApplicationSettingsClientInitiateLoginUri :: !(Maybe Text) -- ^ "initiate_login_uri"
  , openIdConnectApplicationSettingsClientIssuerMode :: !(Maybe OpenIdConnectApplicationIssuerMode) -- ^ "issuer_mode"
  , openIdConnectApplicationSettingsClientIdpInitiatedLogin :: !(Maybe OpenIdConnectApplicationIdpInitiatedLogin) -- ^ "idp_initiated_login"
  , openIdConnectApplicationSettingsClientLogoUri :: !(Maybe Text) -- ^ "logo_uri"
  , openIdConnectApplicationSettingsClientPolicyUri :: !(Maybe Text) -- ^ "policy_uri"
  , openIdConnectApplicationSettingsClientPostLogoutRedirectUris :: !(Maybe [Text]) -- ^ "post_logout_redirect_uris"
  , openIdConnectApplicationSettingsClientRedirectUris :: !(Maybe [Text]) -- ^ "redirect_uris"
  , openIdConnectApplicationSettingsClientWildcardRedirect :: !(Maybe Text) -- ^ "wildcard_redirect"
  , openIdConnectApplicationSettingsClientResponseTypes :: !(Maybe [OAuthResponseType]) -- ^ "response_types"
  , openIdConnectApplicationSettingsClientRefreshToken :: !(Maybe OpenIdConnectApplicationSettingsRefreshToken) -- ^ "refresh_token"
  , openIdConnectApplicationSettingsClientTosUri :: !(Maybe Text) -- ^ "tos_uri"
  , openIdConnectApplicationSettingsClientJwks :: !(Maybe OpenIdConnectApplicationSettingsClientKeys) -- ^ "jwks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationSettingsClient
instance A.FromJSON OpenIdConnectApplicationSettingsClient where
  parseJSON = A.withObject "OpenIdConnectApplicationSettingsClient" $ \o ->
    OpenIdConnectApplicationSettingsClient
      <$> (o .:? "application_type")
      <*> (o .:? "client_uri")
      <*> (o .:? "consent_method")
      <*> (o .:? "grant_types")
      <*> (o .:? "initiate_login_uri")
      <*> (o .:? "issuer_mode")
      <*> (o .:? "idp_initiated_login")
      <*> (o .:? "logo_uri")
      <*> (o .:? "policy_uri")
      <*> (o .:? "post_logout_redirect_uris")
      <*> (o .:? "redirect_uris")
      <*> (o .:? "wildcard_redirect")
      <*> (o .:? "response_types")
      <*> (o .:? "refresh_token")
      <*> (o .:? "tos_uri")
      <*> (o .:? "jwks")

-- | ToJSON OpenIdConnectApplicationSettingsClient
instance A.ToJSON OpenIdConnectApplicationSettingsClient where
  toJSON OpenIdConnectApplicationSettingsClient {..} =
   _omitNulls
      [ "application_type" .= openIdConnectApplicationSettingsClientApplicationType
      , "client_uri" .= openIdConnectApplicationSettingsClientClientUri
      , "consent_method" .= openIdConnectApplicationSettingsClientConsentMethod
      , "grant_types" .= openIdConnectApplicationSettingsClientGrantTypes
      , "initiate_login_uri" .= openIdConnectApplicationSettingsClientInitiateLoginUri
      , "issuer_mode" .= openIdConnectApplicationSettingsClientIssuerMode
      , "idp_initiated_login" .= openIdConnectApplicationSettingsClientIdpInitiatedLogin
      , "logo_uri" .= openIdConnectApplicationSettingsClientLogoUri
      , "policy_uri" .= openIdConnectApplicationSettingsClientPolicyUri
      , "post_logout_redirect_uris" .= openIdConnectApplicationSettingsClientPostLogoutRedirectUris
      , "redirect_uris" .= openIdConnectApplicationSettingsClientRedirectUris
      , "wildcard_redirect" .= openIdConnectApplicationSettingsClientWildcardRedirect
      , "response_types" .= openIdConnectApplicationSettingsClientResponseTypes
      , "refresh_token" .= openIdConnectApplicationSettingsClientRefreshToken
      , "tos_uri" .= openIdConnectApplicationSettingsClientTosUri
      , "jwks" .= openIdConnectApplicationSettingsClientJwks
      ]


-- | Construct a value of type 'OpenIdConnectApplicationSettingsClient' (by applying it's required fields, if any)
mkOpenIdConnectApplicationSettingsClient
  :: OpenIdConnectApplicationSettingsClient
mkOpenIdConnectApplicationSettingsClient =
  OpenIdConnectApplicationSettingsClient
  { openIdConnectApplicationSettingsClientApplicationType = Nothing
  , openIdConnectApplicationSettingsClientClientUri = Nothing
  , openIdConnectApplicationSettingsClientConsentMethod = Nothing
  , openIdConnectApplicationSettingsClientGrantTypes = Nothing
  , openIdConnectApplicationSettingsClientInitiateLoginUri = Nothing
  , openIdConnectApplicationSettingsClientIssuerMode = Nothing
  , openIdConnectApplicationSettingsClientIdpInitiatedLogin = Nothing
  , openIdConnectApplicationSettingsClientLogoUri = Nothing
  , openIdConnectApplicationSettingsClientPolicyUri = Nothing
  , openIdConnectApplicationSettingsClientPostLogoutRedirectUris = Nothing
  , openIdConnectApplicationSettingsClientRedirectUris = Nothing
  , openIdConnectApplicationSettingsClientWildcardRedirect = Nothing
  , openIdConnectApplicationSettingsClientResponseTypes = Nothing
  , openIdConnectApplicationSettingsClientRefreshToken = Nothing
  , openIdConnectApplicationSettingsClientTosUri = Nothing
  , openIdConnectApplicationSettingsClientJwks = Nothing
  }

-- ** OpenIdConnectApplicationSettingsClientKeys
-- | OpenIdConnectApplicationSettingsClientKeys
data OpenIdConnectApplicationSettingsClientKeys = OpenIdConnectApplicationSettingsClientKeys
  { openIdConnectApplicationSettingsClientKeysKeys :: !(Maybe [JsonWebKey]) -- ^ "keys"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationSettingsClientKeys
instance A.FromJSON OpenIdConnectApplicationSettingsClientKeys where
  parseJSON = A.withObject "OpenIdConnectApplicationSettingsClientKeys" $ \o ->
    OpenIdConnectApplicationSettingsClientKeys
      <$> (o .:? "keys")

-- | ToJSON OpenIdConnectApplicationSettingsClientKeys
instance A.ToJSON OpenIdConnectApplicationSettingsClientKeys where
  toJSON OpenIdConnectApplicationSettingsClientKeys {..} =
   _omitNulls
      [ "keys" .= openIdConnectApplicationSettingsClientKeysKeys
      ]


-- | Construct a value of type 'OpenIdConnectApplicationSettingsClientKeys' (by applying it's required fields, if any)
mkOpenIdConnectApplicationSettingsClientKeys
  :: OpenIdConnectApplicationSettingsClientKeys
mkOpenIdConnectApplicationSettingsClientKeys =
  OpenIdConnectApplicationSettingsClientKeys
  { openIdConnectApplicationSettingsClientKeysKeys = Nothing
  }

-- ** OpenIdConnectApplicationSettingsRefreshToken
-- | OpenIdConnectApplicationSettingsRefreshToken
data OpenIdConnectApplicationSettingsRefreshToken = OpenIdConnectApplicationSettingsRefreshToken
  { openIdConnectApplicationSettingsRefreshTokenLeeway :: !(Maybe Int) -- ^ "leeway"
  , openIdConnectApplicationSettingsRefreshTokenRotationType :: !(Maybe OpenIdConnectRefreshTokenRotationType) -- ^ "rotation_type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationSettingsRefreshToken
instance A.FromJSON OpenIdConnectApplicationSettingsRefreshToken where
  parseJSON = A.withObject "OpenIdConnectApplicationSettingsRefreshToken" $ \o ->
    OpenIdConnectApplicationSettingsRefreshToken
      <$> (o .:? "leeway")
      <*> (o .:? "rotation_type")

-- | ToJSON OpenIdConnectApplicationSettingsRefreshToken
instance A.ToJSON OpenIdConnectApplicationSettingsRefreshToken where
  toJSON OpenIdConnectApplicationSettingsRefreshToken {..} =
   _omitNulls
      [ "leeway" .= openIdConnectApplicationSettingsRefreshTokenLeeway
      , "rotation_type" .= openIdConnectApplicationSettingsRefreshTokenRotationType
      ]


-- | Construct a value of type 'OpenIdConnectApplicationSettingsRefreshToken' (by applying it's required fields, if any)
mkOpenIdConnectApplicationSettingsRefreshToken
  :: OpenIdConnectApplicationSettingsRefreshToken
mkOpenIdConnectApplicationSettingsRefreshToken =
  OpenIdConnectApplicationSettingsRefreshToken
  { openIdConnectApplicationSettingsRefreshTokenLeeway = Nothing
  , openIdConnectApplicationSettingsRefreshTokenRotationType = Nothing
  }

-- ** Org2OrgApplication
-- | Org2OrgApplication
data Org2OrgApplication = Org2OrgApplication
  { org2OrgApplicationName :: !(Maybe A.Value) -- ^ "name"
  , org2OrgApplicationSettings :: !(Maybe Org2OrgApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Org2OrgApplication
instance A.FromJSON Org2OrgApplication where
  parseJSON = A.withObject "Org2OrgApplication" $ \o ->
    Org2OrgApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON Org2OrgApplication
instance A.ToJSON Org2OrgApplication where
  toJSON Org2OrgApplication {..} =
   _omitNulls
      [ "name" .= org2OrgApplicationName
      , "settings" .= org2OrgApplicationSettings
      ]


-- | Construct a value of type 'Org2OrgApplication' (by applying it's required fields, if any)
mkOrg2OrgApplication
  :: Org2OrgApplication
mkOrg2OrgApplication =
  Org2OrgApplication
  { org2OrgApplicationName = Nothing
  , org2OrgApplicationSettings = Nothing
  }

-- ** Org2OrgApplicationSettings
-- | Org2OrgApplicationSettings
data Org2OrgApplicationSettings = Org2OrgApplicationSettings
  { org2OrgApplicationSettingsApp :: !(Maybe Org2OrgApplicationSettingsApp) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Org2OrgApplicationSettings
instance A.FromJSON Org2OrgApplicationSettings where
  parseJSON = A.withObject "Org2OrgApplicationSettings" $ \o ->
    Org2OrgApplicationSettings
      <$> (o .:? "app")

-- | ToJSON Org2OrgApplicationSettings
instance A.ToJSON Org2OrgApplicationSettings where
  toJSON Org2OrgApplicationSettings {..} =
   _omitNulls
      [ "app" .= org2OrgApplicationSettingsApp
      ]


-- | Construct a value of type 'Org2OrgApplicationSettings' (by applying it's required fields, if any)
mkOrg2OrgApplicationSettings
  :: Org2OrgApplicationSettings
mkOrg2OrgApplicationSettings =
  Org2OrgApplicationSettings
  { org2OrgApplicationSettingsApp = Nothing
  }

-- ** Org2OrgApplicationSettingsApp
-- | Org2OrgApplicationSettingsApp
data Org2OrgApplicationSettingsApp = Org2OrgApplicationSettingsApp
  { org2OrgApplicationSettingsAppAcsUrl :: !(Maybe Text) -- ^ "acsUrl"
  , org2OrgApplicationSettingsAppAudRestriction :: !(Maybe Text) -- ^ "audRestriction"
  , org2OrgApplicationSettingsAppBaseUrl :: !(Maybe Text) -- ^ "baseUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Org2OrgApplicationSettingsApp
instance A.FromJSON Org2OrgApplicationSettingsApp where
  parseJSON = A.withObject "Org2OrgApplicationSettingsApp" $ \o ->
    Org2OrgApplicationSettingsApp
      <$> (o .:? "acsUrl")
      <*> (o .:? "audRestriction")
      <*> (o .:? "baseUrl")

-- | ToJSON Org2OrgApplicationSettingsApp
instance A.ToJSON Org2OrgApplicationSettingsApp where
  toJSON Org2OrgApplicationSettingsApp {..} =
   _omitNulls
      [ "acsUrl" .= org2OrgApplicationSettingsAppAcsUrl
      , "audRestriction" .= org2OrgApplicationSettingsAppAudRestriction
      , "baseUrl" .= org2OrgApplicationSettingsAppBaseUrl
      ]


-- | Construct a value of type 'Org2OrgApplicationSettingsApp' (by applying it's required fields, if any)
mkOrg2OrgApplicationSettingsApp
  :: Org2OrgApplicationSettingsApp
mkOrg2OrgApplicationSettingsApp =
  Org2OrgApplicationSettingsApp
  { org2OrgApplicationSettingsAppAcsUrl = Nothing
  , org2OrgApplicationSettingsAppAudRestriction = Nothing
  , org2OrgApplicationSettingsAppBaseUrl = Nothing
  }

-- ** OrgContactTypeObj
-- | OrgContactTypeObj
data OrgContactTypeObj = OrgContactTypeObj
  { orgContactTypeObjLinks :: !(Maybe A.Value) -- ^ "_links"
  , orgContactTypeObjContactType :: !(Maybe OrgContactType) -- ^ "contactType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrgContactTypeObj
instance A.FromJSON OrgContactTypeObj where
  parseJSON = A.withObject "OrgContactTypeObj" $ \o ->
    OrgContactTypeObj
      <$> (o .:? "_links")
      <*> (o .:? "contactType")

-- | ToJSON OrgContactTypeObj
instance A.ToJSON OrgContactTypeObj where
  toJSON OrgContactTypeObj {..} =
   _omitNulls
      [ "_links" .= orgContactTypeObjLinks
      , "contactType" .= orgContactTypeObjContactType
      ]


-- | Construct a value of type 'OrgContactTypeObj' (by applying it's required fields, if any)
mkOrgContactTypeObj
  :: OrgContactTypeObj
mkOrgContactTypeObj =
  OrgContactTypeObj
  { orgContactTypeObjLinks = Nothing
  , orgContactTypeObjContactType = Nothing
  }

-- ** OrgContactUser
-- | OrgContactUser
data OrgContactUser = OrgContactUser
  { orgContactUserLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , orgContactUserUserId :: !(Maybe Text) -- ^ "userId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrgContactUser
instance A.FromJSON OrgContactUser where
  parseJSON = A.withObject "OrgContactUser" $ \o ->
    OrgContactUser
      <$> (o .:? "_links")
      <*> (o .:? "userId")

-- | ToJSON OrgContactUser
instance A.ToJSON OrgContactUser where
  toJSON OrgContactUser {..} =
   _omitNulls
      [ "_links" .= orgContactUserLinks
      , "userId" .= orgContactUserUserId
      ]


-- | Construct a value of type 'OrgContactUser' (by applying it's required fields, if any)
mkOrgContactUser
  :: OrgContactUser
mkOrgContactUser =
  OrgContactUser
  { orgContactUserLinks = Nothing
  , orgContactUserUserId = Nothing
  }

-- ** OrgOktaCommunicationSetting
-- | OrgOktaCommunicationSetting
data OrgOktaCommunicationSetting = OrgOktaCommunicationSetting
  { orgOktaCommunicationSettingLinks :: !(Maybe A.Value) -- ^ "_links"
  , orgOktaCommunicationSettingOptOutEmailUsers :: !(Maybe Bool) -- ^ /ReadOnly/ "optOutEmailUsers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrgOktaCommunicationSetting
instance A.FromJSON OrgOktaCommunicationSetting where
  parseJSON = A.withObject "OrgOktaCommunicationSetting" $ \o ->
    OrgOktaCommunicationSetting
      <$> (o .:? "_links")
      <*> (o .:? "optOutEmailUsers")

-- | ToJSON OrgOktaCommunicationSetting
instance A.ToJSON OrgOktaCommunicationSetting where
  toJSON OrgOktaCommunicationSetting {..} =
   _omitNulls
      [ "_links" .= orgOktaCommunicationSettingLinks
      , "optOutEmailUsers" .= orgOktaCommunicationSettingOptOutEmailUsers
      ]


-- | Construct a value of type 'OrgOktaCommunicationSetting' (by applying it's required fields, if any)
mkOrgOktaCommunicationSetting
  :: OrgOktaCommunicationSetting
mkOrgOktaCommunicationSetting =
  OrgOktaCommunicationSetting
  { orgOktaCommunicationSettingLinks = Nothing
  , orgOktaCommunicationSettingOptOutEmailUsers = Nothing
  }

-- ** OrgOktaSupportSettingsObj
-- | OrgOktaSupportSettingsObj
data OrgOktaSupportSettingsObj = OrgOktaSupportSettingsObj
  { orgOktaSupportSettingsObjLinks :: !(Maybe A.Value) -- ^ "_links"
  , orgOktaSupportSettingsObjExpiration :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiration"
  , orgOktaSupportSettingsObjSupport :: !(Maybe OrgOktaSupportSetting) -- ^ "support"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrgOktaSupportSettingsObj
instance A.FromJSON OrgOktaSupportSettingsObj where
  parseJSON = A.withObject "OrgOktaSupportSettingsObj" $ \o ->
    OrgOktaSupportSettingsObj
      <$> (o .:? "_links")
      <*> (o .:? "expiration")
      <*> (o .:? "support")

-- | ToJSON OrgOktaSupportSettingsObj
instance A.ToJSON OrgOktaSupportSettingsObj where
  toJSON OrgOktaSupportSettingsObj {..} =
   _omitNulls
      [ "_links" .= orgOktaSupportSettingsObjLinks
      , "expiration" .= orgOktaSupportSettingsObjExpiration
      , "support" .= orgOktaSupportSettingsObjSupport
      ]


-- | Construct a value of type 'OrgOktaSupportSettingsObj' (by applying it's required fields, if any)
mkOrgOktaSupportSettingsObj
  :: OrgOktaSupportSettingsObj
mkOrgOktaSupportSettingsObj =
  OrgOktaSupportSettingsObj
  { orgOktaSupportSettingsObjLinks = Nothing
  , orgOktaSupportSettingsObjExpiration = Nothing
  , orgOktaSupportSettingsObjSupport = Nothing
  }

-- ** OrgPreferences
-- | OrgPreferences
data OrgPreferences = OrgPreferences
  { orgPreferencesLinks :: !(Maybe A.Value) -- ^ "_links"
  , orgPreferencesShowEndUserFooter :: !(Maybe Bool) -- ^ /ReadOnly/ "showEndUserFooter"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrgPreferences
instance A.FromJSON OrgPreferences where
  parseJSON = A.withObject "OrgPreferences" $ \o ->
    OrgPreferences
      <$> (o .:? "_links")
      <*> (o .:? "showEndUserFooter")

-- | ToJSON OrgPreferences
instance A.ToJSON OrgPreferences where
  toJSON OrgPreferences {..} =
   _omitNulls
      [ "_links" .= orgPreferencesLinks
      , "showEndUserFooter" .= orgPreferencesShowEndUserFooter
      ]


-- | Construct a value of type 'OrgPreferences' (by applying it's required fields, if any)
mkOrgPreferences
  :: OrgPreferences
mkOrgPreferences =
  OrgPreferences
  { orgPreferencesLinks = Nothing
  , orgPreferencesShowEndUserFooter = Nothing
  }

-- ** OrgSetting
-- | OrgSetting
data OrgSetting = OrgSetting
  { orgSettingLinks :: !(Maybe A.Value) -- ^ "_links"
  , orgSettingAddress1 :: !(Maybe Text) -- ^ "address1"
  , orgSettingAddress2 :: !(Maybe Text) -- ^ "address2"
  , orgSettingCity :: !(Maybe Text) -- ^ "city"
  , orgSettingCompanyName :: !(Maybe Text) -- ^ "companyName"
  , orgSettingCountry :: !(Maybe Text) -- ^ "country"
  , orgSettingCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , orgSettingEndUserSupportHelpUrl :: !(Maybe Text) -- ^ "endUserSupportHelpURL"
  , orgSettingExpiresAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiresAt"
  , orgSettingId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , orgSettingLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , orgSettingPhoneNumber :: !(Maybe Text) -- ^ "phoneNumber"
  , orgSettingPostalCode :: !(Maybe Text) -- ^ "postalCode"
  , orgSettingState :: !(Maybe Text) -- ^ "state"
  , orgSettingStatus :: !(Maybe Text) -- ^ /ReadOnly/ "status"
  , orgSettingSubdomain :: !(Maybe Text) -- ^ /ReadOnly/ "subdomain"
  , orgSettingSupportPhoneNumber :: !(Maybe Text) -- ^ "supportPhoneNumber"
  , orgSettingWebsite :: !(Maybe Text) -- ^ "website"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrgSetting
instance A.FromJSON OrgSetting where
  parseJSON = A.withObject "OrgSetting" $ \o ->
    OrgSetting
      <$> (o .:? "_links")
      <*> (o .:? "address1")
      <*> (o .:? "address2")
      <*> (o .:? "city")
      <*> (o .:? "companyName")
      <*> (o .:? "country")
      <*> (o .:? "created")
      <*> (o .:? "endUserSupportHelpURL")
      <*> (o .:? "expiresAt")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "phoneNumber")
      <*> (o .:? "postalCode")
      <*> (o .:? "state")
      <*> (o .:? "status")
      <*> (o .:? "subdomain")
      <*> (o .:? "supportPhoneNumber")
      <*> (o .:? "website")

-- | ToJSON OrgSetting
instance A.ToJSON OrgSetting where
  toJSON OrgSetting {..} =
   _omitNulls
      [ "_links" .= orgSettingLinks
      , "address1" .= orgSettingAddress1
      , "address2" .= orgSettingAddress2
      , "city" .= orgSettingCity
      , "companyName" .= orgSettingCompanyName
      , "country" .= orgSettingCountry
      , "created" .= orgSettingCreated
      , "endUserSupportHelpURL" .= orgSettingEndUserSupportHelpUrl
      , "expiresAt" .= orgSettingExpiresAt
      , "id" .= orgSettingId
      , "lastUpdated" .= orgSettingLastUpdated
      , "phoneNumber" .= orgSettingPhoneNumber
      , "postalCode" .= orgSettingPostalCode
      , "state" .= orgSettingState
      , "status" .= orgSettingStatus
      , "subdomain" .= orgSettingSubdomain
      , "supportPhoneNumber" .= orgSettingSupportPhoneNumber
      , "website" .= orgSettingWebsite
      ]


-- | Construct a value of type 'OrgSetting' (by applying it's required fields, if any)
mkOrgSetting
  :: OrgSetting
mkOrgSetting =
  OrgSetting
  { orgSettingLinks = Nothing
  , orgSettingAddress1 = Nothing
  , orgSettingAddress2 = Nothing
  , orgSettingCity = Nothing
  , orgSettingCompanyName = Nothing
  , orgSettingCountry = Nothing
  , orgSettingCreated = Nothing
  , orgSettingEndUserSupportHelpUrl = Nothing
  , orgSettingExpiresAt = Nothing
  , orgSettingId = Nothing
  , orgSettingLastUpdated = Nothing
  , orgSettingPhoneNumber = Nothing
  , orgSettingPostalCode = Nothing
  , orgSettingState = Nothing
  , orgSettingStatus = Nothing
  , orgSettingSubdomain = Nothing
  , orgSettingSupportPhoneNumber = Nothing
  , orgSettingWebsite = Nothing
  }

-- ** PasswordCredential
-- | PasswordCredential
data PasswordCredential = PasswordCredential
  { passwordCredentialHash :: !(Maybe PasswordCredentialHash) -- ^ "hash"
  , passwordCredentialHook :: !(Maybe PasswordCredentialHook) -- ^ "hook"
  , passwordCredentialValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordCredential
instance A.FromJSON PasswordCredential where
  parseJSON = A.withObject "PasswordCredential" $ \o ->
    PasswordCredential
      <$> (o .:? "hash")
      <*> (o .:? "hook")
      <*> (o .:? "value")

-- | ToJSON PasswordCredential
instance A.ToJSON PasswordCredential where
  toJSON PasswordCredential {..} =
   _omitNulls
      [ "hash" .= passwordCredentialHash
      , "hook" .= passwordCredentialHook
      , "value" .= passwordCredentialValue
      ]


-- | Construct a value of type 'PasswordCredential' (by applying it's required fields, if any)
mkPasswordCredential
  :: PasswordCredential
mkPasswordCredential =
  PasswordCredential
  { passwordCredentialHash = Nothing
  , passwordCredentialHook = Nothing
  , passwordCredentialValue = Nothing
  }

-- ** PasswordCredentialHash
-- | PasswordCredentialHash
data PasswordCredentialHash = PasswordCredentialHash
  { passwordCredentialHashAlgorithm :: !(Maybe PasswordCredentialHashAlgorithm) -- ^ "algorithm"
  , passwordCredentialHashSalt :: !(Maybe Text) -- ^ "salt"
  , passwordCredentialHashSaltOrder :: !(Maybe Text) -- ^ "saltOrder"
  , passwordCredentialHashValue :: !(Maybe Text) -- ^ "value"
  , passwordCredentialHashWorkFactor :: !(Maybe Int) -- ^ "workFactor"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordCredentialHash
instance A.FromJSON PasswordCredentialHash where
  parseJSON = A.withObject "PasswordCredentialHash" $ \o ->
    PasswordCredentialHash
      <$> (o .:? "algorithm")
      <*> (o .:? "salt")
      <*> (o .:? "saltOrder")
      <*> (o .:? "value")
      <*> (o .:? "workFactor")

-- | ToJSON PasswordCredentialHash
instance A.ToJSON PasswordCredentialHash where
  toJSON PasswordCredentialHash {..} =
   _omitNulls
      [ "algorithm" .= passwordCredentialHashAlgorithm
      , "salt" .= passwordCredentialHashSalt
      , "saltOrder" .= passwordCredentialHashSaltOrder
      , "value" .= passwordCredentialHashValue
      , "workFactor" .= passwordCredentialHashWorkFactor
      ]


-- | Construct a value of type 'PasswordCredentialHash' (by applying it's required fields, if any)
mkPasswordCredentialHash
  :: PasswordCredentialHash
mkPasswordCredentialHash =
  PasswordCredentialHash
  { passwordCredentialHashAlgorithm = Nothing
  , passwordCredentialHashSalt = Nothing
  , passwordCredentialHashSaltOrder = Nothing
  , passwordCredentialHashValue = Nothing
  , passwordCredentialHashWorkFactor = Nothing
  }

-- ** PasswordCredentialHook
-- | PasswordCredentialHook
data PasswordCredentialHook = PasswordCredentialHook
  { passwordCredentialHookType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordCredentialHook
instance A.FromJSON PasswordCredentialHook where
  parseJSON = A.withObject "PasswordCredentialHook" $ \o ->
    PasswordCredentialHook
      <$> (o .:? "type")

-- | ToJSON PasswordCredentialHook
instance A.ToJSON PasswordCredentialHook where
  toJSON PasswordCredentialHook {..} =
   _omitNulls
      [ "type" .= passwordCredentialHookType
      ]


-- | Construct a value of type 'PasswordCredentialHook' (by applying it's required fields, if any)
mkPasswordCredentialHook
  :: PasswordCredentialHook
mkPasswordCredentialHook =
  PasswordCredentialHook
  { passwordCredentialHookType = Nothing
  }

-- ** PasswordDictionary
-- | PasswordDictionary
data PasswordDictionary = PasswordDictionary
  { passwordDictionaryCommon :: !(Maybe PasswordDictionaryCommon) -- ^ "common"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordDictionary
instance A.FromJSON PasswordDictionary where
  parseJSON = A.withObject "PasswordDictionary" $ \o ->
    PasswordDictionary
      <$> (o .:? "common")

-- | ToJSON PasswordDictionary
instance A.ToJSON PasswordDictionary where
  toJSON PasswordDictionary {..} =
   _omitNulls
      [ "common" .= passwordDictionaryCommon
      ]


-- | Construct a value of type 'PasswordDictionary' (by applying it's required fields, if any)
mkPasswordDictionary
  :: PasswordDictionary
mkPasswordDictionary =
  PasswordDictionary
  { passwordDictionaryCommon = Nothing
  }

-- ** PasswordDictionaryCommon
-- | PasswordDictionaryCommon
data PasswordDictionaryCommon = PasswordDictionaryCommon
  { passwordDictionaryCommonExclude :: !(Maybe Bool) -- ^ "exclude"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordDictionaryCommon
instance A.FromJSON PasswordDictionaryCommon where
  parseJSON = A.withObject "PasswordDictionaryCommon" $ \o ->
    PasswordDictionaryCommon
      <$> (o .:? "exclude")

-- | ToJSON PasswordDictionaryCommon
instance A.ToJSON PasswordDictionaryCommon where
  toJSON PasswordDictionaryCommon {..} =
   _omitNulls
      [ "exclude" .= passwordDictionaryCommonExclude
      ]


-- | Construct a value of type 'PasswordDictionaryCommon' (by applying it's required fields, if any)
mkPasswordDictionaryCommon
  :: PasswordDictionaryCommon
mkPasswordDictionaryCommon =
  PasswordDictionaryCommon
  { passwordDictionaryCommonExclude = Nothing
  }

-- ** PasswordExpirationPolicyRuleCondition
-- | PasswordExpirationPolicyRuleCondition
data PasswordExpirationPolicyRuleCondition = PasswordExpirationPolicyRuleCondition
  { passwordExpirationPolicyRuleConditionNumber :: !(Maybe Int) -- ^ "number"
  , passwordExpirationPolicyRuleConditionUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordExpirationPolicyRuleCondition
instance A.FromJSON PasswordExpirationPolicyRuleCondition where
  parseJSON = A.withObject "PasswordExpirationPolicyRuleCondition" $ \o ->
    PasswordExpirationPolicyRuleCondition
      <$> (o .:? "number")
      <*> (o .:? "unit")

-- | ToJSON PasswordExpirationPolicyRuleCondition
instance A.ToJSON PasswordExpirationPolicyRuleCondition where
  toJSON PasswordExpirationPolicyRuleCondition {..} =
   _omitNulls
      [ "number" .= passwordExpirationPolicyRuleConditionNumber
      , "unit" .= passwordExpirationPolicyRuleConditionUnit
      ]


-- | Construct a value of type 'PasswordExpirationPolicyRuleCondition' (by applying it's required fields, if any)
mkPasswordExpirationPolicyRuleCondition
  :: PasswordExpirationPolicyRuleCondition
mkPasswordExpirationPolicyRuleCondition =
  PasswordExpirationPolicyRuleCondition
  { passwordExpirationPolicyRuleConditionNumber = Nothing
  , passwordExpirationPolicyRuleConditionUnit = Nothing
  }

-- ** PasswordPolicy
-- | PasswordPolicy
data PasswordPolicy = PasswordPolicy
  { passwordPolicyConditions :: !(Maybe PasswordPolicyConditions) -- ^ "conditions"
  , passwordPolicySettings :: !(Maybe PasswordPolicySettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicy
instance A.FromJSON PasswordPolicy where
  parseJSON = A.withObject "PasswordPolicy" $ \o ->
    PasswordPolicy
      <$> (o .:? "conditions")
      <*> (o .:? "settings")

-- | ToJSON PasswordPolicy
instance A.ToJSON PasswordPolicy where
  toJSON PasswordPolicy {..} =
   _omitNulls
      [ "conditions" .= passwordPolicyConditions
      , "settings" .= passwordPolicySettings
      ]


-- | Construct a value of type 'PasswordPolicy' (by applying it's required fields, if any)
mkPasswordPolicy
  :: PasswordPolicy
mkPasswordPolicy =
  PasswordPolicy
  { passwordPolicyConditions = Nothing
  , passwordPolicySettings = Nothing
  }

-- ** PasswordPolicyAuthenticationProviderCondition
-- | PasswordPolicyAuthenticationProviderCondition
data PasswordPolicyAuthenticationProviderCondition = PasswordPolicyAuthenticationProviderCondition
  { passwordPolicyAuthenticationProviderConditionInclude :: !(Maybe [Text]) -- ^ "include"
  , passwordPolicyAuthenticationProviderConditionProvider :: !(Maybe E'Provider2) -- ^ "provider"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyAuthenticationProviderCondition
instance A.FromJSON PasswordPolicyAuthenticationProviderCondition where
  parseJSON = A.withObject "PasswordPolicyAuthenticationProviderCondition" $ \o ->
    PasswordPolicyAuthenticationProviderCondition
      <$> (o .:? "include")
      <*> (o .:? "provider")

-- | ToJSON PasswordPolicyAuthenticationProviderCondition
instance A.ToJSON PasswordPolicyAuthenticationProviderCondition where
  toJSON PasswordPolicyAuthenticationProviderCondition {..} =
   _omitNulls
      [ "include" .= passwordPolicyAuthenticationProviderConditionInclude
      , "provider" .= passwordPolicyAuthenticationProviderConditionProvider
      ]


-- | Construct a value of type 'PasswordPolicyAuthenticationProviderCondition' (by applying it's required fields, if any)
mkPasswordPolicyAuthenticationProviderCondition
  :: PasswordPolicyAuthenticationProviderCondition
mkPasswordPolicyAuthenticationProviderCondition =
  PasswordPolicyAuthenticationProviderCondition
  { passwordPolicyAuthenticationProviderConditionInclude = Nothing
  , passwordPolicyAuthenticationProviderConditionProvider = Nothing
  }

-- ** PasswordPolicyConditions
-- | PasswordPolicyConditions
data PasswordPolicyConditions = PasswordPolicyConditions
  { passwordPolicyConditionsAuthProvider :: !(Maybe PasswordPolicyAuthenticationProviderCondition) -- ^ "authProvider"
  , passwordPolicyConditionsPeople :: !(Maybe PolicyPeopleCondition) -- ^ "people"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyConditions
instance A.FromJSON PasswordPolicyConditions where
  parseJSON = A.withObject "PasswordPolicyConditions" $ \o ->
    PasswordPolicyConditions
      <$> (o .:? "authProvider")
      <*> (o .:? "people")

-- | ToJSON PasswordPolicyConditions
instance A.ToJSON PasswordPolicyConditions where
  toJSON PasswordPolicyConditions {..} =
   _omitNulls
      [ "authProvider" .= passwordPolicyConditionsAuthProvider
      , "people" .= passwordPolicyConditionsPeople
      ]


-- | Construct a value of type 'PasswordPolicyConditions' (by applying it's required fields, if any)
mkPasswordPolicyConditions
  :: PasswordPolicyConditions
mkPasswordPolicyConditions =
  PasswordPolicyConditions
  { passwordPolicyConditionsAuthProvider = Nothing
  , passwordPolicyConditionsPeople = Nothing
  }

-- ** PasswordPolicyDelegationSettings
-- | PasswordPolicyDelegationSettings
data PasswordPolicyDelegationSettings = PasswordPolicyDelegationSettings
  { passwordPolicyDelegationSettingsOptions :: !(Maybe PasswordPolicyDelegationSettingsOptions) -- ^ "options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyDelegationSettings
instance A.FromJSON PasswordPolicyDelegationSettings where
  parseJSON = A.withObject "PasswordPolicyDelegationSettings" $ \o ->
    PasswordPolicyDelegationSettings
      <$> (o .:? "options")

-- | ToJSON PasswordPolicyDelegationSettings
instance A.ToJSON PasswordPolicyDelegationSettings where
  toJSON PasswordPolicyDelegationSettings {..} =
   _omitNulls
      [ "options" .= passwordPolicyDelegationSettingsOptions
      ]


-- | Construct a value of type 'PasswordPolicyDelegationSettings' (by applying it's required fields, if any)
mkPasswordPolicyDelegationSettings
  :: PasswordPolicyDelegationSettings
mkPasswordPolicyDelegationSettings =
  PasswordPolicyDelegationSettings
  { passwordPolicyDelegationSettingsOptions = Nothing
  }

-- ** PasswordPolicyDelegationSettingsOptions
-- | PasswordPolicyDelegationSettingsOptions
data PasswordPolicyDelegationSettingsOptions = PasswordPolicyDelegationSettingsOptions
  { passwordPolicyDelegationSettingsOptionsSkipUnlock :: !(Maybe Bool) -- ^ "skipUnlock"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyDelegationSettingsOptions
instance A.FromJSON PasswordPolicyDelegationSettingsOptions where
  parseJSON = A.withObject "PasswordPolicyDelegationSettingsOptions" $ \o ->
    PasswordPolicyDelegationSettingsOptions
      <$> (o .:? "skipUnlock")

-- | ToJSON PasswordPolicyDelegationSettingsOptions
instance A.ToJSON PasswordPolicyDelegationSettingsOptions where
  toJSON PasswordPolicyDelegationSettingsOptions {..} =
   _omitNulls
      [ "skipUnlock" .= passwordPolicyDelegationSettingsOptionsSkipUnlock
      ]


-- | Construct a value of type 'PasswordPolicyDelegationSettingsOptions' (by applying it's required fields, if any)
mkPasswordPolicyDelegationSettingsOptions
  :: PasswordPolicyDelegationSettingsOptions
mkPasswordPolicyDelegationSettingsOptions =
  PasswordPolicyDelegationSettingsOptions
  { passwordPolicyDelegationSettingsOptionsSkipUnlock = Nothing
  }

-- ** PasswordPolicyPasswordSettings
-- | PasswordPolicyPasswordSettings
data PasswordPolicyPasswordSettings = PasswordPolicyPasswordSettings
  { passwordPolicyPasswordSettingsAge :: !(Maybe PasswordPolicyPasswordSettingsAge) -- ^ "age"
  , passwordPolicyPasswordSettingsComplexity :: !(Maybe PasswordPolicyPasswordSettingsComplexity) -- ^ "complexity"
  , passwordPolicyPasswordSettingsLockout :: !(Maybe PasswordPolicyPasswordSettingsLockout) -- ^ "lockout"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyPasswordSettings
instance A.FromJSON PasswordPolicyPasswordSettings where
  parseJSON = A.withObject "PasswordPolicyPasswordSettings" $ \o ->
    PasswordPolicyPasswordSettings
      <$> (o .:? "age")
      <*> (o .:? "complexity")
      <*> (o .:? "lockout")

-- | ToJSON PasswordPolicyPasswordSettings
instance A.ToJSON PasswordPolicyPasswordSettings where
  toJSON PasswordPolicyPasswordSettings {..} =
   _omitNulls
      [ "age" .= passwordPolicyPasswordSettingsAge
      , "complexity" .= passwordPolicyPasswordSettingsComplexity
      , "lockout" .= passwordPolicyPasswordSettingsLockout
      ]


-- | Construct a value of type 'PasswordPolicyPasswordSettings' (by applying it's required fields, if any)
mkPasswordPolicyPasswordSettings
  :: PasswordPolicyPasswordSettings
mkPasswordPolicyPasswordSettings =
  PasswordPolicyPasswordSettings
  { passwordPolicyPasswordSettingsAge = Nothing
  , passwordPolicyPasswordSettingsComplexity = Nothing
  , passwordPolicyPasswordSettingsLockout = Nothing
  }

-- ** PasswordPolicyPasswordSettingsAge
-- | PasswordPolicyPasswordSettingsAge
data PasswordPolicyPasswordSettingsAge = PasswordPolicyPasswordSettingsAge
  { passwordPolicyPasswordSettingsAgeExpireWarnDays :: !(Maybe Int) -- ^ "expireWarnDays"
  , passwordPolicyPasswordSettingsAgeHistoryCount :: !(Maybe Int) -- ^ "historyCount"
  , passwordPolicyPasswordSettingsAgeMaxAgeDays :: !(Maybe Int) -- ^ "maxAgeDays"
  , passwordPolicyPasswordSettingsAgeMinAgeMinutes :: !(Maybe Int) -- ^ "minAgeMinutes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyPasswordSettingsAge
instance A.FromJSON PasswordPolicyPasswordSettingsAge where
  parseJSON = A.withObject "PasswordPolicyPasswordSettingsAge" $ \o ->
    PasswordPolicyPasswordSettingsAge
      <$> (o .:? "expireWarnDays")
      <*> (o .:? "historyCount")
      <*> (o .:? "maxAgeDays")
      <*> (o .:? "minAgeMinutes")

-- | ToJSON PasswordPolicyPasswordSettingsAge
instance A.ToJSON PasswordPolicyPasswordSettingsAge where
  toJSON PasswordPolicyPasswordSettingsAge {..} =
   _omitNulls
      [ "expireWarnDays" .= passwordPolicyPasswordSettingsAgeExpireWarnDays
      , "historyCount" .= passwordPolicyPasswordSettingsAgeHistoryCount
      , "maxAgeDays" .= passwordPolicyPasswordSettingsAgeMaxAgeDays
      , "minAgeMinutes" .= passwordPolicyPasswordSettingsAgeMinAgeMinutes
      ]


-- | Construct a value of type 'PasswordPolicyPasswordSettingsAge' (by applying it's required fields, if any)
mkPasswordPolicyPasswordSettingsAge
  :: PasswordPolicyPasswordSettingsAge
mkPasswordPolicyPasswordSettingsAge =
  PasswordPolicyPasswordSettingsAge
  { passwordPolicyPasswordSettingsAgeExpireWarnDays = Nothing
  , passwordPolicyPasswordSettingsAgeHistoryCount = Nothing
  , passwordPolicyPasswordSettingsAgeMaxAgeDays = Nothing
  , passwordPolicyPasswordSettingsAgeMinAgeMinutes = Nothing
  }

-- ** PasswordPolicyPasswordSettingsComplexity
-- | PasswordPolicyPasswordSettingsComplexity
data PasswordPolicyPasswordSettingsComplexity = PasswordPolicyPasswordSettingsComplexity
  { passwordPolicyPasswordSettingsComplexityDictionary :: !(Maybe PasswordDictionary) -- ^ "dictionary"
  , passwordPolicyPasswordSettingsComplexityExcludeAttributes :: !(Maybe [Text]) -- ^ "excludeAttributes"
  , passwordPolicyPasswordSettingsComplexityExcludeUsername :: !(Maybe Bool) -- ^ "excludeUsername"
  , passwordPolicyPasswordSettingsComplexityMinLength :: !(Maybe Int) -- ^ "minLength"
  , passwordPolicyPasswordSettingsComplexityMinLowerCase :: !(Maybe Int) -- ^ "minLowerCase"
  , passwordPolicyPasswordSettingsComplexityMinNumber :: !(Maybe Int) -- ^ "minNumber"
  , passwordPolicyPasswordSettingsComplexityMinSymbol :: !(Maybe Int) -- ^ "minSymbol"
  , passwordPolicyPasswordSettingsComplexityMinUpperCase :: !(Maybe Int) -- ^ "minUpperCase"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyPasswordSettingsComplexity
instance A.FromJSON PasswordPolicyPasswordSettingsComplexity where
  parseJSON = A.withObject "PasswordPolicyPasswordSettingsComplexity" $ \o ->
    PasswordPolicyPasswordSettingsComplexity
      <$> (o .:? "dictionary")
      <*> (o .:? "excludeAttributes")
      <*> (o .:? "excludeUsername")
      <*> (o .:? "minLength")
      <*> (o .:? "minLowerCase")
      <*> (o .:? "minNumber")
      <*> (o .:? "minSymbol")
      <*> (o .:? "minUpperCase")

-- | ToJSON PasswordPolicyPasswordSettingsComplexity
instance A.ToJSON PasswordPolicyPasswordSettingsComplexity where
  toJSON PasswordPolicyPasswordSettingsComplexity {..} =
   _omitNulls
      [ "dictionary" .= passwordPolicyPasswordSettingsComplexityDictionary
      , "excludeAttributes" .= passwordPolicyPasswordSettingsComplexityExcludeAttributes
      , "excludeUsername" .= passwordPolicyPasswordSettingsComplexityExcludeUsername
      , "minLength" .= passwordPolicyPasswordSettingsComplexityMinLength
      , "minLowerCase" .= passwordPolicyPasswordSettingsComplexityMinLowerCase
      , "minNumber" .= passwordPolicyPasswordSettingsComplexityMinNumber
      , "minSymbol" .= passwordPolicyPasswordSettingsComplexityMinSymbol
      , "minUpperCase" .= passwordPolicyPasswordSettingsComplexityMinUpperCase
      ]


-- | Construct a value of type 'PasswordPolicyPasswordSettingsComplexity' (by applying it's required fields, if any)
mkPasswordPolicyPasswordSettingsComplexity
  :: PasswordPolicyPasswordSettingsComplexity
mkPasswordPolicyPasswordSettingsComplexity =
  PasswordPolicyPasswordSettingsComplexity
  { passwordPolicyPasswordSettingsComplexityDictionary = Nothing
  , passwordPolicyPasswordSettingsComplexityExcludeAttributes = Nothing
  , passwordPolicyPasswordSettingsComplexityExcludeUsername = Nothing
  , passwordPolicyPasswordSettingsComplexityMinLength = Nothing
  , passwordPolicyPasswordSettingsComplexityMinLowerCase = Nothing
  , passwordPolicyPasswordSettingsComplexityMinNumber = Nothing
  , passwordPolicyPasswordSettingsComplexityMinSymbol = Nothing
  , passwordPolicyPasswordSettingsComplexityMinUpperCase = Nothing
  }

-- ** PasswordPolicyPasswordSettingsLockout
-- | PasswordPolicyPasswordSettingsLockout
data PasswordPolicyPasswordSettingsLockout = PasswordPolicyPasswordSettingsLockout
  { passwordPolicyPasswordSettingsLockoutAutoUnlockMinutes :: !(Maybe Int) -- ^ "autoUnlockMinutes"
  , passwordPolicyPasswordSettingsLockoutMaxAttempts :: !(Maybe Int) -- ^ "maxAttempts"
  , passwordPolicyPasswordSettingsLockoutShowLockoutFailures :: !(Maybe Bool) -- ^ "showLockoutFailures"
  , passwordPolicyPasswordSettingsLockoutUserLockoutNotificationChannels :: !(Maybe [Text]) -- ^ "userLockoutNotificationChannels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyPasswordSettingsLockout
instance A.FromJSON PasswordPolicyPasswordSettingsLockout where
  parseJSON = A.withObject "PasswordPolicyPasswordSettingsLockout" $ \o ->
    PasswordPolicyPasswordSettingsLockout
      <$> (o .:? "autoUnlockMinutes")
      <*> (o .:? "maxAttempts")
      <*> (o .:? "showLockoutFailures")
      <*> (o .:? "userLockoutNotificationChannels")

-- | ToJSON PasswordPolicyPasswordSettingsLockout
instance A.ToJSON PasswordPolicyPasswordSettingsLockout where
  toJSON PasswordPolicyPasswordSettingsLockout {..} =
   _omitNulls
      [ "autoUnlockMinutes" .= passwordPolicyPasswordSettingsLockoutAutoUnlockMinutes
      , "maxAttempts" .= passwordPolicyPasswordSettingsLockoutMaxAttempts
      , "showLockoutFailures" .= passwordPolicyPasswordSettingsLockoutShowLockoutFailures
      , "userLockoutNotificationChannels" .= passwordPolicyPasswordSettingsLockoutUserLockoutNotificationChannels
      ]


-- | Construct a value of type 'PasswordPolicyPasswordSettingsLockout' (by applying it's required fields, if any)
mkPasswordPolicyPasswordSettingsLockout
  :: PasswordPolicyPasswordSettingsLockout
mkPasswordPolicyPasswordSettingsLockout =
  PasswordPolicyPasswordSettingsLockout
  { passwordPolicyPasswordSettingsLockoutAutoUnlockMinutes = Nothing
  , passwordPolicyPasswordSettingsLockoutMaxAttempts = Nothing
  , passwordPolicyPasswordSettingsLockoutShowLockoutFailures = Nothing
  , passwordPolicyPasswordSettingsLockoutUserLockoutNotificationChannels = Nothing
  }

-- ** PasswordPolicyRecoveryEmail
-- | PasswordPolicyRecoveryEmail
data PasswordPolicyRecoveryEmail = PasswordPolicyRecoveryEmail
  { passwordPolicyRecoveryEmailProperties :: !(Maybe PasswordPolicyRecoveryEmailProperties) -- ^ "properties"
  , passwordPolicyRecoveryEmailStatus :: !(Maybe E'Status2) -- ^ /ReadOnly/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryEmail
instance A.FromJSON PasswordPolicyRecoveryEmail where
  parseJSON = A.withObject "PasswordPolicyRecoveryEmail" $ \o ->
    PasswordPolicyRecoveryEmail
      <$> (o .:? "properties")
      <*> (o .:? "status")

-- | ToJSON PasswordPolicyRecoveryEmail
instance A.ToJSON PasswordPolicyRecoveryEmail where
  toJSON PasswordPolicyRecoveryEmail {..} =
   _omitNulls
      [ "properties" .= passwordPolicyRecoveryEmailProperties
      , "status" .= passwordPolicyRecoveryEmailStatus
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryEmail' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryEmail
  :: PasswordPolicyRecoveryEmail
mkPasswordPolicyRecoveryEmail =
  PasswordPolicyRecoveryEmail
  { passwordPolicyRecoveryEmailProperties = Nothing
  , passwordPolicyRecoveryEmailStatus = Nothing
  }

-- ** PasswordPolicyRecoveryEmailProperties
-- | PasswordPolicyRecoveryEmailProperties
data PasswordPolicyRecoveryEmailProperties = PasswordPolicyRecoveryEmailProperties
  { passwordPolicyRecoveryEmailPropertiesRecoveryToken :: !(Maybe PasswordPolicyRecoveryEmailRecoveryToken) -- ^ "recoveryToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryEmailProperties
instance A.FromJSON PasswordPolicyRecoveryEmailProperties where
  parseJSON = A.withObject "PasswordPolicyRecoveryEmailProperties" $ \o ->
    PasswordPolicyRecoveryEmailProperties
      <$> (o .:? "recoveryToken")

-- | ToJSON PasswordPolicyRecoveryEmailProperties
instance A.ToJSON PasswordPolicyRecoveryEmailProperties where
  toJSON PasswordPolicyRecoveryEmailProperties {..} =
   _omitNulls
      [ "recoveryToken" .= passwordPolicyRecoveryEmailPropertiesRecoveryToken
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryEmailProperties' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryEmailProperties
  :: PasswordPolicyRecoveryEmailProperties
mkPasswordPolicyRecoveryEmailProperties =
  PasswordPolicyRecoveryEmailProperties
  { passwordPolicyRecoveryEmailPropertiesRecoveryToken = Nothing
  }

-- ** PasswordPolicyRecoveryEmailRecoveryToken
-- | PasswordPolicyRecoveryEmailRecoveryToken
data PasswordPolicyRecoveryEmailRecoveryToken = PasswordPolicyRecoveryEmailRecoveryToken
  { passwordPolicyRecoveryEmailRecoveryTokenTokenLifetimeMinutes :: !(Maybe Int) -- ^ "tokenLifetimeMinutes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryEmailRecoveryToken
instance A.FromJSON PasswordPolicyRecoveryEmailRecoveryToken where
  parseJSON = A.withObject "PasswordPolicyRecoveryEmailRecoveryToken" $ \o ->
    PasswordPolicyRecoveryEmailRecoveryToken
      <$> (o .:? "tokenLifetimeMinutes")

-- | ToJSON PasswordPolicyRecoveryEmailRecoveryToken
instance A.ToJSON PasswordPolicyRecoveryEmailRecoveryToken where
  toJSON PasswordPolicyRecoveryEmailRecoveryToken {..} =
   _omitNulls
      [ "tokenLifetimeMinutes" .= passwordPolicyRecoveryEmailRecoveryTokenTokenLifetimeMinutes
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryEmailRecoveryToken' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryEmailRecoveryToken
  :: PasswordPolicyRecoveryEmailRecoveryToken
mkPasswordPolicyRecoveryEmailRecoveryToken =
  PasswordPolicyRecoveryEmailRecoveryToken
  { passwordPolicyRecoveryEmailRecoveryTokenTokenLifetimeMinutes = Nothing
  }

-- ** PasswordPolicyRecoveryFactorSettings
-- | PasswordPolicyRecoveryFactorSettings
data PasswordPolicyRecoveryFactorSettings = PasswordPolicyRecoveryFactorSettings
  { passwordPolicyRecoveryFactorSettingsStatus :: !(Maybe E'Status2) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryFactorSettings
instance A.FromJSON PasswordPolicyRecoveryFactorSettings where
  parseJSON = A.withObject "PasswordPolicyRecoveryFactorSettings" $ \o ->
    PasswordPolicyRecoveryFactorSettings
      <$> (o .:? "status")

-- | ToJSON PasswordPolicyRecoveryFactorSettings
instance A.ToJSON PasswordPolicyRecoveryFactorSettings where
  toJSON PasswordPolicyRecoveryFactorSettings {..} =
   _omitNulls
      [ "status" .= passwordPolicyRecoveryFactorSettingsStatus
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryFactorSettings' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryFactorSettings
  :: PasswordPolicyRecoveryFactorSettings
mkPasswordPolicyRecoveryFactorSettings =
  PasswordPolicyRecoveryFactorSettings
  { passwordPolicyRecoveryFactorSettingsStatus = Nothing
  }

-- ** PasswordPolicyRecoveryFactors
-- | PasswordPolicyRecoveryFactors
data PasswordPolicyRecoveryFactors = PasswordPolicyRecoveryFactors
  { passwordPolicyRecoveryFactorsOktaCall :: !(Maybe PasswordPolicyRecoveryFactorSettings) -- ^ "okta_call"
  , passwordPolicyRecoveryFactorsOktaEmail :: !(Maybe PasswordPolicyRecoveryEmail) -- ^ "okta_email"
  , passwordPolicyRecoveryFactorsOktaSms :: !(Maybe PasswordPolicyRecoveryFactorSettings) -- ^ "okta_sms"
  , passwordPolicyRecoveryFactorsRecoveryQuestion :: !(Maybe PasswordPolicyRecoveryQuestion) -- ^ "recovery_question"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryFactors
instance A.FromJSON PasswordPolicyRecoveryFactors where
  parseJSON = A.withObject "PasswordPolicyRecoveryFactors" $ \o ->
    PasswordPolicyRecoveryFactors
      <$> (o .:? "okta_call")
      <*> (o .:? "okta_email")
      <*> (o .:? "okta_sms")
      <*> (o .:? "recovery_question")

-- | ToJSON PasswordPolicyRecoveryFactors
instance A.ToJSON PasswordPolicyRecoveryFactors where
  toJSON PasswordPolicyRecoveryFactors {..} =
   _omitNulls
      [ "okta_call" .= passwordPolicyRecoveryFactorsOktaCall
      , "okta_email" .= passwordPolicyRecoveryFactorsOktaEmail
      , "okta_sms" .= passwordPolicyRecoveryFactorsOktaSms
      , "recovery_question" .= passwordPolicyRecoveryFactorsRecoveryQuestion
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryFactors' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryFactors
  :: PasswordPolicyRecoveryFactors
mkPasswordPolicyRecoveryFactors =
  PasswordPolicyRecoveryFactors
  { passwordPolicyRecoveryFactorsOktaCall = Nothing
  , passwordPolicyRecoveryFactorsOktaEmail = Nothing
  , passwordPolicyRecoveryFactorsOktaSms = Nothing
  , passwordPolicyRecoveryFactorsRecoveryQuestion = Nothing
  }

-- ** PasswordPolicyRecoveryQuestion
-- | PasswordPolicyRecoveryQuestion
data PasswordPolicyRecoveryQuestion = PasswordPolicyRecoveryQuestion
  { passwordPolicyRecoveryQuestionProperties :: !(Maybe PasswordPolicyRecoveryQuestionProperties) -- ^ "properties"
  , passwordPolicyRecoveryQuestionStatus :: !(Maybe E'Status2) -- ^ /ReadOnly/ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryQuestion
instance A.FromJSON PasswordPolicyRecoveryQuestion where
  parseJSON = A.withObject "PasswordPolicyRecoveryQuestion" $ \o ->
    PasswordPolicyRecoveryQuestion
      <$> (o .:? "properties")
      <*> (o .:? "status")

-- | ToJSON PasswordPolicyRecoveryQuestion
instance A.ToJSON PasswordPolicyRecoveryQuestion where
  toJSON PasswordPolicyRecoveryQuestion {..} =
   _omitNulls
      [ "properties" .= passwordPolicyRecoveryQuestionProperties
      , "status" .= passwordPolicyRecoveryQuestionStatus
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryQuestion' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryQuestion
  :: PasswordPolicyRecoveryQuestion
mkPasswordPolicyRecoveryQuestion =
  PasswordPolicyRecoveryQuestion
  { passwordPolicyRecoveryQuestionProperties = Nothing
  , passwordPolicyRecoveryQuestionStatus = Nothing
  }

-- ** PasswordPolicyRecoveryQuestionComplexity
-- | PasswordPolicyRecoveryQuestionComplexity
data PasswordPolicyRecoveryQuestionComplexity = PasswordPolicyRecoveryQuestionComplexity
  { passwordPolicyRecoveryQuestionComplexityMinLength :: !(Maybe Int) -- ^ /ReadOnly/ "minLength"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryQuestionComplexity
instance A.FromJSON PasswordPolicyRecoveryQuestionComplexity where
  parseJSON = A.withObject "PasswordPolicyRecoveryQuestionComplexity" $ \o ->
    PasswordPolicyRecoveryQuestionComplexity
      <$> (o .:? "minLength")

-- | ToJSON PasswordPolicyRecoveryQuestionComplexity
instance A.ToJSON PasswordPolicyRecoveryQuestionComplexity where
  toJSON PasswordPolicyRecoveryQuestionComplexity {..} =
   _omitNulls
      [ "minLength" .= passwordPolicyRecoveryQuestionComplexityMinLength
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryQuestionComplexity' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryQuestionComplexity
  :: PasswordPolicyRecoveryQuestionComplexity
mkPasswordPolicyRecoveryQuestionComplexity =
  PasswordPolicyRecoveryQuestionComplexity
  { passwordPolicyRecoveryQuestionComplexityMinLength = Nothing
  }

-- ** PasswordPolicyRecoveryQuestionProperties
-- | PasswordPolicyRecoveryQuestionProperties
data PasswordPolicyRecoveryQuestionProperties = PasswordPolicyRecoveryQuestionProperties
  { passwordPolicyRecoveryQuestionPropertiesComplexity :: !(Maybe PasswordPolicyRecoveryQuestionComplexity) -- ^ "complexity"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoveryQuestionProperties
instance A.FromJSON PasswordPolicyRecoveryQuestionProperties where
  parseJSON = A.withObject "PasswordPolicyRecoveryQuestionProperties" $ \o ->
    PasswordPolicyRecoveryQuestionProperties
      <$> (o .:? "complexity")

-- | ToJSON PasswordPolicyRecoveryQuestionProperties
instance A.ToJSON PasswordPolicyRecoveryQuestionProperties where
  toJSON PasswordPolicyRecoveryQuestionProperties {..} =
   _omitNulls
      [ "complexity" .= passwordPolicyRecoveryQuestionPropertiesComplexity
      ]


-- | Construct a value of type 'PasswordPolicyRecoveryQuestionProperties' (by applying it's required fields, if any)
mkPasswordPolicyRecoveryQuestionProperties
  :: PasswordPolicyRecoveryQuestionProperties
mkPasswordPolicyRecoveryQuestionProperties =
  PasswordPolicyRecoveryQuestionProperties
  { passwordPolicyRecoveryQuestionPropertiesComplexity = Nothing
  }

-- ** PasswordPolicyRecoverySettings
-- | PasswordPolicyRecoverySettings
data PasswordPolicyRecoverySettings = PasswordPolicyRecoverySettings
  { passwordPolicyRecoverySettingsFactors :: !(Maybe PasswordPolicyRecoveryFactors) -- ^ "factors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRecoverySettings
instance A.FromJSON PasswordPolicyRecoverySettings where
  parseJSON = A.withObject "PasswordPolicyRecoverySettings" $ \o ->
    PasswordPolicyRecoverySettings
      <$> (o .:? "factors")

-- | ToJSON PasswordPolicyRecoverySettings
instance A.ToJSON PasswordPolicyRecoverySettings where
  toJSON PasswordPolicyRecoverySettings {..} =
   _omitNulls
      [ "factors" .= passwordPolicyRecoverySettingsFactors
      ]


-- | Construct a value of type 'PasswordPolicyRecoverySettings' (by applying it's required fields, if any)
mkPasswordPolicyRecoverySettings
  :: PasswordPolicyRecoverySettings
mkPasswordPolicyRecoverySettings =
  PasswordPolicyRecoverySettings
  { passwordPolicyRecoverySettingsFactors = Nothing
  }

-- ** PasswordPolicyRule
-- | PasswordPolicyRule
data PasswordPolicyRule = PasswordPolicyRule
  { passwordPolicyRuleActions :: !(Maybe PasswordPolicyRuleActions) -- ^ "actions"
  , passwordPolicyRuleConditions :: !(Maybe PasswordPolicyRuleConditions) -- ^ "conditions"
  , passwordPolicyRuleName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRule
instance A.FromJSON PasswordPolicyRule where
  parseJSON = A.withObject "PasswordPolicyRule" $ \o ->
    PasswordPolicyRule
      <$> (o .:? "actions")
      <*> (o .:? "conditions")
      <*> (o .:? "name")

-- | ToJSON PasswordPolicyRule
instance A.ToJSON PasswordPolicyRule where
  toJSON PasswordPolicyRule {..} =
   _omitNulls
      [ "actions" .= passwordPolicyRuleActions
      , "conditions" .= passwordPolicyRuleConditions
      , "name" .= passwordPolicyRuleName
      ]


-- | Construct a value of type 'PasswordPolicyRule' (by applying it's required fields, if any)
mkPasswordPolicyRule
  :: PasswordPolicyRule
mkPasswordPolicyRule =
  PasswordPolicyRule
  { passwordPolicyRuleActions = Nothing
  , passwordPolicyRuleConditions = Nothing
  , passwordPolicyRuleName = Nothing
  }

-- ** PasswordPolicyRuleAction
-- | PasswordPolicyRuleAction
data PasswordPolicyRuleAction = PasswordPolicyRuleAction
  { passwordPolicyRuleActionAccess :: !(Maybe E'Access) -- ^ "access"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRuleAction
instance A.FromJSON PasswordPolicyRuleAction where
  parseJSON = A.withObject "PasswordPolicyRuleAction" $ \o ->
    PasswordPolicyRuleAction
      <$> (o .:? "access")

-- | ToJSON PasswordPolicyRuleAction
instance A.ToJSON PasswordPolicyRuleAction where
  toJSON PasswordPolicyRuleAction {..} =
   _omitNulls
      [ "access" .= passwordPolicyRuleActionAccess
      ]


-- | Construct a value of type 'PasswordPolicyRuleAction' (by applying it's required fields, if any)
mkPasswordPolicyRuleAction
  :: PasswordPolicyRuleAction
mkPasswordPolicyRuleAction =
  PasswordPolicyRuleAction
  { passwordPolicyRuleActionAccess = Nothing
  }

-- ** PasswordPolicyRuleActions
-- | PasswordPolicyRuleActions
data PasswordPolicyRuleActions = PasswordPolicyRuleActions
  { passwordPolicyRuleActionsPasswordChange :: !(Maybe PasswordPolicyRuleAction) -- ^ "passwordChange"
  , passwordPolicyRuleActionsSelfServicePasswordReset :: !(Maybe PasswordPolicyRuleAction) -- ^ "selfServicePasswordReset"
  , passwordPolicyRuleActionsSelfServiceUnlock :: !(Maybe PasswordPolicyRuleAction) -- ^ "selfServiceUnlock"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRuleActions
instance A.FromJSON PasswordPolicyRuleActions where
  parseJSON = A.withObject "PasswordPolicyRuleActions" $ \o ->
    PasswordPolicyRuleActions
      <$> (o .:? "passwordChange")
      <*> (o .:? "selfServicePasswordReset")
      <*> (o .:? "selfServiceUnlock")

-- | ToJSON PasswordPolicyRuleActions
instance A.ToJSON PasswordPolicyRuleActions where
  toJSON PasswordPolicyRuleActions {..} =
   _omitNulls
      [ "passwordChange" .= passwordPolicyRuleActionsPasswordChange
      , "selfServicePasswordReset" .= passwordPolicyRuleActionsSelfServicePasswordReset
      , "selfServiceUnlock" .= passwordPolicyRuleActionsSelfServiceUnlock
      ]


-- | Construct a value of type 'PasswordPolicyRuleActions' (by applying it's required fields, if any)
mkPasswordPolicyRuleActions
  :: PasswordPolicyRuleActions
mkPasswordPolicyRuleActions =
  PasswordPolicyRuleActions
  { passwordPolicyRuleActionsPasswordChange = Nothing
  , passwordPolicyRuleActionsSelfServicePasswordReset = Nothing
  , passwordPolicyRuleActionsSelfServiceUnlock = Nothing
  }

-- ** PasswordPolicyRuleConditions
-- | PasswordPolicyRuleConditions
data PasswordPolicyRuleConditions = PasswordPolicyRuleConditions
  { passwordPolicyRuleConditionsNetwork :: !(Maybe PolicyNetworkCondition) -- ^ "network"
  , passwordPolicyRuleConditionsPeople :: !(Maybe PolicyPeopleCondition) -- ^ "people"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicyRuleConditions
instance A.FromJSON PasswordPolicyRuleConditions where
  parseJSON = A.withObject "PasswordPolicyRuleConditions" $ \o ->
    PasswordPolicyRuleConditions
      <$> (o .:? "network")
      <*> (o .:? "people")

-- | ToJSON PasswordPolicyRuleConditions
instance A.ToJSON PasswordPolicyRuleConditions where
  toJSON PasswordPolicyRuleConditions {..} =
   _omitNulls
      [ "network" .= passwordPolicyRuleConditionsNetwork
      , "people" .= passwordPolicyRuleConditionsPeople
      ]


-- | Construct a value of type 'PasswordPolicyRuleConditions' (by applying it's required fields, if any)
mkPasswordPolicyRuleConditions
  :: PasswordPolicyRuleConditions
mkPasswordPolicyRuleConditions =
  PasswordPolicyRuleConditions
  { passwordPolicyRuleConditionsNetwork = Nothing
  , passwordPolicyRuleConditionsPeople = Nothing
  }

-- ** PasswordPolicySettings
-- | PasswordPolicySettings
data PasswordPolicySettings = PasswordPolicySettings
  { passwordPolicySettingsDelegation :: !(Maybe PasswordPolicyDelegationSettings) -- ^ "delegation"
  , passwordPolicySettingsPassword :: !(Maybe PasswordPolicyPasswordSettings) -- ^ "password"
  , passwordPolicySettingsRecovery :: !(Maybe PasswordPolicyRecoverySettings) -- ^ "recovery"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordPolicySettings
instance A.FromJSON PasswordPolicySettings where
  parseJSON = A.withObject "PasswordPolicySettings" $ \o ->
    PasswordPolicySettings
      <$> (o .:? "delegation")
      <*> (o .:? "password")
      <*> (o .:? "recovery")

-- | ToJSON PasswordPolicySettings
instance A.ToJSON PasswordPolicySettings where
  toJSON PasswordPolicySettings {..} =
   _omitNulls
      [ "delegation" .= passwordPolicySettingsDelegation
      , "password" .= passwordPolicySettingsPassword
      , "recovery" .= passwordPolicySettingsRecovery
      ]


-- | Construct a value of type 'PasswordPolicySettings' (by applying it's required fields, if any)
mkPasswordPolicySettings
  :: PasswordPolicySettings
mkPasswordPolicySettings =
  PasswordPolicySettings
  { passwordPolicySettingsDelegation = Nothing
  , passwordPolicySettingsPassword = Nothing
  , passwordPolicySettingsRecovery = Nothing
  }

-- ** PasswordSettingObject
-- | PasswordSettingObject
data PasswordSettingObject = PasswordSettingObject
  { passwordSettingObjectChange :: !(Maybe ChangeEnum) -- ^ "change"
  , passwordSettingObjectSeed :: !(Maybe SeedEnum) -- ^ "seed"
  , passwordSettingObjectStatus :: !(Maybe EnabledStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordSettingObject
instance A.FromJSON PasswordSettingObject where
  parseJSON = A.withObject "PasswordSettingObject" $ \o ->
    PasswordSettingObject
      <$> (o .:? "change")
      <*> (o .:? "seed")
      <*> (o .:? "status")

-- | ToJSON PasswordSettingObject
instance A.ToJSON PasswordSettingObject where
  toJSON PasswordSettingObject {..} =
   _omitNulls
      [ "change" .= passwordSettingObjectChange
      , "seed" .= passwordSettingObjectSeed
      , "status" .= passwordSettingObjectStatus
      ]


-- | Construct a value of type 'PasswordSettingObject' (by applying it's required fields, if any)
mkPasswordSettingObject
  :: PasswordSettingObject
mkPasswordSettingObject =
  PasswordSettingObject
  { passwordSettingObjectChange = Nothing
  , passwordSettingObjectSeed = Nothing
  , passwordSettingObjectStatus = Nothing
  }

-- ** PlatformConditionEvaluatorPlatform
-- | PlatformConditionEvaluatorPlatform
data PlatformConditionEvaluatorPlatform = PlatformConditionEvaluatorPlatform
  { platformConditionEvaluatorPlatformOs :: !(Maybe PlatformConditionEvaluatorPlatformOperatingSystem) -- ^ "os"
  , platformConditionEvaluatorPlatformType :: !(Maybe E'Type6) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlatformConditionEvaluatorPlatform
instance A.FromJSON PlatformConditionEvaluatorPlatform where
  parseJSON = A.withObject "PlatformConditionEvaluatorPlatform" $ \o ->
    PlatformConditionEvaluatorPlatform
      <$> (o .:? "os")
      <*> (o .:? "type")

-- | ToJSON PlatformConditionEvaluatorPlatform
instance A.ToJSON PlatformConditionEvaluatorPlatform where
  toJSON PlatformConditionEvaluatorPlatform {..} =
   _omitNulls
      [ "os" .= platformConditionEvaluatorPlatformOs
      , "type" .= platformConditionEvaluatorPlatformType
      ]


-- | Construct a value of type 'PlatformConditionEvaluatorPlatform' (by applying it's required fields, if any)
mkPlatformConditionEvaluatorPlatform
  :: PlatformConditionEvaluatorPlatform
mkPlatformConditionEvaluatorPlatform =
  PlatformConditionEvaluatorPlatform
  { platformConditionEvaluatorPlatformOs = Nothing
  , platformConditionEvaluatorPlatformType = Nothing
  }

-- ** PlatformConditionEvaluatorPlatformOperatingSystem
-- | PlatformConditionEvaluatorPlatformOperatingSystem
data PlatformConditionEvaluatorPlatformOperatingSystem = PlatformConditionEvaluatorPlatformOperatingSystem
  { platformConditionEvaluatorPlatformOperatingSystemExpression :: !(Maybe Text) -- ^ "expression"
  , platformConditionEvaluatorPlatformOperatingSystemType :: !(Maybe E'Type7) -- ^ "type"
  , platformConditionEvaluatorPlatformOperatingSystemVersion :: !(Maybe PlatformConditionEvaluatorPlatformOperatingSystemVersion) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlatformConditionEvaluatorPlatformOperatingSystem
instance A.FromJSON PlatformConditionEvaluatorPlatformOperatingSystem where
  parseJSON = A.withObject "PlatformConditionEvaluatorPlatformOperatingSystem" $ \o ->
    PlatformConditionEvaluatorPlatformOperatingSystem
      <$> (o .:? "expression")
      <*> (o .:? "type")
      <*> (o .:? "version")

-- | ToJSON PlatformConditionEvaluatorPlatformOperatingSystem
instance A.ToJSON PlatformConditionEvaluatorPlatformOperatingSystem where
  toJSON PlatformConditionEvaluatorPlatformOperatingSystem {..} =
   _omitNulls
      [ "expression" .= platformConditionEvaluatorPlatformOperatingSystemExpression
      , "type" .= platformConditionEvaluatorPlatformOperatingSystemType
      , "version" .= platformConditionEvaluatorPlatformOperatingSystemVersion
      ]


-- | Construct a value of type 'PlatformConditionEvaluatorPlatformOperatingSystem' (by applying it's required fields, if any)
mkPlatformConditionEvaluatorPlatformOperatingSystem
  :: PlatformConditionEvaluatorPlatformOperatingSystem
mkPlatformConditionEvaluatorPlatformOperatingSystem =
  PlatformConditionEvaluatorPlatformOperatingSystem
  { platformConditionEvaluatorPlatformOperatingSystemExpression = Nothing
  , platformConditionEvaluatorPlatformOperatingSystemType = Nothing
  , platformConditionEvaluatorPlatformOperatingSystemVersion = Nothing
  }

-- ** PlatformConditionEvaluatorPlatformOperatingSystemVersion
-- | PlatformConditionEvaluatorPlatformOperatingSystemVersion
data PlatformConditionEvaluatorPlatformOperatingSystemVersion = PlatformConditionEvaluatorPlatformOperatingSystemVersion
  { platformConditionEvaluatorPlatformOperatingSystemVersionMatchType :: !(Maybe E'MatchType) -- ^ "matchType"
  , platformConditionEvaluatorPlatformOperatingSystemVersionValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlatformConditionEvaluatorPlatformOperatingSystemVersion
instance A.FromJSON PlatformConditionEvaluatorPlatformOperatingSystemVersion where
  parseJSON = A.withObject "PlatformConditionEvaluatorPlatformOperatingSystemVersion" $ \o ->
    PlatformConditionEvaluatorPlatformOperatingSystemVersion
      <$> (o .:? "matchType")
      <*> (o .:? "value")

-- | ToJSON PlatformConditionEvaluatorPlatformOperatingSystemVersion
instance A.ToJSON PlatformConditionEvaluatorPlatformOperatingSystemVersion where
  toJSON PlatformConditionEvaluatorPlatformOperatingSystemVersion {..} =
   _omitNulls
      [ "matchType" .= platformConditionEvaluatorPlatformOperatingSystemVersionMatchType
      , "value" .= platformConditionEvaluatorPlatformOperatingSystemVersionValue
      ]


-- | Construct a value of type 'PlatformConditionEvaluatorPlatformOperatingSystemVersion' (by applying it's required fields, if any)
mkPlatformConditionEvaluatorPlatformOperatingSystemVersion
  :: PlatformConditionEvaluatorPlatformOperatingSystemVersion
mkPlatformConditionEvaluatorPlatformOperatingSystemVersion =
  PlatformConditionEvaluatorPlatformOperatingSystemVersion
  { platformConditionEvaluatorPlatformOperatingSystemVersionMatchType = Nothing
  , platformConditionEvaluatorPlatformOperatingSystemVersionValue = Nothing
  }

-- ** PlatformPolicyRuleCondition
-- | PlatformPolicyRuleCondition
data PlatformPolicyRuleCondition = PlatformPolicyRuleCondition
  { platformPolicyRuleConditionExclude :: !(Maybe [PlatformConditionEvaluatorPlatform]) -- ^ "exclude"
  , platformPolicyRuleConditionInclude :: !(Maybe [PlatformConditionEvaluatorPlatform]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PlatformPolicyRuleCondition
instance A.FromJSON PlatformPolicyRuleCondition where
  parseJSON = A.withObject "PlatformPolicyRuleCondition" $ \o ->
    PlatformPolicyRuleCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON PlatformPolicyRuleCondition
instance A.ToJSON PlatformPolicyRuleCondition where
  toJSON PlatformPolicyRuleCondition {..} =
   _omitNulls
      [ "exclude" .= platformPolicyRuleConditionExclude
      , "include" .= platformPolicyRuleConditionInclude
      ]


-- | Construct a value of type 'PlatformPolicyRuleCondition' (by applying it's required fields, if any)
mkPlatformPolicyRuleCondition
  :: PlatformPolicyRuleCondition
mkPlatformPolicyRuleCondition =
  PlatformPolicyRuleCondition
  { platformPolicyRuleConditionExclude = Nothing
  , platformPolicyRuleConditionInclude = Nothing
  }

-- ** Policy
-- | Policy
data Policy = Policy
  { policyEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , policyLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , policyConditions :: !(Maybe PolicyRuleConditions) -- ^ "conditions"
  , policyCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , policyDescription :: !(Maybe Text) -- ^ "description"
  , policyId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , policyLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , policyName :: !(Maybe Text) -- ^ "name"
  , policyPriority :: !(Maybe Int) -- ^ "priority"
  , policyStatus :: !(Maybe E'Status2) -- ^ "status"
  , policySystem :: !(Maybe Bool) -- ^ "system"
  , policyType :: !(Maybe PolicyType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Policy
instance A.FromJSON Policy where
  parseJSON = A.withObject "Policy" $ \o ->
    Policy
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "conditions")
      <*> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "priority")
      <*> (o .:? "status")
      <*> (o .:? "system")
      <*> (o .:? "type")

-- | ToJSON Policy
instance A.ToJSON Policy where
  toJSON Policy {..} =
   _omitNulls
      [ "_embedded" .= policyEmbedded
      , "_links" .= policyLinks
      , "conditions" .= policyConditions
      , "created" .= policyCreated
      , "description" .= policyDescription
      , "id" .= policyId
      , "lastUpdated" .= policyLastUpdated
      , "name" .= policyName
      , "priority" .= policyPriority
      , "status" .= policyStatus
      , "system" .= policySystem
      , "type" .= policyType
      ]


-- | Construct a value of type 'Policy' (by applying it's required fields, if any)
mkPolicy
  :: Policy
mkPolicy =
  Policy
  { policyEmbedded = Nothing
  , policyLinks = Nothing
  , policyConditions = Nothing
  , policyCreated = Nothing
  , policyDescription = Nothing
  , policyId = Nothing
  , policyLastUpdated = Nothing
  , policyName = Nothing
  , policyPriority = Nothing
  , policyStatus = Nothing
  , policySystem = Nothing
  , policyType = Nothing
  }

-- ** PolicyAccountLink
-- | PolicyAccountLink
data PolicyAccountLink = PolicyAccountLink
  { policyAccountLinkAction :: !(Maybe E'Action) -- ^ "action"
  , policyAccountLinkFilter :: !(Maybe PolicyAccountLinkFilter) -- ^ "filter"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyAccountLink
instance A.FromJSON PolicyAccountLink where
  parseJSON = A.withObject "PolicyAccountLink" $ \o ->
    PolicyAccountLink
      <$> (o .:? "action")
      <*> (o .:? "filter")

-- | ToJSON PolicyAccountLink
instance A.ToJSON PolicyAccountLink where
  toJSON PolicyAccountLink {..} =
   _omitNulls
      [ "action" .= policyAccountLinkAction
      , "filter" .= policyAccountLinkFilter
      ]


-- | Construct a value of type 'PolicyAccountLink' (by applying it's required fields, if any)
mkPolicyAccountLink
  :: PolicyAccountLink
mkPolicyAccountLink =
  PolicyAccountLink
  { policyAccountLinkAction = Nothing
  , policyAccountLinkFilter = Nothing
  }

-- ** PolicyAccountLinkFilter
-- | PolicyAccountLinkFilter
data PolicyAccountLinkFilter = PolicyAccountLinkFilter
  { policyAccountLinkFilterGroups :: !(Maybe PolicyAccountLinkFilterGroups) -- ^ "groups"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyAccountLinkFilter
instance A.FromJSON PolicyAccountLinkFilter where
  parseJSON = A.withObject "PolicyAccountLinkFilter" $ \o ->
    PolicyAccountLinkFilter
      <$> (o .:? "groups")

-- | ToJSON PolicyAccountLinkFilter
instance A.ToJSON PolicyAccountLinkFilter where
  toJSON PolicyAccountLinkFilter {..} =
   _omitNulls
      [ "groups" .= policyAccountLinkFilterGroups
      ]


-- | Construct a value of type 'PolicyAccountLinkFilter' (by applying it's required fields, if any)
mkPolicyAccountLinkFilter
  :: PolicyAccountLinkFilter
mkPolicyAccountLinkFilter =
  PolicyAccountLinkFilter
  { policyAccountLinkFilterGroups = Nothing
  }

-- ** PolicyAccountLinkFilterGroups
-- | PolicyAccountLinkFilterGroups
data PolicyAccountLinkFilterGroups = PolicyAccountLinkFilterGroups
  { policyAccountLinkFilterGroupsInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyAccountLinkFilterGroups
instance A.FromJSON PolicyAccountLinkFilterGroups where
  parseJSON = A.withObject "PolicyAccountLinkFilterGroups" $ \o ->
    PolicyAccountLinkFilterGroups
      <$> (o .:? "include")

-- | ToJSON PolicyAccountLinkFilterGroups
instance A.ToJSON PolicyAccountLinkFilterGroups where
  toJSON PolicyAccountLinkFilterGroups {..} =
   _omitNulls
      [ "include" .= policyAccountLinkFilterGroupsInclude
      ]


-- | Construct a value of type 'PolicyAccountLinkFilterGroups' (by applying it's required fields, if any)
mkPolicyAccountLinkFilterGroups
  :: PolicyAccountLinkFilterGroups
mkPolicyAccountLinkFilterGroups =
  PolicyAccountLinkFilterGroups
  { policyAccountLinkFilterGroupsInclude = Nothing
  }

-- ** PolicyNetworkCondition
-- | PolicyNetworkCondition
data PolicyNetworkCondition = PolicyNetworkCondition
  { policyNetworkConditionConnection :: !(Maybe E'Connection) -- ^ "connection"
  , policyNetworkConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , policyNetworkConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyNetworkCondition
instance A.FromJSON PolicyNetworkCondition where
  parseJSON = A.withObject "PolicyNetworkCondition" $ \o ->
    PolicyNetworkCondition
      <$> (o .:? "connection")
      <*> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON PolicyNetworkCondition
instance A.ToJSON PolicyNetworkCondition where
  toJSON PolicyNetworkCondition {..} =
   _omitNulls
      [ "connection" .= policyNetworkConditionConnection
      , "exclude" .= policyNetworkConditionExclude
      , "include" .= policyNetworkConditionInclude
      ]


-- | Construct a value of type 'PolicyNetworkCondition' (by applying it's required fields, if any)
mkPolicyNetworkCondition
  :: PolicyNetworkCondition
mkPolicyNetworkCondition =
  PolicyNetworkCondition
  { policyNetworkConditionConnection = Nothing
  , policyNetworkConditionExclude = Nothing
  , policyNetworkConditionInclude = Nothing
  }

-- ** PolicyPeopleCondition
-- | PolicyPeopleCondition
data PolicyPeopleCondition = PolicyPeopleCondition
  { policyPeopleConditionGroups :: !(Maybe GroupCondition) -- ^ "groups"
  , policyPeopleConditionUsers :: !(Maybe UserCondition) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyPeopleCondition
instance A.FromJSON PolicyPeopleCondition where
  parseJSON = A.withObject "PolicyPeopleCondition" $ \o ->
    PolicyPeopleCondition
      <$> (o .:? "groups")
      <*> (o .:? "users")

-- | ToJSON PolicyPeopleCondition
instance A.ToJSON PolicyPeopleCondition where
  toJSON PolicyPeopleCondition {..} =
   _omitNulls
      [ "groups" .= policyPeopleConditionGroups
      , "users" .= policyPeopleConditionUsers
      ]


-- | Construct a value of type 'PolicyPeopleCondition' (by applying it's required fields, if any)
mkPolicyPeopleCondition
  :: PolicyPeopleCondition
mkPolicyPeopleCondition =
  PolicyPeopleCondition
  { policyPeopleConditionGroups = Nothing
  , policyPeopleConditionUsers = Nothing
  }

-- ** PolicyRule
-- | PolicyRule
data PolicyRule = PolicyRule
  { policyRuleCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , policyRuleId :: !(Maybe Text) -- ^ "id"
  , policyRuleLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , policyRulePriority :: !(Maybe Int) -- ^ "priority"
  , policyRuleStatus :: !(Maybe E'Status2) -- ^ "status"
  , policyRuleSystem :: !(Maybe Bool) -- ^ "system"
  , policyRuleType :: !(Maybe E'Type8) -- ^ "type"
  , policyRuleName :: !(Maybe Text) -- ^ "name"
  , policyRuleConditions :: !(Maybe PolicyRuleConditions) -- ^ "conditions"
  , policyRuleActions :: !(Maybe PolicyRuleActions) -- ^ "actions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyRule
instance A.FromJSON PolicyRule where
  parseJSON = A.withObject "PolicyRule" $ \o ->
    PolicyRule
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "priority")
      <*> (o .:? "status")
      <*> (o .:? "system")
      <*> (o .:? "type")
      <*> (o .:? "name")
      <*> (o .:? "conditions")
      <*> (o .:? "actions")

-- | ToJSON PolicyRule
instance A.ToJSON PolicyRule where
  toJSON PolicyRule {..} =
   _omitNulls
      [ "created" .= policyRuleCreated
      , "id" .= policyRuleId
      , "lastUpdated" .= policyRuleLastUpdated
      , "priority" .= policyRulePriority
      , "status" .= policyRuleStatus
      , "system" .= policyRuleSystem
      , "type" .= policyRuleType
      , "name" .= policyRuleName
      , "conditions" .= policyRuleConditions
      , "actions" .= policyRuleActions
      ]


-- | Construct a value of type 'PolicyRule' (by applying it's required fields, if any)
mkPolicyRule
  :: PolicyRule
mkPolicyRule =
  PolicyRule
  { policyRuleCreated = Nothing
  , policyRuleId = Nothing
  , policyRuleLastUpdated = Nothing
  , policyRulePriority = Nothing
  , policyRuleStatus = Nothing
  , policyRuleSystem = Nothing
  , policyRuleType = Nothing
  , policyRuleName = Nothing
  , policyRuleConditions = Nothing
  , policyRuleActions = Nothing
  }

-- ** PolicyRuleActions
-- | PolicyRuleActions
data PolicyRuleActions = PolicyRuleActions
  { policyRuleActionsEnroll :: !(Maybe PolicyRuleActionsEnroll) -- ^ "enroll"
  , policyRuleActionsSignon :: !(Maybe OktaSignOnPolicyRuleSignonActions) -- ^ "signon"
  , policyRuleActionsPasswordChange :: !(Maybe PasswordPolicyRuleAction) -- ^ "passwordChange"
  , policyRuleActionsSelfServicePasswordReset :: !(Maybe PasswordPolicyRuleAction) -- ^ "selfServicePasswordReset"
  , policyRuleActionsSelfServiceUnlock :: !(Maybe PasswordPolicyRuleAction) -- ^ "selfServiceUnlock"
  , policyRuleActionsIdp :: !(Maybe IdpPolicyRuleAction) -- ^ "idp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyRuleActions
instance A.FromJSON PolicyRuleActions where
  parseJSON = A.withObject "PolicyRuleActions" $ \o ->
    PolicyRuleActions
      <$> (o .:? "enroll")
      <*> (o .:? "signon")
      <*> (o .:? "passwordChange")
      <*> (o .:? "selfServicePasswordReset")
      <*> (o .:? "selfServiceUnlock")
      <*> (o .:? "idp")

-- | ToJSON PolicyRuleActions
instance A.ToJSON PolicyRuleActions where
  toJSON PolicyRuleActions {..} =
   _omitNulls
      [ "enroll" .= policyRuleActionsEnroll
      , "signon" .= policyRuleActionsSignon
      , "passwordChange" .= policyRuleActionsPasswordChange
      , "selfServicePasswordReset" .= policyRuleActionsSelfServicePasswordReset
      , "selfServiceUnlock" .= policyRuleActionsSelfServiceUnlock
      , "idp" .= policyRuleActionsIdp
      ]


-- | Construct a value of type 'PolicyRuleActions' (by applying it's required fields, if any)
mkPolicyRuleActions
  :: PolicyRuleActions
mkPolicyRuleActions =
  PolicyRuleActions
  { policyRuleActionsEnroll = Nothing
  , policyRuleActionsSignon = Nothing
  , policyRuleActionsPasswordChange = Nothing
  , policyRuleActionsSelfServicePasswordReset = Nothing
  , policyRuleActionsSelfServiceUnlock = Nothing
  , policyRuleActionsIdp = Nothing
  }

-- ** PolicyRuleActionsEnroll
-- | PolicyRuleActionsEnroll
data PolicyRuleActionsEnroll = PolicyRuleActionsEnroll
  { policyRuleActionsEnrollSelf :: !(Maybe PolicyRuleActionsEnrollSelf) -- ^ "self"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyRuleActionsEnroll
instance A.FromJSON PolicyRuleActionsEnroll where
  parseJSON = A.withObject "PolicyRuleActionsEnroll" $ \o ->
    PolicyRuleActionsEnroll
      <$> (o .:? "self")

-- | ToJSON PolicyRuleActionsEnroll
instance A.ToJSON PolicyRuleActionsEnroll where
  toJSON PolicyRuleActionsEnroll {..} =
   _omitNulls
      [ "self" .= policyRuleActionsEnrollSelf
      ]


-- | Construct a value of type 'PolicyRuleActionsEnroll' (by applying it's required fields, if any)
mkPolicyRuleActionsEnroll
  :: PolicyRuleActionsEnroll
mkPolicyRuleActionsEnroll =
  PolicyRuleActionsEnroll
  { policyRuleActionsEnrollSelf = Nothing
  }

-- ** PolicyRuleAuthContextCondition
-- | PolicyRuleAuthContextCondition
data PolicyRuleAuthContextCondition = PolicyRuleAuthContextCondition
  { policyRuleAuthContextConditionAuthType :: !(Maybe E'AuthType) -- ^ "authType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyRuleAuthContextCondition
instance A.FromJSON PolicyRuleAuthContextCondition where
  parseJSON = A.withObject "PolicyRuleAuthContextCondition" $ \o ->
    PolicyRuleAuthContextCondition
      <$> (o .:? "authType")

-- | ToJSON PolicyRuleAuthContextCondition
instance A.ToJSON PolicyRuleAuthContextCondition where
  toJSON PolicyRuleAuthContextCondition {..} =
   _omitNulls
      [ "authType" .= policyRuleAuthContextConditionAuthType
      ]


-- | Construct a value of type 'PolicyRuleAuthContextCondition' (by applying it's required fields, if any)
mkPolicyRuleAuthContextCondition
  :: PolicyRuleAuthContextCondition
mkPolicyRuleAuthContextCondition =
  PolicyRuleAuthContextCondition
  { policyRuleAuthContextConditionAuthType = Nothing
  }

-- ** PolicyRuleConditions
-- | PolicyRuleConditions
data PolicyRuleConditions = PolicyRuleConditions
  { policyRuleConditionsApp :: !(Maybe AppAndInstancePolicyRuleCondition) -- ^ "app"
  , policyRuleConditionsApps :: !(Maybe AppInstancePolicyRuleCondition) -- ^ "apps"
  , policyRuleConditionsAuthContext :: !(Maybe PolicyRuleAuthContextCondition) -- ^ "authContext"
  , policyRuleConditionsAuthProvider :: !(Maybe PasswordPolicyAuthenticationProviderCondition) -- ^ "authProvider"
  , policyRuleConditionsBeforeScheduledAction :: !(Maybe BeforeScheduledActionPolicyRuleCondition) -- ^ "beforeScheduledAction"
  , policyRuleConditionsClients :: !(Maybe ClientPolicyCondition) -- ^ "clients"
  , policyRuleConditionsContext :: !(Maybe ContextPolicyRuleCondition) -- ^ "context"
  , policyRuleConditionsDevice :: !(Maybe DevicePolicyRuleCondition) -- ^ "device"
  , policyRuleConditionsGrantTypes :: !(Maybe GrantTypePolicyRuleCondition) -- ^ "grantTypes"
  , policyRuleConditionsGroups :: !(Maybe GroupPolicyRuleCondition) -- ^ "groups"
  , policyRuleConditionsIdentityProvider :: !(Maybe IdentityProviderPolicyRuleCondition) -- ^ "identityProvider"
  , policyRuleConditionsMdmEnrollment :: !(Maybe MDMEnrollmentPolicyRuleCondition) -- ^ "mdmEnrollment"
  , policyRuleConditionsNetwork :: !(Maybe PolicyNetworkCondition) -- ^ "network"
  , policyRuleConditionsPeople :: !(Maybe PolicyPeopleCondition) -- ^ "people"
  , policyRuleConditionsPlatform :: !(Maybe PlatformPolicyRuleCondition) -- ^ "platform"
  , policyRuleConditionsRisk :: !(Maybe RiskPolicyRuleCondition) -- ^ "risk"
  , policyRuleConditionsRiskScore :: !(Maybe RiskScorePolicyRuleCondition) -- ^ "riskScore"
  , policyRuleConditionsScopes :: !(Maybe OAuth2ScopesMediationPolicyRuleCondition) -- ^ "scopes"
  , policyRuleConditionsUserIdentifier :: !(Maybe UserIdentifierPolicyRuleCondition) -- ^ "userIdentifier"
  , policyRuleConditionsUserStatus :: !(Maybe UserStatusPolicyRuleCondition) -- ^ "userStatus"
  , policyRuleConditionsUsers :: !(Maybe UserPolicyRuleCondition) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyRuleConditions
instance A.FromJSON PolicyRuleConditions where
  parseJSON = A.withObject "PolicyRuleConditions" $ \o ->
    PolicyRuleConditions
      <$> (o .:? "app")
      <*> (o .:? "apps")
      <*> (o .:? "authContext")
      <*> (o .:? "authProvider")
      <*> (o .:? "beforeScheduledAction")
      <*> (o .:? "clients")
      <*> (o .:? "context")
      <*> (o .:? "device")
      <*> (o .:? "grantTypes")
      <*> (o .:? "groups")
      <*> (o .:? "identityProvider")
      <*> (o .:? "mdmEnrollment")
      <*> (o .:? "network")
      <*> (o .:? "people")
      <*> (o .:? "platform")
      <*> (o .:? "risk")
      <*> (o .:? "riskScore")
      <*> (o .:? "scopes")
      <*> (o .:? "userIdentifier")
      <*> (o .:? "userStatus")
      <*> (o .:? "users")

-- | ToJSON PolicyRuleConditions
instance A.ToJSON PolicyRuleConditions where
  toJSON PolicyRuleConditions {..} =
   _omitNulls
      [ "app" .= policyRuleConditionsApp
      , "apps" .= policyRuleConditionsApps
      , "authContext" .= policyRuleConditionsAuthContext
      , "authProvider" .= policyRuleConditionsAuthProvider
      , "beforeScheduledAction" .= policyRuleConditionsBeforeScheduledAction
      , "clients" .= policyRuleConditionsClients
      , "context" .= policyRuleConditionsContext
      , "device" .= policyRuleConditionsDevice
      , "grantTypes" .= policyRuleConditionsGrantTypes
      , "groups" .= policyRuleConditionsGroups
      , "identityProvider" .= policyRuleConditionsIdentityProvider
      , "mdmEnrollment" .= policyRuleConditionsMdmEnrollment
      , "network" .= policyRuleConditionsNetwork
      , "people" .= policyRuleConditionsPeople
      , "platform" .= policyRuleConditionsPlatform
      , "risk" .= policyRuleConditionsRisk
      , "riskScore" .= policyRuleConditionsRiskScore
      , "scopes" .= policyRuleConditionsScopes
      , "userIdentifier" .= policyRuleConditionsUserIdentifier
      , "userStatus" .= policyRuleConditionsUserStatus
      , "users" .= policyRuleConditionsUsers
      ]


-- | Construct a value of type 'PolicyRuleConditions' (by applying it's required fields, if any)
mkPolicyRuleConditions
  :: PolicyRuleConditions
mkPolicyRuleConditions =
  PolicyRuleConditions
  { policyRuleConditionsApp = Nothing
  , policyRuleConditionsApps = Nothing
  , policyRuleConditionsAuthContext = Nothing
  , policyRuleConditionsAuthProvider = Nothing
  , policyRuleConditionsBeforeScheduledAction = Nothing
  , policyRuleConditionsClients = Nothing
  , policyRuleConditionsContext = Nothing
  , policyRuleConditionsDevice = Nothing
  , policyRuleConditionsGrantTypes = Nothing
  , policyRuleConditionsGroups = Nothing
  , policyRuleConditionsIdentityProvider = Nothing
  , policyRuleConditionsMdmEnrollment = Nothing
  , policyRuleConditionsNetwork = Nothing
  , policyRuleConditionsPeople = Nothing
  , policyRuleConditionsPlatform = Nothing
  , policyRuleConditionsRisk = Nothing
  , policyRuleConditionsRiskScore = Nothing
  , policyRuleConditionsScopes = Nothing
  , policyRuleConditionsUserIdentifier = Nothing
  , policyRuleConditionsUserStatus = Nothing
  , policyRuleConditionsUsers = Nothing
  }

-- ** PolicySubject
-- | PolicySubject
data PolicySubject = PolicySubject
  { policySubjectFilter :: !(Maybe Text) -- ^ "filter"
  , policySubjectFormat :: !(Maybe [Text]) -- ^ "format"
  , policySubjectMatchAttribute :: !(Maybe Text) -- ^ "matchAttribute"
  , policySubjectMatchType :: !(Maybe PolicySubjectMatchType) -- ^ "matchType"
  , policySubjectUserNameTemplate :: !(Maybe PolicyUserNameTemplate) -- ^ "userNameTemplate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicySubject
instance A.FromJSON PolicySubject where
  parseJSON = A.withObject "PolicySubject" $ \o ->
    PolicySubject
      <$> (o .:? "filter")
      <*> (o .:? "format")
      <*> (o .:? "matchAttribute")
      <*> (o .:? "matchType")
      <*> (o .:? "userNameTemplate")

-- | ToJSON PolicySubject
instance A.ToJSON PolicySubject where
  toJSON PolicySubject {..} =
   _omitNulls
      [ "filter" .= policySubjectFilter
      , "format" .= policySubjectFormat
      , "matchAttribute" .= policySubjectMatchAttribute
      , "matchType" .= policySubjectMatchType
      , "userNameTemplate" .= policySubjectUserNameTemplate
      ]


-- | Construct a value of type 'PolicySubject' (by applying it's required fields, if any)
mkPolicySubject
  :: PolicySubject
mkPolicySubject =
  PolicySubject
  { policySubjectFilter = Nothing
  , policySubjectFormat = Nothing
  , policySubjectMatchAttribute = Nothing
  , policySubjectMatchType = Nothing
  , policySubjectUserNameTemplate = Nothing
  }

-- ** PolicyUserNameTemplate
-- | PolicyUserNameTemplate
data PolicyUserNameTemplate = PolicyUserNameTemplate
  { policyUserNameTemplateTemplate :: !(Maybe Text) -- ^ "template"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PolicyUserNameTemplate
instance A.FromJSON PolicyUserNameTemplate where
  parseJSON = A.withObject "PolicyUserNameTemplate" $ \o ->
    PolicyUserNameTemplate
      <$> (o .:? "template")

-- | ToJSON PolicyUserNameTemplate
instance A.ToJSON PolicyUserNameTemplate where
  toJSON PolicyUserNameTemplate {..} =
   _omitNulls
      [ "template" .= policyUserNameTemplateTemplate
      ]


-- | Construct a value of type 'PolicyUserNameTemplate' (by applying it's required fields, if any)
mkPolicyUserNameTemplate
  :: PolicyUserNameTemplate
mkPolicyUserNameTemplate =
  PolicyUserNameTemplate
  { policyUserNameTemplateTemplate = Nothing
  }

-- ** PossessionConstraint
-- | PossessionConstraint
data PossessionConstraint = PossessionConstraint
  { possessionConstraintHardwareProtection :: !(Maybe Text) -- ^ "hardwareProtection"
  , possessionConstraintDeviceBound :: !(Maybe Text) -- ^ "deviceBound"
  , possessionConstraintPhishingResistant :: !(Maybe Text) -- ^ "phishingResistant"
  , possessionConstraintUserPresence :: !(Maybe Text) -- ^ "userPresence"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PossessionConstraint
instance A.FromJSON PossessionConstraint where
  parseJSON = A.withObject "PossessionConstraint" $ \o ->
    PossessionConstraint
      <$> (o .:? "hardwareProtection")
      <*> (o .:? "deviceBound")
      <*> (o .:? "phishingResistant")
      <*> (o .:? "userPresence")

-- | ToJSON PossessionConstraint
instance A.ToJSON PossessionConstraint where
  toJSON PossessionConstraint {..} =
   _omitNulls
      [ "hardwareProtection" .= possessionConstraintHardwareProtection
      , "deviceBound" .= possessionConstraintDeviceBound
      , "phishingResistant" .= possessionConstraintPhishingResistant
      , "userPresence" .= possessionConstraintUserPresence
      ]


-- | Construct a value of type 'PossessionConstraint' (by applying it's required fields, if any)
mkPossessionConstraint
  :: PossessionConstraint
mkPossessionConstraint =
  PossessionConstraint
  { possessionConstraintHardwareProtection = Nothing
  , possessionConstraintDeviceBound = Nothing
  , possessionConstraintPhishingResistant = Nothing
  , possessionConstraintUserPresence = Nothing
  }

-- ** PreRegistrationInlineHook
-- | PreRegistrationInlineHook
data PreRegistrationInlineHook = PreRegistrationInlineHook
  { preRegistrationInlineHookInlineHookId :: !(Maybe Text) -- ^ "inlineHookId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PreRegistrationInlineHook
instance A.FromJSON PreRegistrationInlineHook where
  parseJSON = A.withObject "PreRegistrationInlineHook" $ \o ->
    PreRegistrationInlineHook
      <$> (o .:? "inlineHookId")

-- | ToJSON PreRegistrationInlineHook
instance A.ToJSON PreRegistrationInlineHook where
  toJSON PreRegistrationInlineHook {..} =
   _omitNulls
      [ "inlineHookId" .= preRegistrationInlineHookInlineHookId
      ]


-- | Construct a value of type 'PreRegistrationInlineHook' (by applying it's required fields, if any)
mkPreRegistrationInlineHook
  :: PreRegistrationInlineHook
mkPreRegistrationInlineHook =
  PreRegistrationInlineHook
  { preRegistrationInlineHookInlineHookId = Nothing
  }

-- ** ProfileEnrollmentPolicyRule
-- | ProfileEnrollmentPolicyRule
data ProfileEnrollmentPolicyRule = ProfileEnrollmentPolicyRule
  { profileEnrollmentPolicyRuleActions :: !(Maybe ProfileEnrollmentPolicyRuleActions) -- ^ "actions"
  , profileEnrollmentPolicyRuleName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileEnrollmentPolicyRule
instance A.FromJSON ProfileEnrollmentPolicyRule where
  parseJSON = A.withObject "ProfileEnrollmentPolicyRule" $ \o ->
    ProfileEnrollmentPolicyRule
      <$> (o .:? "actions")
      <*> (o .:? "name")

-- | ToJSON ProfileEnrollmentPolicyRule
instance A.ToJSON ProfileEnrollmentPolicyRule where
  toJSON ProfileEnrollmentPolicyRule {..} =
   _omitNulls
      [ "actions" .= profileEnrollmentPolicyRuleActions
      , "name" .= profileEnrollmentPolicyRuleName
      ]


-- | Construct a value of type 'ProfileEnrollmentPolicyRule' (by applying it's required fields, if any)
mkProfileEnrollmentPolicyRule
  :: ProfileEnrollmentPolicyRule
mkProfileEnrollmentPolicyRule =
  ProfileEnrollmentPolicyRule
  { profileEnrollmentPolicyRuleActions = Nothing
  , profileEnrollmentPolicyRuleName = Nothing
  }

-- ** ProfileEnrollmentPolicyRuleAction
-- | ProfileEnrollmentPolicyRuleAction
data ProfileEnrollmentPolicyRuleAction = ProfileEnrollmentPolicyRuleAction
  { profileEnrollmentPolicyRuleActionAccess :: !(Maybe Text) -- ^ "access"
  , profileEnrollmentPolicyRuleActionPreRegistrationInlineHooks :: !(Maybe [PreRegistrationInlineHook]) -- ^ "preRegistrationInlineHooks"
  , profileEnrollmentPolicyRuleActionProfileAttributes :: !(Maybe [ProfileEnrollmentPolicyRuleProfileAttribute]) -- ^ "profileAttributes"
  , profileEnrollmentPolicyRuleActionActivationRequirements :: !(Maybe ProfileEnrollmentPolicyRuleActivationRequirement) -- ^ "activationRequirements"
  , profileEnrollmentPolicyRuleActionTargetGroupIds :: !(Maybe [Text]) -- ^ "targetGroupIds"
  , profileEnrollmentPolicyRuleActionUnknownUserAction :: !(Maybe Text) -- ^ "unknownUserAction"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileEnrollmentPolicyRuleAction
instance A.FromJSON ProfileEnrollmentPolicyRuleAction where
  parseJSON = A.withObject "ProfileEnrollmentPolicyRuleAction" $ \o ->
    ProfileEnrollmentPolicyRuleAction
      <$> (o .:? "access")
      <*> (o .:? "preRegistrationInlineHooks")
      <*> (o .:? "profileAttributes")
      <*> (o .:? "activationRequirements")
      <*> (o .:? "targetGroupIds")
      <*> (o .:? "unknownUserAction")

-- | ToJSON ProfileEnrollmentPolicyRuleAction
instance A.ToJSON ProfileEnrollmentPolicyRuleAction where
  toJSON ProfileEnrollmentPolicyRuleAction {..} =
   _omitNulls
      [ "access" .= profileEnrollmentPolicyRuleActionAccess
      , "preRegistrationInlineHooks" .= profileEnrollmentPolicyRuleActionPreRegistrationInlineHooks
      , "profileAttributes" .= profileEnrollmentPolicyRuleActionProfileAttributes
      , "activationRequirements" .= profileEnrollmentPolicyRuleActionActivationRequirements
      , "targetGroupIds" .= profileEnrollmentPolicyRuleActionTargetGroupIds
      , "unknownUserAction" .= profileEnrollmentPolicyRuleActionUnknownUserAction
      ]


-- | Construct a value of type 'ProfileEnrollmentPolicyRuleAction' (by applying it's required fields, if any)
mkProfileEnrollmentPolicyRuleAction
  :: ProfileEnrollmentPolicyRuleAction
mkProfileEnrollmentPolicyRuleAction =
  ProfileEnrollmentPolicyRuleAction
  { profileEnrollmentPolicyRuleActionAccess = Nothing
  , profileEnrollmentPolicyRuleActionPreRegistrationInlineHooks = Nothing
  , profileEnrollmentPolicyRuleActionProfileAttributes = Nothing
  , profileEnrollmentPolicyRuleActionActivationRequirements = Nothing
  , profileEnrollmentPolicyRuleActionTargetGroupIds = Nothing
  , profileEnrollmentPolicyRuleActionUnknownUserAction = Nothing
  }

-- ** ProfileEnrollmentPolicyRuleActions
-- | ProfileEnrollmentPolicyRuleActions
data ProfileEnrollmentPolicyRuleActions = ProfileEnrollmentPolicyRuleActions
  { profileEnrollmentPolicyRuleActionsProfileEnrollment :: !(Maybe ProfileEnrollmentPolicyRuleAction) -- ^ "profileEnrollment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileEnrollmentPolicyRuleActions
instance A.FromJSON ProfileEnrollmentPolicyRuleActions where
  parseJSON = A.withObject "ProfileEnrollmentPolicyRuleActions" $ \o ->
    ProfileEnrollmentPolicyRuleActions
      <$> (o .:? "profileEnrollment")

-- | ToJSON ProfileEnrollmentPolicyRuleActions
instance A.ToJSON ProfileEnrollmentPolicyRuleActions where
  toJSON ProfileEnrollmentPolicyRuleActions {..} =
   _omitNulls
      [ "profileEnrollment" .= profileEnrollmentPolicyRuleActionsProfileEnrollment
      ]


-- | Construct a value of type 'ProfileEnrollmentPolicyRuleActions' (by applying it's required fields, if any)
mkProfileEnrollmentPolicyRuleActions
  :: ProfileEnrollmentPolicyRuleActions
mkProfileEnrollmentPolicyRuleActions =
  ProfileEnrollmentPolicyRuleActions
  { profileEnrollmentPolicyRuleActionsProfileEnrollment = Nothing
  }

-- ** ProfileEnrollmentPolicyRuleActivationRequirement
-- | ProfileEnrollmentPolicyRuleActivationRequirement
data ProfileEnrollmentPolicyRuleActivationRequirement = ProfileEnrollmentPolicyRuleActivationRequirement
  { profileEnrollmentPolicyRuleActivationRequirementEmailVerification :: !(Maybe Bool) -- ^ "emailVerification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileEnrollmentPolicyRuleActivationRequirement
instance A.FromJSON ProfileEnrollmentPolicyRuleActivationRequirement where
  parseJSON = A.withObject "ProfileEnrollmentPolicyRuleActivationRequirement" $ \o ->
    ProfileEnrollmentPolicyRuleActivationRequirement
      <$> (o .:? "emailVerification")

-- | ToJSON ProfileEnrollmentPolicyRuleActivationRequirement
instance A.ToJSON ProfileEnrollmentPolicyRuleActivationRequirement where
  toJSON ProfileEnrollmentPolicyRuleActivationRequirement {..} =
   _omitNulls
      [ "emailVerification" .= profileEnrollmentPolicyRuleActivationRequirementEmailVerification
      ]


-- | Construct a value of type 'ProfileEnrollmentPolicyRuleActivationRequirement' (by applying it's required fields, if any)
mkProfileEnrollmentPolicyRuleActivationRequirement
  :: ProfileEnrollmentPolicyRuleActivationRequirement
mkProfileEnrollmentPolicyRuleActivationRequirement =
  ProfileEnrollmentPolicyRuleActivationRequirement
  { profileEnrollmentPolicyRuleActivationRequirementEmailVerification = Nothing
  }

-- ** ProfileEnrollmentPolicyRuleProfileAttribute
-- | ProfileEnrollmentPolicyRuleProfileAttribute
data ProfileEnrollmentPolicyRuleProfileAttribute = ProfileEnrollmentPolicyRuleProfileAttribute
  { profileEnrollmentPolicyRuleProfileAttributeLabel :: !(Maybe Text) -- ^ "label"
  , profileEnrollmentPolicyRuleProfileAttributeName :: !(Maybe Text) -- ^ "name"
  , profileEnrollmentPolicyRuleProfileAttributeRequired :: !(Maybe Bool) -- ^ "required"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileEnrollmentPolicyRuleProfileAttribute
instance A.FromJSON ProfileEnrollmentPolicyRuleProfileAttribute where
  parseJSON = A.withObject "ProfileEnrollmentPolicyRuleProfileAttribute" $ \o ->
    ProfileEnrollmentPolicyRuleProfileAttribute
      <$> (o .:? "label")
      <*> (o .:? "name")
      <*> (o .:? "required")

-- | ToJSON ProfileEnrollmentPolicyRuleProfileAttribute
instance A.ToJSON ProfileEnrollmentPolicyRuleProfileAttribute where
  toJSON ProfileEnrollmentPolicyRuleProfileAttribute {..} =
   _omitNulls
      [ "label" .= profileEnrollmentPolicyRuleProfileAttributeLabel
      , "name" .= profileEnrollmentPolicyRuleProfileAttributeName
      , "required" .= profileEnrollmentPolicyRuleProfileAttributeRequired
      ]


-- | Construct a value of type 'ProfileEnrollmentPolicyRuleProfileAttribute' (by applying it's required fields, if any)
mkProfileEnrollmentPolicyRuleProfileAttribute
  :: ProfileEnrollmentPolicyRuleProfileAttribute
mkProfileEnrollmentPolicyRuleProfileAttribute =
  ProfileEnrollmentPolicyRuleProfileAttribute
  { profileEnrollmentPolicyRuleProfileAttributeLabel = Nothing
  , profileEnrollmentPolicyRuleProfileAttributeName = Nothing
  , profileEnrollmentPolicyRuleProfileAttributeRequired = Nothing
  }

-- ** ProfileMapping
-- | ProfileMapping
data ProfileMapping = ProfileMapping
  { profileMappingLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , profileMappingId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , profileMappingProperties :: !(Maybe (Map.Map String ProfileMappingProperty)) -- ^ /ReadOnly/ "properties"
  , profileMappingSource :: !(Maybe ProfileMappingSource) -- ^ "source"
  , profileMappingTarget :: !(Maybe ProfileMappingSource) -- ^ "target"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileMapping
instance A.FromJSON ProfileMapping where
  parseJSON = A.withObject "ProfileMapping" $ \o ->
    ProfileMapping
      <$> (o .:? "_links")
      <*> (o .:? "id")
      <*> (o .:? "properties")
      <*> (o .:? "source")
      <*> (o .:? "target")

-- | ToJSON ProfileMapping
instance A.ToJSON ProfileMapping where
  toJSON ProfileMapping {..} =
   _omitNulls
      [ "_links" .= profileMappingLinks
      , "id" .= profileMappingId
      , "properties" .= profileMappingProperties
      , "source" .= profileMappingSource
      , "target" .= profileMappingTarget
      ]


-- | Construct a value of type 'ProfileMapping' (by applying it's required fields, if any)
mkProfileMapping
  :: ProfileMapping
mkProfileMapping =
  ProfileMapping
  { profileMappingLinks = Nothing
  , profileMappingId = Nothing
  , profileMappingProperties = Nothing
  , profileMappingSource = Nothing
  , profileMappingTarget = Nothing
  }

-- ** ProfileMappingProperty
-- | ProfileMappingProperty
data ProfileMappingProperty = ProfileMappingProperty
  { profileMappingPropertyExpression :: !(Maybe Text) -- ^ "expression"
  , profileMappingPropertyPushStatus :: !(Maybe ProfileMappingPropertyPushStatus) -- ^ "pushStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileMappingProperty
instance A.FromJSON ProfileMappingProperty where
  parseJSON = A.withObject "ProfileMappingProperty" $ \o ->
    ProfileMappingProperty
      <$> (o .:? "expression")
      <*> (o .:? "pushStatus")

-- | ToJSON ProfileMappingProperty
instance A.ToJSON ProfileMappingProperty where
  toJSON ProfileMappingProperty {..} =
   _omitNulls
      [ "expression" .= profileMappingPropertyExpression
      , "pushStatus" .= profileMappingPropertyPushStatus
      ]


-- | Construct a value of type 'ProfileMappingProperty' (by applying it's required fields, if any)
mkProfileMappingProperty
  :: ProfileMappingProperty
mkProfileMappingProperty =
  ProfileMappingProperty
  { profileMappingPropertyExpression = Nothing
  , profileMappingPropertyPushStatus = Nothing
  }

-- ** ProfileMappingPropertyPushStatus
-- | ProfileMappingPropertyPushStatus
data ProfileMappingPropertyPushStatus = ProfileMappingPropertyPushStatus
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileMappingPropertyPushStatus
instance A.FromJSON ProfileMappingPropertyPushStatus where
  parseJSON = A.withObject "ProfileMappingPropertyPushStatus" $ \o ->
    pure ProfileMappingPropertyPushStatus
      

-- | ToJSON ProfileMappingPropertyPushStatus
instance A.ToJSON ProfileMappingPropertyPushStatus where
  toJSON ProfileMappingPropertyPushStatus  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'ProfileMappingPropertyPushStatus' (by applying it's required fields, if any)
mkProfileMappingPropertyPushStatus
  :: ProfileMappingPropertyPushStatus
mkProfileMappingPropertyPushStatus =
  ProfileMappingPropertyPushStatus
  { 
  }

-- ** ProfileMappingSource
-- | ProfileMappingSource
data ProfileMappingSource = ProfileMappingSource
  { profileMappingSourceLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , profileMappingSourceId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , profileMappingSourceName :: !(Maybe Text) -- ^ /ReadOnly/ "name"
  , profileMappingSourceType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileMappingSource
instance A.FromJSON ProfileMappingSource where
  parseJSON = A.withObject "ProfileMappingSource" $ \o ->
    ProfileMappingSource
      <$> (o .:? "_links")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON ProfileMappingSource
instance A.ToJSON ProfileMappingSource where
  toJSON ProfileMappingSource {..} =
   _omitNulls
      [ "_links" .= profileMappingSourceLinks
      , "id" .= profileMappingSourceId
      , "name" .= profileMappingSourceName
      , "type" .= profileMappingSourceType
      ]


-- | Construct a value of type 'ProfileMappingSource' (by applying it's required fields, if any)
mkProfileMappingSource
  :: ProfileMappingSource
mkProfileMappingSource =
  ProfileMappingSource
  { profileMappingSourceLinks = Nothing
  , profileMappingSourceId = Nothing
  , profileMappingSourceName = Nothing
  , profileMappingSourceType = Nothing
  }

-- ** ProfileSettingObject
-- | ProfileSettingObject
data ProfileSettingObject = ProfileSettingObject
  { profileSettingObjectStatus :: !(Maybe EnabledStatus) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProfileSettingObject
instance A.FromJSON ProfileSettingObject where
  parseJSON = A.withObject "ProfileSettingObject" $ \o ->
    ProfileSettingObject
      <$> (o .:? "status")

-- | ToJSON ProfileSettingObject
instance A.ToJSON ProfileSettingObject where
  toJSON ProfileSettingObject {..} =
   _omitNulls
      [ "status" .= profileSettingObjectStatus
      ]


-- | Construct a value of type 'ProfileSettingObject' (by applying it's required fields, if any)
mkProfileSettingObject
  :: ProfileSettingObject
mkProfileSettingObject =
  ProfileSettingObject
  { profileSettingObjectStatus = Nothing
  }

-- ** Protocol
-- | Protocol
data Protocol = Protocol
  { protocolAlgorithms :: !(Maybe ProtocolAlgorithms) -- ^ "algorithms"
  , protocolCredentials :: !(Maybe IdentityProviderCredentials) -- ^ "credentials"
  , protocolEndpoints :: !(Maybe ProtocolEndpoints) -- ^ "endpoints"
  , protocolIssuer :: !(Maybe ProtocolEndpoint) -- ^ "issuer"
  , protocolRelayState :: !(Maybe ProtocolRelayState) -- ^ "relayState"
  , protocolScopes :: !(Maybe [Text]) -- ^ "scopes"
  , protocolSettings :: !(Maybe ProtocolSettings) -- ^ "settings"
  , protocolType :: !(Maybe E'Type9) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Protocol
instance A.FromJSON Protocol where
  parseJSON = A.withObject "Protocol" $ \o ->
    Protocol
      <$> (o .:? "algorithms")
      <*> (o .:? "credentials")
      <*> (o .:? "endpoints")
      <*> (o .:? "issuer")
      <*> (o .:? "relayState")
      <*> (o .:? "scopes")
      <*> (o .:? "settings")
      <*> (o .:? "type")

-- | ToJSON Protocol
instance A.ToJSON Protocol where
  toJSON Protocol {..} =
   _omitNulls
      [ "algorithms" .= protocolAlgorithms
      , "credentials" .= protocolCredentials
      , "endpoints" .= protocolEndpoints
      , "issuer" .= protocolIssuer
      , "relayState" .= protocolRelayState
      , "scopes" .= protocolScopes
      , "settings" .= protocolSettings
      , "type" .= protocolType
      ]


-- | Construct a value of type 'Protocol' (by applying it's required fields, if any)
mkProtocol
  :: Protocol
mkProtocol =
  Protocol
  { protocolAlgorithms = Nothing
  , protocolCredentials = Nothing
  , protocolEndpoints = Nothing
  , protocolIssuer = Nothing
  , protocolRelayState = Nothing
  , protocolScopes = Nothing
  , protocolSettings = Nothing
  , protocolType = Nothing
  }

-- ** ProtocolAlgorithmType
-- | ProtocolAlgorithmType
data ProtocolAlgorithmType = ProtocolAlgorithmType
  { protocolAlgorithmTypeSignature :: !(Maybe ProtocolAlgorithmTypeSignature) -- ^ "signature"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolAlgorithmType
instance A.FromJSON ProtocolAlgorithmType where
  parseJSON = A.withObject "ProtocolAlgorithmType" $ \o ->
    ProtocolAlgorithmType
      <$> (o .:? "signature")

-- | ToJSON ProtocolAlgorithmType
instance A.ToJSON ProtocolAlgorithmType where
  toJSON ProtocolAlgorithmType {..} =
   _omitNulls
      [ "signature" .= protocolAlgorithmTypeSignature
      ]


-- | Construct a value of type 'ProtocolAlgorithmType' (by applying it's required fields, if any)
mkProtocolAlgorithmType
  :: ProtocolAlgorithmType
mkProtocolAlgorithmType =
  ProtocolAlgorithmType
  { protocolAlgorithmTypeSignature = Nothing
  }

-- ** ProtocolAlgorithmTypeSignature
-- | ProtocolAlgorithmTypeSignature
data ProtocolAlgorithmTypeSignature = ProtocolAlgorithmTypeSignature
  { protocolAlgorithmTypeSignatureAlgorithm :: !(Maybe Text) -- ^ "algorithm"
  , protocolAlgorithmTypeSignatureScope :: !(Maybe E'Scope) -- ^ "scope"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolAlgorithmTypeSignature
instance A.FromJSON ProtocolAlgorithmTypeSignature where
  parseJSON = A.withObject "ProtocolAlgorithmTypeSignature" $ \o ->
    ProtocolAlgorithmTypeSignature
      <$> (o .:? "algorithm")
      <*> (o .:? "scope")

-- | ToJSON ProtocolAlgorithmTypeSignature
instance A.ToJSON ProtocolAlgorithmTypeSignature where
  toJSON ProtocolAlgorithmTypeSignature {..} =
   _omitNulls
      [ "algorithm" .= protocolAlgorithmTypeSignatureAlgorithm
      , "scope" .= protocolAlgorithmTypeSignatureScope
      ]


-- | Construct a value of type 'ProtocolAlgorithmTypeSignature' (by applying it's required fields, if any)
mkProtocolAlgorithmTypeSignature
  :: ProtocolAlgorithmTypeSignature
mkProtocolAlgorithmTypeSignature =
  ProtocolAlgorithmTypeSignature
  { protocolAlgorithmTypeSignatureAlgorithm = Nothing
  , protocolAlgorithmTypeSignatureScope = Nothing
  }

-- ** ProtocolAlgorithms
-- | ProtocolAlgorithms
data ProtocolAlgorithms = ProtocolAlgorithms
  { protocolAlgorithmsRequest :: !(Maybe ProtocolAlgorithmType) -- ^ "request"
  , protocolAlgorithmsResponse :: !(Maybe ProtocolAlgorithmType) -- ^ "response"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolAlgorithms
instance A.FromJSON ProtocolAlgorithms where
  parseJSON = A.withObject "ProtocolAlgorithms" $ \o ->
    ProtocolAlgorithms
      <$> (o .:? "request")
      <*> (o .:? "response")

-- | ToJSON ProtocolAlgorithms
instance A.ToJSON ProtocolAlgorithms where
  toJSON ProtocolAlgorithms {..} =
   _omitNulls
      [ "request" .= protocolAlgorithmsRequest
      , "response" .= protocolAlgorithmsResponse
      ]


-- | Construct a value of type 'ProtocolAlgorithms' (by applying it's required fields, if any)
mkProtocolAlgorithms
  :: ProtocolAlgorithms
mkProtocolAlgorithms =
  ProtocolAlgorithms
  { protocolAlgorithmsRequest = Nothing
  , protocolAlgorithmsResponse = Nothing
  }

-- ** ProtocolEndpoint
-- | ProtocolEndpoint
data ProtocolEndpoint = ProtocolEndpoint
  { protocolEndpointBinding :: !(Maybe E'Binding) -- ^ "binding"
  , protocolEndpointDestination :: !(Maybe Text) -- ^ "destination"
  , protocolEndpointType :: !(Maybe E'Type10) -- ^ "type"
  , protocolEndpointUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolEndpoint
instance A.FromJSON ProtocolEndpoint where
  parseJSON = A.withObject "ProtocolEndpoint" $ \o ->
    ProtocolEndpoint
      <$> (o .:? "binding")
      <*> (o .:? "destination")
      <*> (o .:? "type")
      <*> (o .:? "url")

-- | ToJSON ProtocolEndpoint
instance A.ToJSON ProtocolEndpoint where
  toJSON ProtocolEndpoint {..} =
   _omitNulls
      [ "binding" .= protocolEndpointBinding
      , "destination" .= protocolEndpointDestination
      , "type" .= protocolEndpointType
      , "url" .= protocolEndpointUrl
      ]


-- | Construct a value of type 'ProtocolEndpoint' (by applying it's required fields, if any)
mkProtocolEndpoint
  :: ProtocolEndpoint
mkProtocolEndpoint =
  ProtocolEndpoint
  { protocolEndpointBinding = Nothing
  , protocolEndpointDestination = Nothing
  , protocolEndpointType = Nothing
  , protocolEndpointUrl = Nothing
  }

-- ** ProtocolEndpoints
-- | ProtocolEndpoints
data ProtocolEndpoints = ProtocolEndpoints
  { protocolEndpointsAcs :: !(Maybe ProtocolEndpoint) -- ^ "acs"
  , protocolEndpointsAuthorization :: !(Maybe ProtocolEndpoint) -- ^ "authorization"
  , protocolEndpointsJwks :: !(Maybe ProtocolEndpoint) -- ^ "jwks"
  , protocolEndpointsMetadata :: !(Maybe ProtocolEndpoint) -- ^ "metadata"
  , protocolEndpointsSlo :: !(Maybe ProtocolEndpoint) -- ^ "slo"
  , protocolEndpointsSso :: !(Maybe ProtocolEndpoint) -- ^ "sso"
  , protocolEndpointsToken :: !(Maybe ProtocolEndpoint) -- ^ "token"
  , protocolEndpointsUserInfo :: !(Maybe ProtocolEndpoint) -- ^ "userInfo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolEndpoints
instance A.FromJSON ProtocolEndpoints where
  parseJSON = A.withObject "ProtocolEndpoints" $ \o ->
    ProtocolEndpoints
      <$> (o .:? "acs")
      <*> (o .:? "authorization")
      <*> (o .:? "jwks")
      <*> (o .:? "metadata")
      <*> (o .:? "slo")
      <*> (o .:? "sso")
      <*> (o .:? "token")
      <*> (o .:? "userInfo")

-- | ToJSON ProtocolEndpoints
instance A.ToJSON ProtocolEndpoints where
  toJSON ProtocolEndpoints {..} =
   _omitNulls
      [ "acs" .= protocolEndpointsAcs
      , "authorization" .= protocolEndpointsAuthorization
      , "jwks" .= protocolEndpointsJwks
      , "metadata" .= protocolEndpointsMetadata
      , "slo" .= protocolEndpointsSlo
      , "sso" .= protocolEndpointsSso
      , "token" .= protocolEndpointsToken
      , "userInfo" .= protocolEndpointsUserInfo
      ]


-- | Construct a value of type 'ProtocolEndpoints' (by applying it's required fields, if any)
mkProtocolEndpoints
  :: ProtocolEndpoints
mkProtocolEndpoints =
  ProtocolEndpoints
  { protocolEndpointsAcs = Nothing
  , protocolEndpointsAuthorization = Nothing
  , protocolEndpointsJwks = Nothing
  , protocolEndpointsMetadata = Nothing
  , protocolEndpointsSlo = Nothing
  , protocolEndpointsSso = Nothing
  , protocolEndpointsToken = Nothing
  , protocolEndpointsUserInfo = Nothing
  }

-- ** ProtocolRelayState
-- | ProtocolRelayState
data ProtocolRelayState = ProtocolRelayState
  { protocolRelayStateFormat :: !(Maybe ProtocolRelayStateFormat) -- ^ "format"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolRelayState
instance A.FromJSON ProtocolRelayState where
  parseJSON = A.withObject "ProtocolRelayState" $ \o ->
    ProtocolRelayState
      <$> (o .:? "format")

-- | ToJSON ProtocolRelayState
instance A.ToJSON ProtocolRelayState where
  toJSON ProtocolRelayState {..} =
   _omitNulls
      [ "format" .= protocolRelayStateFormat
      ]


-- | Construct a value of type 'ProtocolRelayState' (by applying it's required fields, if any)
mkProtocolRelayState
  :: ProtocolRelayState
mkProtocolRelayState =
  ProtocolRelayState
  { protocolRelayStateFormat = Nothing
  }

-- ** ProtocolSettings
-- | ProtocolSettings
data ProtocolSettings = ProtocolSettings
  { protocolSettingsNameFormat :: !(Maybe Text) -- ^ "nameFormat"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProtocolSettings
instance A.FromJSON ProtocolSettings where
  parseJSON = A.withObject "ProtocolSettings" $ \o ->
    ProtocolSettings
      <$> (o .:? "nameFormat")

-- | ToJSON ProtocolSettings
instance A.ToJSON ProtocolSettings where
  toJSON ProtocolSettings {..} =
   _omitNulls
      [ "nameFormat" .= protocolSettingsNameFormat
      ]


-- | Construct a value of type 'ProtocolSettings' (by applying it's required fields, if any)
mkProtocolSettings
  :: ProtocolSettings
mkProtocolSettings =
  ProtocolSettings
  { protocolSettingsNameFormat = Nothing
  }

-- ** Provisioning
-- | Provisioning
data Provisioning = Provisioning
  { provisioningAction :: !(Maybe E'Action2) -- ^ "action"
  , provisioningConditions :: !(Maybe ProvisioningConditions) -- ^ "conditions"
  , provisioningGroups :: !(Maybe ProvisioningGroups) -- ^ "groups"
  , provisioningProfileMaster :: !(Maybe Bool) -- ^ "profileMaster"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Provisioning
instance A.FromJSON Provisioning where
  parseJSON = A.withObject "Provisioning" $ \o ->
    Provisioning
      <$> (o .:? "action")
      <*> (o .:? "conditions")
      <*> (o .:? "groups")
      <*> (o .:? "profileMaster")

-- | ToJSON Provisioning
instance A.ToJSON Provisioning where
  toJSON Provisioning {..} =
   _omitNulls
      [ "action" .= provisioningAction
      , "conditions" .= provisioningConditions
      , "groups" .= provisioningGroups
      , "profileMaster" .= provisioningProfileMaster
      ]


-- | Construct a value of type 'Provisioning' (by applying it's required fields, if any)
mkProvisioning
  :: Provisioning
mkProvisioning =
  Provisioning
  { provisioningAction = Nothing
  , provisioningConditions = Nothing
  , provisioningGroups = Nothing
  , provisioningProfileMaster = Nothing
  }

-- ** ProvisioningConditions
-- | ProvisioningConditions
data ProvisioningConditions = ProvisioningConditions
  { provisioningConditionsDeprovisioned :: !(Maybe ProvisioningDeprovisionedCondition) -- ^ "deprovisioned"
  , provisioningConditionsSuspended :: !(Maybe ProvisioningSuspendedCondition) -- ^ "suspended"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningConditions
instance A.FromJSON ProvisioningConditions where
  parseJSON = A.withObject "ProvisioningConditions" $ \o ->
    ProvisioningConditions
      <$> (o .:? "deprovisioned")
      <*> (o .:? "suspended")

-- | ToJSON ProvisioningConditions
instance A.ToJSON ProvisioningConditions where
  toJSON ProvisioningConditions {..} =
   _omitNulls
      [ "deprovisioned" .= provisioningConditionsDeprovisioned
      , "suspended" .= provisioningConditionsSuspended
      ]


-- | Construct a value of type 'ProvisioningConditions' (by applying it's required fields, if any)
mkProvisioningConditions
  :: ProvisioningConditions
mkProvisioningConditions =
  ProvisioningConditions
  { provisioningConditionsDeprovisioned = Nothing
  , provisioningConditionsSuspended = Nothing
  }

-- ** ProvisioningConnection
-- | ProvisioningConnection
data ProvisioningConnection = ProvisioningConnection
  { provisioningConnectionAuthScheme :: !(Maybe ProvisioningConnectionAuthScheme) -- ^ "authScheme"
  , provisioningConnectionStatus :: !(Maybe ProvisioningConnectionStatus) -- ^ "status"
  , provisioningConnectionLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningConnection
instance A.FromJSON ProvisioningConnection where
  parseJSON = A.withObject "ProvisioningConnection" $ \o ->
    ProvisioningConnection
      <$> (o .:? "authScheme")
      <*> (o .:? "status")
      <*> (o .:? "_links")

-- | ToJSON ProvisioningConnection
instance A.ToJSON ProvisioningConnection where
  toJSON ProvisioningConnection {..} =
   _omitNulls
      [ "authScheme" .= provisioningConnectionAuthScheme
      , "status" .= provisioningConnectionStatus
      , "_links" .= provisioningConnectionLinks
      ]


-- | Construct a value of type 'ProvisioningConnection' (by applying it's required fields, if any)
mkProvisioningConnection
  :: ProvisioningConnection
mkProvisioningConnection =
  ProvisioningConnection
  { provisioningConnectionAuthScheme = Nothing
  , provisioningConnectionStatus = Nothing
  , provisioningConnectionLinks = Nothing
  }

-- ** ProvisioningConnectionProfile
-- | ProvisioningConnectionProfile
data ProvisioningConnectionProfile = ProvisioningConnectionProfile
  { provisioningConnectionProfileAuthScheme :: !(Maybe ProvisioningConnectionAuthScheme) -- ^ "authScheme"
  , provisioningConnectionProfileToken :: !(Maybe Text) -- ^ "token"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningConnectionProfile
instance A.FromJSON ProvisioningConnectionProfile where
  parseJSON = A.withObject "ProvisioningConnectionProfile" $ \o ->
    ProvisioningConnectionProfile
      <$> (o .:? "authScheme")
      <*> (o .:? "token")

-- | ToJSON ProvisioningConnectionProfile
instance A.ToJSON ProvisioningConnectionProfile where
  toJSON ProvisioningConnectionProfile {..} =
   _omitNulls
      [ "authScheme" .= provisioningConnectionProfileAuthScheme
      , "token" .= provisioningConnectionProfileToken
      ]


-- | Construct a value of type 'ProvisioningConnectionProfile' (by applying it's required fields, if any)
mkProvisioningConnectionProfile
  :: ProvisioningConnectionProfile
mkProvisioningConnectionProfile =
  ProvisioningConnectionProfile
  { provisioningConnectionProfileAuthScheme = Nothing
  , provisioningConnectionProfileToken = Nothing
  }

-- ** ProvisioningConnectionRequest
-- | ProvisioningConnectionRequest
data ProvisioningConnectionRequest = ProvisioningConnectionRequest
  { provisioningConnectionRequestProfile :: !(Maybe ProvisioningConnectionProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningConnectionRequest
instance A.FromJSON ProvisioningConnectionRequest where
  parseJSON = A.withObject "ProvisioningConnectionRequest" $ \o ->
    ProvisioningConnectionRequest
      <$> (o .:? "profile")

-- | ToJSON ProvisioningConnectionRequest
instance A.ToJSON ProvisioningConnectionRequest where
  toJSON ProvisioningConnectionRequest {..} =
   _omitNulls
      [ "profile" .= provisioningConnectionRequestProfile
      ]


-- | Construct a value of type 'ProvisioningConnectionRequest' (by applying it's required fields, if any)
mkProvisioningConnectionRequest
  :: ProvisioningConnectionRequest
mkProvisioningConnectionRequest =
  ProvisioningConnectionRequest
  { provisioningConnectionRequestProfile = Nothing
  }

-- ** ProvisioningDeprovisionedCondition
-- | ProvisioningDeprovisionedCondition
data ProvisioningDeprovisionedCondition = ProvisioningDeprovisionedCondition
  { provisioningDeprovisionedConditionAction :: !(Maybe E'Action3) -- ^ "action"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningDeprovisionedCondition
instance A.FromJSON ProvisioningDeprovisionedCondition where
  parseJSON = A.withObject "ProvisioningDeprovisionedCondition" $ \o ->
    ProvisioningDeprovisionedCondition
      <$> (o .:? "action")

-- | ToJSON ProvisioningDeprovisionedCondition
instance A.ToJSON ProvisioningDeprovisionedCondition where
  toJSON ProvisioningDeprovisionedCondition {..} =
   _omitNulls
      [ "action" .= provisioningDeprovisionedConditionAction
      ]


-- | Construct a value of type 'ProvisioningDeprovisionedCondition' (by applying it's required fields, if any)
mkProvisioningDeprovisionedCondition
  :: ProvisioningDeprovisionedCondition
mkProvisioningDeprovisionedCondition =
  ProvisioningDeprovisionedCondition
  { provisioningDeprovisionedConditionAction = Nothing
  }

-- ** ProvisioningGroups
-- | ProvisioningGroups
data ProvisioningGroups = ProvisioningGroups
  { provisioningGroupsAction :: !(Maybe E'Action4) -- ^ "action"
  , provisioningGroupsAssignments :: !(Maybe [Text]) -- ^ "assignments"
  , provisioningGroupsFilter :: !(Maybe [Text]) -- ^ "filter"
  , provisioningGroupsSourceAttributeName :: !(Maybe Text) -- ^ "sourceAttributeName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningGroups
instance A.FromJSON ProvisioningGroups where
  parseJSON = A.withObject "ProvisioningGroups" $ \o ->
    ProvisioningGroups
      <$> (o .:? "action")
      <*> (o .:? "assignments")
      <*> (o .:? "filter")
      <*> (o .:? "sourceAttributeName")

-- | ToJSON ProvisioningGroups
instance A.ToJSON ProvisioningGroups where
  toJSON ProvisioningGroups {..} =
   _omitNulls
      [ "action" .= provisioningGroupsAction
      , "assignments" .= provisioningGroupsAssignments
      , "filter" .= provisioningGroupsFilter
      , "sourceAttributeName" .= provisioningGroupsSourceAttributeName
      ]


-- | Construct a value of type 'ProvisioningGroups' (by applying it's required fields, if any)
mkProvisioningGroups
  :: ProvisioningGroups
mkProvisioningGroups =
  ProvisioningGroups
  { provisioningGroupsAction = Nothing
  , provisioningGroupsAssignments = Nothing
  , provisioningGroupsFilter = Nothing
  , provisioningGroupsSourceAttributeName = Nothing
  }

-- ** ProvisioningSuspendedCondition
-- | ProvisioningSuspendedCondition
data ProvisioningSuspendedCondition = ProvisioningSuspendedCondition
  { provisioningSuspendedConditionAction :: !(Maybe E'Action5) -- ^ "action"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProvisioningSuspendedCondition
instance A.FromJSON ProvisioningSuspendedCondition where
  parseJSON = A.withObject "ProvisioningSuspendedCondition" $ \o ->
    ProvisioningSuspendedCondition
      <$> (o .:? "action")

-- | ToJSON ProvisioningSuspendedCondition
instance A.ToJSON ProvisioningSuspendedCondition where
  toJSON ProvisioningSuspendedCondition {..} =
   _omitNulls
      [ "action" .= provisioningSuspendedConditionAction
      ]


-- | Construct a value of type 'ProvisioningSuspendedCondition' (by applying it's required fields, if any)
mkProvisioningSuspendedCondition
  :: ProvisioningSuspendedCondition
mkProvisioningSuspendedCondition =
  ProvisioningSuspendedCondition
  { provisioningSuspendedConditionAction = Nothing
  }

-- ** PushUserFactor
-- | PushUserFactor
data PushUserFactor = PushUserFactor
  { pushUserFactorExpiresAt :: !(Maybe DateTime) -- ^ "expiresAt"
  , pushUserFactorFactorResult :: !(Maybe FactorResultType) -- ^ "factorResult"
  , pushUserFactorProfile :: !(Maybe PushUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushUserFactor
instance A.FromJSON PushUserFactor where
  parseJSON = A.withObject "PushUserFactor" $ \o ->
    PushUserFactor
      <$> (o .:? "expiresAt")
      <*> (o .:? "factorResult")
      <*> (o .:? "profile")

-- | ToJSON PushUserFactor
instance A.ToJSON PushUserFactor where
  toJSON PushUserFactor {..} =
   _omitNulls
      [ "expiresAt" .= pushUserFactorExpiresAt
      , "factorResult" .= pushUserFactorFactorResult
      , "profile" .= pushUserFactorProfile
      ]


-- | Construct a value of type 'PushUserFactor' (by applying it's required fields, if any)
mkPushUserFactor
  :: PushUserFactor
mkPushUserFactor =
  PushUserFactor
  { pushUserFactorExpiresAt = Nothing
  , pushUserFactorFactorResult = Nothing
  , pushUserFactorProfile = Nothing
  }

-- ** PushUserFactorProfile
-- | PushUserFactorProfile
data PushUserFactorProfile = PushUserFactorProfile
  { pushUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  , pushUserFactorProfileDeviceToken :: !(Maybe Text) -- ^ "deviceToken"
  , pushUserFactorProfileDeviceType :: !(Maybe Text) -- ^ "deviceType"
  , pushUserFactorProfileName :: !(Maybe Text) -- ^ "name"
  , pushUserFactorProfilePlatform :: !(Maybe Text) -- ^ "platform"
  , pushUserFactorProfileVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushUserFactorProfile
instance A.FromJSON PushUserFactorProfile where
  parseJSON = A.withObject "PushUserFactorProfile" $ \o ->
    PushUserFactorProfile
      <$> (o .:? "credentialId")
      <*> (o .:? "deviceToken")
      <*> (o .:? "deviceType")
      <*> (o .:? "name")
      <*> (o .:? "platform")
      <*> (o .:? "version")

-- | ToJSON PushUserFactorProfile
instance A.ToJSON PushUserFactorProfile where
  toJSON PushUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= pushUserFactorProfileCredentialId
      , "deviceToken" .= pushUserFactorProfileDeviceToken
      , "deviceType" .= pushUserFactorProfileDeviceType
      , "name" .= pushUserFactorProfileName
      , "platform" .= pushUserFactorProfilePlatform
      , "version" .= pushUserFactorProfileVersion
      ]


-- | Construct a value of type 'PushUserFactorProfile' (by applying it's required fields, if any)
mkPushUserFactorProfile
  :: PushUserFactorProfile
mkPushUserFactorProfile =
  PushUserFactorProfile
  { pushUserFactorProfileCredentialId = Nothing
  , pushUserFactorProfileDeviceToken = Nothing
  , pushUserFactorProfileDeviceType = Nothing
  , pushUserFactorProfileName = Nothing
  , pushUserFactorProfilePlatform = Nothing
  , pushUserFactorProfileVersion = Nothing
  }

-- ** RecoveryQuestionCredential
-- | RecoveryQuestionCredential
data RecoveryQuestionCredential = RecoveryQuestionCredential
  { recoveryQuestionCredentialAnswer :: !(Maybe Text) -- ^ "answer"
  , recoveryQuestionCredentialQuestion :: !(Maybe Text) -- ^ "question"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecoveryQuestionCredential
instance A.FromJSON RecoveryQuestionCredential where
  parseJSON = A.withObject "RecoveryQuestionCredential" $ \o ->
    RecoveryQuestionCredential
      <$> (o .:? "answer")
      <*> (o .:? "question")

-- | ToJSON RecoveryQuestionCredential
instance A.ToJSON RecoveryQuestionCredential where
  toJSON RecoveryQuestionCredential {..} =
   _omitNulls
      [ "answer" .= recoveryQuestionCredentialAnswer
      , "question" .= recoveryQuestionCredentialQuestion
      ]


-- | Construct a value of type 'RecoveryQuestionCredential' (by applying it's required fields, if any)
mkRecoveryQuestionCredential
  :: RecoveryQuestionCredential
mkRecoveryQuestionCredential =
  RecoveryQuestionCredential
  { recoveryQuestionCredentialAnswer = Nothing
  , recoveryQuestionCredentialQuestion = Nothing
  }

-- ** ResetPasswordToken
-- | ResetPasswordToken
data ResetPasswordToken = ResetPasswordToken
  { resetPasswordTokenResetPasswordUrl :: !(Maybe Text) -- ^ /ReadOnly/ "resetPasswordUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResetPasswordToken
instance A.FromJSON ResetPasswordToken where
  parseJSON = A.withObject "ResetPasswordToken" $ \o ->
    ResetPasswordToken
      <$> (o .:? "resetPasswordUrl")

-- | ToJSON ResetPasswordToken
instance A.ToJSON ResetPasswordToken where
  toJSON ResetPasswordToken {..} =
   _omitNulls
      [ "resetPasswordUrl" .= resetPasswordTokenResetPasswordUrl
      ]


-- | Construct a value of type 'ResetPasswordToken' (by applying it's required fields, if any)
mkResetPasswordToken
  :: ResetPasswordToken
mkResetPasswordToken =
  ResetPasswordToken
  { resetPasswordTokenResetPasswordUrl = Nothing
  }

-- ** ResponseLinks
-- | ResponseLinks
data ResponseLinks = ResponseLinks
  { responseLinksLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseLinks
instance A.FromJSON ResponseLinks where
  parseJSON = A.withObject "ResponseLinks" $ \o ->
    ResponseLinks
      <$> (o .:? "_links")

-- | ToJSON ResponseLinks
instance A.ToJSON ResponseLinks where
  toJSON ResponseLinks {..} =
   _omitNulls
      [ "_links" .= responseLinksLinks
      ]


-- | Construct a value of type 'ResponseLinks' (by applying it's required fields, if any)
mkResponseLinks
  :: ResponseLinks
mkResponseLinks =
  ResponseLinks
  { responseLinksLinks = Nothing
  }

-- ** RiskPolicyRuleCondition
-- | RiskPolicyRuleCondition
data RiskPolicyRuleCondition = RiskPolicyRuleCondition
  { riskPolicyRuleConditionBehaviors :: !(Maybe [Text]) -- ^ "behaviors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RiskPolicyRuleCondition
instance A.FromJSON RiskPolicyRuleCondition where
  parseJSON = A.withObject "RiskPolicyRuleCondition" $ \o ->
    RiskPolicyRuleCondition
      <$> (o .:? "behaviors")

-- | ToJSON RiskPolicyRuleCondition
instance A.ToJSON RiskPolicyRuleCondition where
  toJSON RiskPolicyRuleCondition {..} =
   _omitNulls
      [ "behaviors" .= riskPolicyRuleConditionBehaviors
      ]


-- | Construct a value of type 'RiskPolicyRuleCondition' (by applying it's required fields, if any)
mkRiskPolicyRuleCondition
  :: RiskPolicyRuleCondition
mkRiskPolicyRuleCondition =
  RiskPolicyRuleCondition
  { riskPolicyRuleConditionBehaviors = Nothing
  }

-- ** RiskScorePolicyRuleCondition
-- | RiskScorePolicyRuleCondition
data RiskScorePolicyRuleCondition = RiskScorePolicyRuleCondition
  { riskScorePolicyRuleConditionLevel :: !(Maybe Text) -- ^ "level"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RiskScorePolicyRuleCondition
instance A.FromJSON RiskScorePolicyRuleCondition where
  parseJSON = A.withObject "RiskScorePolicyRuleCondition" $ \o ->
    RiskScorePolicyRuleCondition
      <$> (o .:? "level")

-- | ToJSON RiskScorePolicyRuleCondition
instance A.ToJSON RiskScorePolicyRuleCondition where
  toJSON RiskScorePolicyRuleCondition {..} =
   _omitNulls
      [ "level" .= riskScorePolicyRuleConditionLevel
      ]


-- | Construct a value of type 'RiskScorePolicyRuleCondition' (by applying it's required fields, if any)
mkRiskScorePolicyRuleCondition
  :: RiskScorePolicyRuleCondition
mkRiskScorePolicyRuleCondition =
  RiskScorePolicyRuleCondition
  { riskScorePolicyRuleConditionLevel = Nothing
  }

-- ** Role
-- | Role
data Role = Role
  { roleEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , roleLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , roleAssignmentType :: !(Maybe RoleAssignmentType) -- ^ "assignmentType"
  , roleCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , roleDescription :: !(Maybe Text) -- ^ "description"
  , roleId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , roleLabel :: !(Maybe Text) -- ^ /ReadOnly/ "label"
  , roleLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , roleStatus :: !(Maybe RoleStatus) -- ^ "status"
  , roleType :: !(Maybe RoleType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Role
instance A.FromJSON Role where
  parseJSON = A.withObject "Role" $ \o ->
    Role
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "assignmentType")
      <*> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "label")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "status")
      <*> (o .:? "type")

-- | ToJSON Role
instance A.ToJSON Role where
  toJSON Role {..} =
   _omitNulls
      [ "_embedded" .= roleEmbedded
      , "_links" .= roleLinks
      , "assignmentType" .= roleAssignmentType
      , "created" .= roleCreated
      , "description" .= roleDescription
      , "id" .= roleId
      , "label" .= roleLabel
      , "lastUpdated" .= roleLastUpdated
      , "status" .= roleStatus
      , "type" .= roleType
      ]


-- | Construct a value of type 'Role' (by applying it's required fields, if any)
mkRole
  :: Role
mkRole =
  Role
  { roleEmbedded = Nothing
  , roleLinks = Nothing
  , roleAssignmentType = Nothing
  , roleCreated = Nothing
  , roleDescription = Nothing
  , roleId = Nothing
  , roleLabel = Nothing
  , roleLastUpdated = Nothing
  , roleStatus = Nothing
  , roleType = Nothing
  }

-- ** SamlApplication
-- | SamlApplication
data SamlApplication = SamlApplication
  { samlApplicationSettings :: !(Maybe SamlApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlApplication
instance A.FromJSON SamlApplication where
  parseJSON = A.withObject "SamlApplication" $ \o ->
    SamlApplication
      <$> (o .:? "settings")

-- | ToJSON SamlApplication
instance A.ToJSON SamlApplication where
  toJSON SamlApplication {..} =
   _omitNulls
      [ "settings" .= samlApplicationSettings
      ]


-- | Construct a value of type 'SamlApplication' (by applying it's required fields, if any)
mkSamlApplication
  :: SamlApplication
mkSamlApplication =
  SamlApplication
  { samlApplicationSettings = Nothing
  }

-- ** SamlApplicationSettings
-- | SamlApplicationSettings
data SamlApplicationSettings = SamlApplicationSettings
  { samlApplicationSettingsSignOn :: !(Maybe SamlApplicationSettingsSignOn) -- ^ "signOn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlApplicationSettings
instance A.FromJSON SamlApplicationSettings where
  parseJSON = A.withObject "SamlApplicationSettings" $ \o ->
    SamlApplicationSettings
      <$> (o .:? "signOn")

-- | ToJSON SamlApplicationSettings
instance A.ToJSON SamlApplicationSettings where
  toJSON SamlApplicationSettings {..} =
   _omitNulls
      [ "signOn" .= samlApplicationSettingsSignOn
      ]


-- | Construct a value of type 'SamlApplicationSettings' (by applying it's required fields, if any)
mkSamlApplicationSettings
  :: SamlApplicationSettings
mkSamlApplicationSettings =
  SamlApplicationSettings
  { samlApplicationSettingsSignOn = Nothing
  }

-- ** SamlApplicationSettingsSignOn
-- | SamlApplicationSettingsSignOn
data SamlApplicationSettingsSignOn = SamlApplicationSettingsSignOn
  { samlApplicationSettingsSignOnAcsEndpoints :: !(Maybe [AcsEndpoint]) -- ^ "acsEndpoints"
  , samlApplicationSettingsSignOnAllowMultipleAcsEndpoints :: !(Maybe Bool) -- ^ "allowMultipleAcsEndpoints"
  , samlApplicationSettingsSignOnAssertionSigned :: !(Maybe Bool) -- ^ "assertionSigned"
  , samlApplicationSettingsSignOnAttributeStatements :: !(Maybe [SamlAttributeStatement]) -- ^ "attributeStatements"
  , samlApplicationSettingsSignOnAudience :: !(Maybe Text) -- ^ "audience"
  , samlApplicationSettingsSignOnAudienceOverride :: !(Maybe Text) -- ^ "audienceOverride"
  , samlApplicationSettingsSignOnAuthnContextClassRef :: !(Maybe Text) -- ^ "authnContextClassRef"
  , samlApplicationSettingsSignOnDefaultRelayState :: !(Maybe Text) -- ^ "defaultRelayState"
  , samlApplicationSettingsSignOnDestination :: !(Maybe Text) -- ^ "destination"
  , samlApplicationSettingsSignOnDestinationOverride :: !(Maybe Text) -- ^ "destinationOverride"
  , samlApplicationSettingsSignOnDigestAlgorithm :: !(Maybe Text) -- ^ "digestAlgorithm"
  , samlApplicationSettingsSignOnHonorForceAuthn :: !(Maybe Bool) -- ^ "honorForceAuthn"
  , samlApplicationSettingsSignOnIdpIssuer :: !(Maybe Text) -- ^ "idpIssuer"
  , samlApplicationSettingsSignOnInlineHooks :: !(Maybe [SignOnInlineHook]) -- ^ "inlineHooks"
  , samlApplicationSettingsSignOnRecipient :: !(Maybe Text) -- ^ "recipient"
  , samlApplicationSettingsSignOnRecipientOverride :: !(Maybe Text) -- ^ "recipientOverride"
  , samlApplicationSettingsSignOnRequestCompressed :: !(Maybe Bool) -- ^ "requestCompressed"
  , samlApplicationSettingsSignOnResponseSigned :: !(Maybe Bool) -- ^ "responseSigned"
  , samlApplicationSettingsSignOnSignatureAlgorithm :: !(Maybe Text) -- ^ "signatureAlgorithm"
  , samlApplicationSettingsSignOnSlo :: !(Maybe SingleLogout) -- ^ "slo"
  , samlApplicationSettingsSignOnSpIssuer :: !(Maybe Text) -- ^ "spIssuer"
  , samlApplicationSettingsSignOnSpCertificate :: !(Maybe SpCertificate) -- ^ "spCertificate"
  , samlApplicationSettingsSignOnSsoAcsUrl :: !(Maybe Text) -- ^ "ssoAcsUrl"
  , samlApplicationSettingsSignOnSsoAcsUrlOverride :: !(Maybe Text) -- ^ "ssoAcsUrlOverride"
  , samlApplicationSettingsSignOnSubjectNameIdFormat :: !(Maybe Text) -- ^ "subjectNameIdFormat"
  , samlApplicationSettingsSignOnSubjectNameIdTemplate :: !(Maybe Text) -- ^ "subjectNameIdTemplate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlApplicationSettingsSignOn
instance A.FromJSON SamlApplicationSettingsSignOn where
  parseJSON = A.withObject "SamlApplicationSettingsSignOn" $ \o ->
    SamlApplicationSettingsSignOn
      <$> (o .:? "acsEndpoints")
      <*> (o .:? "allowMultipleAcsEndpoints")
      <*> (o .:? "assertionSigned")
      <*> (o .:? "attributeStatements")
      <*> (o .:? "audience")
      <*> (o .:? "audienceOverride")
      <*> (o .:? "authnContextClassRef")
      <*> (o .:? "defaultRelayState")
      <*> (o .:? "destination")
      <*> (o .:? "destinationOverride")
      <*> (o .:? "digestAlgorithm")
      <*> (o .:? "honorForceAuthn")
      <*> (o .:? "idpIssuer")
      <*> (o .:? "inlineHooks")
      <*> (o .:? "recipient")
      <*> (o .:? "recipientOverride")
      <*> (o .:? "requestCompressed")
      <*> (o .:? "responseSigned")
      <*> (o .:? "signatureAlgorithm")
      <*> (o .:? "slo")
      <*> (o .:? "spIssuer")
      <*> (o .:? "spCertificate")
      <*> (o .:? "ssoAcsUrl")
      <*> (o .:? "ssoAcsUrlOverride")
      <*> (o .:? "subjectNameIdFormat")
      <*> (o .:? "subjectNameIdTemplate")

-- | ToJSON SamlApplicationSettingsSignOn
instance A.ToJSON SamlApplicationSettingsSignOn where
  toJSON SamlApplicationSettingsSignOn {..} =
   _omitNulls
      [ "acsEndpoints" .= samlApplicationSettingsSignOnAcsEndpoints
      , "allowMultipleAcsEndpoints" .= samlApplicationSettingsSignOnAllowMultipleAcsEndpoints
      , "assertionSigned" .= samlApplicationSettingsSignOnAssertionSigned
      , "attributeStatements" .= samlApplicationSettingsSignOnAttributeStatements
      , "audience" .= samlApplicationSettingsSignOnAudience
      , "audienceOverride" .= samlApplicationSettingsSignOnAudienceOverride
      , "authnContextClassRef" .= samlApplicationSettingsSignOnAuthnContextClassRef
      , "defaultRelayState" .= samlApplicationSettingsSignOnDefaultRelayState
      , "destination" .= samlApplicationSettingsSignOnDestination
      , "destinationOverride" .= samlApplicationSettingsSignOnDestinationOverride
      , "digestAlgorithm" .= samlApplicationSettingsSignOnDigestAlgorithm
      , "honorForceAuthn" .= samlApplicationSettingsSignOnHonorForceAuthn
      , "idpIssuer" .= samlApplicationSettingsSignOnIdpIssuer
      , "inlineHooks" .= samlApplicationSettingsSignOnInlineHooks
      , "recipient" .= samlApplicationSettingsSignOnRecipient
      , "recipientOverride" .= samlApplicationSettingsSignOnRecipientOverride
      , "requestCompressed" .= samlApplicationSettingsSignOnRequestCompressed
      , "responseSigned" .= samlApplicationSettingsSignOnResponseSigned
      , "signatureAlgorithm" .= samlApplicationSettingsSignOnSignatureAlgorithm
      , "slo" .= samlApplicationSettingsSignOnSlo
      , "spIssuer" .= samlApplicationSettingsSignOnSpIssuer
      , "spCertificate" .= samlApplicationSettingsSignOnSpCertificate
      , "ssoAcsUrl" .= samlApplicationSettingsSignOnSsoAcsUrl
      , "ssoAcsUrlOverride" .= samlApplicationSettingsSignOnSsoAcsUrlOverride
      , "subjectNameIdFormat" .= samlApplicationSettingsSignOnSubjectNameIdFormat
      , "subjectNameIdTemplate" .= samlApplicationSettingsSignOnSubjectNameIdTemplate
      ]


-- | Construct a value of type 'SamlApplicationSettingsSignOn' (by applying it's required fields, if any)
mkSamlApplicationSettingsSignOn
  :: SamlApplicationSettingsSignOn
mkSamlApplicationSettingsSignOn =
  SamlApplicationSettingsSignOn
  { samlApplicationSettingsSignOnAcsEndpoints = Nothing
  , samlApplicationSettingsSignOnAllowMultipleAcsEndpoints = Nothing
  , samlApplicationSettingsSignOnAssertionSigned = Nothing
  , samlApplicationSettingsSignOnAttributeStatements = Nothing
  , samlApplicationSettingsSignOnAudience = Nothing
  , samlApplicationSettingsSignOnAudienceOverride = Nothing
  , samlApplicationSettingsSignOnAuthnContextClassRef = Nothing
  , samlApplicationSettingsSignOnDefaultRelayState = Nothing
  , samlApplicationSettingsSignOnDestination = Nothing
  , samlApplicationSettingsSignOnDestinationOverride = Nothing
  , samlApplicationSettingsSignOnDigestAlgorithm = Nothing
  , samlApplicationSettingsSignOnHonorForceAuthn = Nothing
  , samlApplicationSettingsSignOnIdpIssuer = Nothing
  , samlApplicationSettingsSignOnInlineHooks = Nothing
  , samlApplicationSettingsSignOnRecipient = Nothing
  , samlApplicationSettingsSignOnRecipientOverride = Nothing
  , samlApplicationSettingsSignOnRequestCompressed = Nothing
  , samlApplicationSettingsSignOnResponseSigned = Nothing
  , samlApplicationSettingsSignOnSignatureAlgorithm = Nothing
  , samlApplicationSettingsSignOnSlo = Nothing
  , samlApplicationSettingsSignOnSpIssuer = Nothing
  , samlApplicationSettingsSignOnSpCertificate = Nothing
  , samlApplicationSettingsSignOnSsoAcsUrl = Nothing
  , samlApplicationSettingsSignOnSsoAcsUrlOverride = Nothing
  , samlApplicationSettingsSignOnSubjectNameIdFormat = Nothing
  , samlApplicationSettingsSignOnSubjectNameIdTemplate = Nothing
  }

-- ** SamlAttributeStatement
-- | SamlAttributeStatement
data SamlAttributeStatement = SamlAttributeStatement
  { samlAttributeStatementName :: !(Maybe Text) -- ^ "name"
  , samlAttributeStatementNamespace :: !(Maybe Text) -- ^ "namespace"
  , samlAttributeStatementType :: !(Maybe Text) -- ^ "type"
  , samlAttributeStatementFilterType :: !(Maybe Text) -- ^ "filterType"
  , samlAttributeStatementFilterValue :: !(Maybe Text) -- ^ "filterValue"
  , samlAttributeStatementValues :: !(Maybe [Text]) -- ^ "values"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlAttributeStatement
instance A.FromJSON SamlAttributeStatement where
  parseJSON = A.withObject "SamlAttributeStatement" $ \o ->
    SamlAttributeStatement
      <$> (o .:? "name")
      <*> (o .:? "namespace")
      <*> (o .:? "type")
      <*> (o .:? "filterType")
      <*> (o .:? "filterValue")
      <*> (o .:? "values")

-- | ToJSON SamlAttributeStatement
instance A.ToJSON SamlAttributeStatement where
  toJSON SamlAttributeStatement {..} =
   _omitNulls
      [ "name" .= samlAttributeStatementName
      , "namespace" .= samlAttributeStatementNamespace
      , "type" .= samlAttributeStatementType
      , "filterType" .= samlAttributeStatementFilterType
      , "filterValue" .= samlAttributeStatementFilterValue
      , "values" .= samlAttributeStatementValues
      ]


-- | Construct a value of type 'SamlAttributeStatement' (by applying it's required fields, if any)
mkSamlAttributeStatement
  :: SamlAttributeStatement
mkSamlAttributeStatement =
  SamlAttributeStatement
  { samlAttributeStatementName = Nothing
  , samlAttributeStatementNamespace = Nothing
  , samlAttributeStatementType = Nothing
  , samlAttributeStatementFilterType = Nothing
  , samlAttributeStatementFilterValue = Nothing
  , samlAttributeStatementValues = Nothing
  }

-- ** ScheduledUserLifecycleAction
-- | ScheduledUserLifecycleAction
data ScheduledUserLifecycleAction = ScheduledUserLifecycleAction
  { scheduledUserLifecycleActionStatus :: !(Maybe E'Status4) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScheduledUserLifecycleAction
instance A.FromJSON ScheduledUserLifecycleAction where
  parseJSON = A.withObject "ScheduledUserLifecycleAction" $ \o ->
    ScheduledUserLifecycleAction
      <$> (o .:? "status")

-- | ToJSON ScheduledUserLifecycleAction
instance A.ToJSON ScheduledUserLifecycleAction where
  toJSON ScheduledUserLifecycleAction {..} =
   _omitNulls
      [ "status" .= scheduledUserLifecycleActionStatus
      ]


-- | Construct a value of type 'ScheduledUserLifecycleAction' (by applying it's required fields, if any)
mkScheduledUserLifecycleAction
  :: ScheduledUserLifecycleAction
mkScheduledUserLifecycleAction =
  ScheduledUserLifecycleAction
  { scheduledUserLifecycleActionStatus = Nothing
  }

-- ** SchemeApplicationCredentials
-- | SchemeApplicationCredentials
data SchemeApplicationCredentials = SchemeApplicationCredentials
  { schemeApplicationCredentialsPassword :: !(Maybe PasswordCredential) -- ^ "password"
  , schemeApplicationCredentialsRevealPassword :: !(Maybe Bool) -- ^ "revealPassword"
  , schemeApplicationCredentialsScheme :: !(Maybe ApplicationCredentialsScheme) -- ^ "scheme"
  , schemeApplicationCredentialsSigning :: !(Maybe ApplicationCredentialsSigning) -- ^ "signing"
  , schemeApplicationCredentialsUserName :: !(Maybe Text) -- ^ "userName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SchemeApplicationCredentials
instance A.FromJSON SchemeApplicationCredentials where
  parseJSON = A.withObject "SchemeApplicationCredentials" $ \o ->
    SchemeApplicationCredentials
      <$> (o .:? "password")
      <*> (o .:? "revealPassword")
      <*> (o .:? "scheme")
      <*> (o .:? "signing")
      <*> (o .:? "userName")

-- | ToJSON SchemeApplicationCredentials
instance A.ToJSON SchemeApplicationCredentials where
  toJSON SchemeApplicationCredentials {..} =
   _omitNulls
      [ "password" .= schemeApplicationCredentialsPassword
      , "revealPassword" .= schemeApplicationCredentialsRevealPassword
      , "scheme" .= schemeApplicationCredentialsScheme
      , "signing" .= schemeApplicationCredentialsSigning
      , "userName" .= schemeApplicationCredentialsUserName
      ]


-- | Construct a value of type 'SchemeApplicationCredentials' (by applying it's required fields, if any)
mkSchemeApplicationCredentials
  :: SchemeApplicationCredentials
mkSchemeApplicationCredentials =
  SchemeApplicationCredentials
  { schemeApplicationCredentialsPassword = Nothing
  , schemeApplicationCredentialsRevealPassword = Nothing
  , schemeApplicationCredentialsScheme = Nothing
  , schemeApplicationCredentialsSigning = Nothing
  , schemeApplicationCredentialsUserName = Nothing
  }

-- ** Scope
-- | Scope
data Scope = Scope
  { scopeStringValue :: !(Maybe Text) -- ^ "stringValue"
  , scopeType :: !(Maybe ScopeType) -- ^ "type"
  , scopeAllowedOktaApps :: !(Maybe [IframeEmbedScopeAllowedApps]) -- ^ "allowedOktaApps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Scope
instance A.FromJSON Scope where
  parseJSON = A.withObject "Scope" $ \o ->
    Scope
      <$> (o .:? "stringValue")
      <*> (o .:? "type")
      <*> (o .:? "allowedOktaApps")

-- | ToJSON Scope
instance A.ToJSON Scope where
  toJSON Scope {..} =
   _omitNulls
      [ "stringValue" .= scopeStringValue
      , "type" .= scopeType
      , "allowedOktaApps" .= scopeAllowedOktaApps
      ]


-- | Construct a value of type 'Scope' (by applying it's required fields, if any)
mkScope
  :: Scope
mkScope =
  Scope
  { scopeStringValue = Nothing
  , scopeType = Nothing
  , scopeAllowedOktaApps = Nothing
  }

-- ** SecurePasswordStoreApplication
-- | SecurePasswordStoreApplication
data SecurePasswordStoreApplication = SecurePasswordStoreApplication
  { securePasswordStoreApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  , securePasswordStoreApplicationName :: !(Maybe A.Value) -- ^ "name"
  , securePasswordStoreApplicationSettings :: !(Maybe SecurePasswordStoreApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurePasswordStoreApplication
instance A.FromJSON SecurePasswordStoreApplication where
  parseJSON = A.withObject "SecurePasswordStoreApplication" $ \o ->
    SecurePasswordStoreApplication
      <$> (o .:? "credentials")
      <*> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON SecurePasswordStoreApplication
instance A.ToJSON SecurePasswordStoreApplication where
  toJSON SecurePasswordStoreApplication {..} =
   _omitNulls
      [ "credentials" .= securePasswordStoreApplicationCredentials
      , "name" .= securePasswordStoreApplicationName
      , "settings" .= securePasswordStoreApplicationSettings
      ]


-- | Construct a value of type 'SecurePasswordStoreApplication' (by applying it's required fields, if any)
mkSecurePasswordStoreApplication
  :: SecurePasswordStoreApplication
mkSecurePasswordStoreApplication =
  SecurePasswordStoreApplication
  { securePasswordStoreApplicationCredentials = Nothing
  , securePasswordStoreApplicationName = Nothing
  , securePasswordStoreApplicationSettings = Nothing
  }

-- ** SecurePasswordStoreApplicationSettings
-- | SecurePasswordStoreApplicationSettings
data SecurePasswordStoreApplicationSettings = SecurePasswordStoreApplicationSettings
  { securePasswordStoreApplicationSettingsApp :: !(Maybe SecurePasswordStoreApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurePasswordStoreApplicationSettings
instance A.FromJSON SecurePasswordStoreApplicationSettings where
  parseJSON = A.withObject "SecurePasswordStoreApplicationSettings" $ \o ->
    SecurePasswordStoreApplicationSettings
      <$> (o .:? "app")

-- | ToJSON SecurePasswordStoreApplicationSettings
instance A.ToJSON SecurePasswordStoreApplicationSettings where
  toJSON SecurePasswordStoreApplicationSettings {..} =
   _omitNulls
      [ "app" .= securePasswordStoreApplicationSettingsApp
      ]


-- | Construct a value of type 'SecurePasswordStoreApplicationSettings' (by applying it's required fields, if any)
mkSecurePasswordStoreApplicationSettings
  :: SecurePasswordStoreApplicationSettings
mkSecurePasswordStoreApplicationSettings =
  SecurePasswordStoreApplicationSettings
  { securePasswordStoreApplicationSettingsApp = Nothing
  }

-- ** SecurePasswordStoreApplicationSettingsApplication
-- | SecurePasswordStoreApplicationSettingsApplication
data SecurePasswordStoreApplicationSettingsApplication = SecurePasswordStoreApplicationSettingsApplication
  { securePasswordStoreApplicationSettingsApplicationOptionalField1 :: !(Maybe Text) -- ^ "optionalField1"
  , securePasswordStoreApplicationSettingsApplicationOptionalField1Value :: !(Maybe Text) -- ^ "optionalField1Value"
  , securePasswordStoreApplicationSettingsApplicationOptionalField2 :: !(Maybe Text) -- ^ "optionalField2"
  , securePasswordStoreApplicationSettingsApplicationOptionalField2Value :: !(Maybe Text) -- ^ "optionalField2Value"
  , securePasswordStoreApplicationSettingsApplicationOptionalField3 :: !(Maybe Text) -- ^ "optionalField3"
  , securePasswordStoreApplicationSettingsApplicationOptionalField3Value :: !(Maybe Text) -- ^ "optionalField3Value"
  , securePasswordStoreApplicationSettingsApplicationPasswordField :: !(Maybe Text) -- ^ "passwordField"
  , securePasswordStoreApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  , securePasswordStoreApplicationSettingsApplicationUsernameField :: !(Maybe Text) -- ^ "usernameField"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurePasswordStoreApplicationSettingsApplication
instance A.FromJSON SecurePasswordStoreApplicationSettingsApplication where
  parseJSON = A.withObject "SecurePasswordStoreApplicationSettingsApplication" $ \o ->
    SecurePasswordStoreApplicationSettingsApplication
      <$> (o .:? "optionalField1")
      <*> (o .:? "optionalField1Value")
      <*> (o .:? "optionalField2")
      <*> (o .:? "optionalField2Value")
      <*> (o .:? "optionalField3")
      <*> (o .:? "optionalField3Value")
      <*> (o .:? "passwordField")
      <*> (o .:? "url")
      <*> (o .:? "usernameField")

-- | ToJSON SecurePasswordStoreApplicationSettingsApplication
instance A.ToJSON SecurePasswordStoreApplicationSettingsApplication where
  toJSON SecurePasswordStoreApplicationSettingsApplication {..} =
   _omitNulls
      [ "optionalField1" .= securePasswordStoreApplicationSettingsApplicationOptionalField1
      , "optionalField1Value" .= securePasswordStoreApplicationSettingsApplicationOptionalField1Value
      , "optionalField2" .= securePasswordStoreApplicationSettingsApplicationOptionalField2
      , "optionalField2Value" .= securePasswordStoreApplicationSettingsApplicationOptionalField2Value
      , "optionalField3" .= securePasswordStoreApplicationSettingsApplicationOptionalField3
      , "optionalField3Value" .= securePasswordStoreApplicationSettingsApplicationOptionalField3Value
      , "passwordField" .= securePasswordStoreApplicationSettingsApplicationPasswordField
      , "url" .= securePasswordStoreApplicationSettingsApplicationUrl
      , "usernameField" .= securePasswordStoreApplicationSettingsApplicationUsernameField
      ]


-- | Construct a value of type 'SecurePasswordStoreApplicationSettingsApplication' (by applying it's required fields, if any)
mkSecurePasswordStoreApplicationSettingsApplication
  :: SecurePasswordStoreApplicationSettingsApplication
mkSecurePasswordStoreApplicationSettingsApplication =
  SecurePasswordStoreApplicationSettingsApplication
  { securePasswordStoreApplicationSettingsApplicationOptionalField1 = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField1Value = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField2 = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField2Value = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField3 = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField3Value = Nothing
  , securePasswordStoreApplicationSettingsApplicationPasswordField = Nothing
  , securePasswordStoreApplicationSettingsApplicationUrl = Nothing
  , securePasswordStoreApplicationSettingsApplicationUsernameField = Nothing
  }

-- ** SecurityQuestion
-- | SecurityQuestion
data SecurityQuestion = SecurityQuestion
  { securityQuestionAnswer :: !(Maybe Text) -- ^ "answer"
  , securityQuestionQuestion :: !(Maybe Text) -- ^ "question"
  , securityQuestionQuestionText :: !(Maybe Text) -- ^ "questionText"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestion
instance A.FromJSON SecurityQuestion where
  parseJSON = A.withObject "SecurityQuestion" $ \o ->
    SecurityQuestion
      <$> (o .:? "answer")
      <*> (o .:? "question")
      <*> (o .:? "questionText")

-- | ToJSON SecurityQuestion
instance A.ToJSON SecurityQuestion where
  toJSON SecurityQuestion {..} =
   _omitNulls
      [ "answer" .= securityQuestionAnswer
      , "question" .= securityQuestionQuestion
      , "questionText" .= securityQuestionQuestionText
      ]


-- | Construct a value of type 'SecurityQuestion' (by applying it's required fields, if any)
mkSecurityQuestion
  :: SecurityQuestion
mkSecurityQuestion =
  SecurityQuestion
  { securityQuestionAnswer = Nothing
  , securityQuestionQuestion = Nothing
  , securityQuestionQuestionText = Nothing
  }

-- ** SecurityQuestionUserFactor
-- | SecurityQuestionUserFactor
data SecurityQuestionUserFactor = SecurityQuestionUserFactor
  { securityQuestionUserFactorProfile :: !(Maybe SecurityQuestionUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestionUserFactor
instance A.FromJSON SecurityQuestionUserFactor where
  parseJSON = A.withObject "SecurityQuestionUserFactor" $ \o ->
    SecurityQuestionUserFactor
      <$> (o .:? "profile")

-- | ToJSON SecurityQuestionUserFactor
instance A.ToJSON SecurityQuestionUserFactor where
  toJSON SecurityQuestionUserFactor {..} =
   _omitNulls
      [ "profile" .= securityQuestionUserFactorProfile
      ]


-- | Construct a value of type 'SecurityQuestionUserFactor' (by applying it's required fields, if any)
mkSecurityQuestionUserFactor
  :: SecurityQuestionUserFactor
mkSecurityQuestionUserFactor =
  SecurityQuestionUserFactor
  { securityQuestionUserFactorProfile = Nothing
  }

-- ** SecurityQuestionUserFactorProfile
-- | SecurityQuestionUserFactorProfile
data SecurityQuestionUserFactorProfile = SecurityQuestionUserFactorProfile
  { securityQuestionUserFactorProfileAnswer :: !(Maybe Text) -- ^ "answer"
  , securityQuestionUserFactorProfileQuestion :: !(Maybe Text) -- ^ "question"
  , securityQuestionUserFactorProfileQuestionText :: !(Maybe Text) -- ^ "questionText"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestionUserFactorProfile
instance A.FromJSON SecurityQuestionUserFactorProfile where
  parseJSON = A.withObject "SecurityQuestionUserFactorProfile" $ \o ->
    SecurityQuestionUserFactorProfile
      <$> (o .:? "answer")
      <*> (o .:? "question")
      <*> (o .:? "questionText")

-- | ToJSON SecurityQuestionUserFactorProfile
instance A.ToJSON SecurityQuestionUserFactorProfile where
  toJSON SecurityQuestionUserFactorProfile {..} =
   _omitNulls
      [ "answer" .= securityQuestionUserFactorProfileAnswer
      , "question" .= securityQuestionUserFactorProfileQuestion
      , "questionText" .= securityQuestionUserFactorProfileQuestionText
      ]


-- | Construct a value of type 'SecurityQuestionUserFactorProfile' (by applying it's required fields, if any)
mkSecurityQuestionUserFactorProfile
  :: SecurityQuestionUserFactorProfile
mkSecurityQuestionUserFactorProfile =
  SecurityQuestionUserFactorProfile
  { securityQuestionUserFactorProfileAnswer = Nothing
  , securityQuestionUserFactorProfileQuestion = Nothing
  , securityQuestionUserFactorProfileQuestionText = Nothing
  }

-- ** Session
-- | Session
data Session = Session
  { sessionLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , sessionAmr :: !(Maybe [SessionAuthenticationMethod]) -- ^ /ReadOnly/ "amr"
  , sessionCreatedAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "createdAt"
  , sessionExpiresAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiresAt"
  , sessionId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , sessionIdp :: !(Maybe SessionIdentityProvider) -- ^ "idp"
  , sessionLastFactorVerification :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastFactorVerification"
  , sessionLastPasswordVerification :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastPasswordVerification"
  , sessionLogin :: !(Maybe Text) -- ^ /ReadOnly/ "login"
  , sessionStatus :: !(Maybe SessionStatus) -- ^ "status"
  , sessionUserId :: !(Maybe Text) -- ^ /ReadOnly/ "userId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Session
instance A.FromJSON Session where
  parseJSON = A.withObject "Session" $ \o ->
    Session
      <$> (o .:? "_links")
      <*> (o .:? "amr")
      <*> (o .:? "createdAt")
      <*> (o .:? "expiresAt")
      <*> (o .:? "id")
      <*> (o .:? "idp")
      <*> (o .:? "lastFactorVerification")
      <*> (o .:? "lastPasswordVerification")
      <*> (o .:? "login")
      <*> (o .:? "status")
      <*> (o .:? "userId")

-- | ToJSON Session
instance A.ToJSON Session where
  toJSON Session {..} =
   _omitNulls
      [ "_links" .= sessionLinks
      , "amr" .= sessionAmr
      , "createdAt" .= sessionCreatedAt
      , "expiresAt" .= sessionExpiresAt
      , "id" .= sessionId
      , "idp" .= sessionIdp
      , "lastFactorVerification" .= sessionLastFactorVerification
      , "lastPasswordVerification" .= sessionLastPasswordVerification
      , "login" .= sessionLogin
      , "status" .= sessionStatus
      , "userId" .= sessionUserId
      ]


-- | Construct a value of type 'Session' (by applying it's required fields, if any)
mkSession
  :: Session
mkSession =
  Session
  { sessionLinks = Nothing
  , sessionAmr = Nothing
  , sessionCreatedAt = Nothing
  , sessionExpiresAt = Nothing
  , sessionId = Nothing
  , sessionIdp = Nothing
  , sessionLastFactorVerification = Nothing
  , sessionLastPasswordVerification = Nothing
  , sessionLogin = Nothing
  , sessionStatus = Nothing
  , sessionUserId = Nothing
  }

-- ** SessionIdentityProvider
-- | SessionIdentityProvider
data SessionIdentityProvider = SessionIdentityProvider
  { sessionIdentityProviderId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , sessionIdentityProviderType :: !(Maybe SessionIdentityProviderType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SessionIdentityProvider
instance A.FromJSON SessionIdentityProvider where
  parseJSON = A.withObject "SessionIdentityProvider" $ \o ->
    SessionIdentityProvider
      <$> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON SessionIdentityProvider
instance A.ToJSON SessionIdentityProvider where
  toJSON SessionIdentityProvider {..} =
   _omitNulls
      [ "id" .= sessionIdentityProviderId
      , "type" .= sessionIdentityProviderType
      ]


-- | Construct a value of type 'SessionIdentityProvider' (by applying it's required fields, if any)
mkSessionIdentityProvider
  :: SessionIdentityProvider
mkSessionIdentityProvider =
  SessionIdentityProvider
  { sessionIdentityProviderId = Nothing
  , sessionIdentityProviderType = Nothing
  }

-- ** SignOnInlineHook
-- | SignOnInlineHook
data SignOnInlineHook = SignOnInlineHook
  { signOnInlineHookId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SignOnInlineHook
instance A.FromJSON SignOnInlineHook where
  parseJSON = A.withObject "SignOnInlineHook" $ \o ->
    SignOnInlineHook
      <$> (o .:? "id")

-- | ToJSON SignOnInlineHook
instance A.ToJSON SignOnInlineHook where
  toJSON SignOnInlineHook {..} =
   _omitNulls
      [ "id" .= signOnInlineHookId
      ]


-- | Construct a value of type 'SignOnInlineHook' (by applying it's required fields, if any)
mkSignOnInlineHook
  :: SignOnInlineHook
mkSignOnInlineHook =
  SignOnInlineHook
  { signOnInlineHookId = Nothing
  }

-- ** SingleLogout
-- | SingleLogout
data SingleLogout = SingleLogout
  { singleLogoutEnabled :: !(Maybe Bool) -- ^ "enabled"
  , singleLogoutIssuer :: !(Maybe Text) -- ^ "issuer"
  , singleLogoutLogoutUrl :: !(Maybe Text) -- ^ "logoutUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SingleLogout
instance A.FromJSON SingleLogout where
  parseJSON = A.withObject "SingleLogout" $ \o ->
    SingleLogout
      <$> (o .:? "enabled")
      <*> (o .:? "issuer")
      <*> (o .:? "logoutUrl")

-- | ToJSON SingleLogout
instance A.ToJSON SingleLogout where
  toJSON SingleLogout {..} =
   _omitNulls
      [ "enabled" .= singleLogoutEnabled
      , "issuer" .= singleLogoutIssuer
      , "logoutUrl" .= singleLogoutLogoutUrl
      ]


-- | Construct a value of type 'SingleLogout' (by applying it's required fields, if any)
mkSingleLogout
  :: SingleLogout
mkSingleLogout =
  SingleLogout
  { singleLogoutEnabled = Nothing
  , singleLogoutIssuer = Nothing
  , singleLogoutLogoutUrl = Nothing
  }

-- ** SmsTemplate
-- | SmsTemplate
data SmsTemplate = SmsTemplate
  { smsTemplateCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , smsTemplateId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , smsTemplateLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , smsTemplateName :: !(Maybe Text) -- ^ "name"
  , smsTemplateTemplate :: !(Maybe Text) -- ^ "template"
  , smsTemplateTranslations :: !(Maybe A.Value) -- ^ "translations"
  , smsTemplateType :: !(Maybe SmsTemplateType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmsTemplate
instance A.FromJSON SmsTemplate where
  parseJSON = A.withObject "SmsTemplate" $ \o ->
    SmsTemplate
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "template")
      <*> (o .:? "translations")
      <*> (o .:? "type")

-- | ToJSON SmsTemplate
instance A.ToJSON SmsTemplate where
  toJSON SmsTemplate {..} =
   _omitNulls
      [ "created" .= smsTemplateCreated
      , "id" .= smsTemplateId
      , "lastUpdated" .= smsTemplateLastUpdated
      , "name" .= smsTemplateName
      , "template" .= smsTemplateTemplate
      , "translations" .= smsTemplateTranslations
      , "type" .= smsTemplateType
      ]


-- | Construct a value of type 'SmsTemplate' (by applying it's required fields, if any)
mkSmsTemplate
  :: SmsTemplate
mkSmsTemplate =
  SmsTemplate
  { smsTemplateCreated = Nothing
  , smsTemplateId = Nothing
  , smsTemplateLastUpdated = Nothing
  , smsTemplateName = Nothing
  , smsTemplateTemplate = Nothing
  , smsTemplateTranslations = Nothing
  , smsTemplateType = Nothing
  }

-- ** SmsUserFactor
-- | SmsUserFactor
data SmsUserFactor = SmsUserFactor
  { smsUserFactorProfile :: !(Maybe SmsUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmsUserFactor
instance A.FromJSON SmsUserFactor where
  parseJSON = A.withObject "SmsUserFactor" $ \o ->
    SmsUserFactor
      <$> (o .:? "profile")

-- | ToJSON SmsUserFactor
instance A.ToJSON SmsUserFactor where
  toJSON SmsUserFactor {..} =
   _omitNulls
      [ "profile" .= smsUserFactorProfile
      ]


-- | Construct a value of type 'SmsUserFactor' (by applying it's required fields, if any)
mkSmsUserFactor
  :: SmsUserFactor
mkSmsUserFactor =
  SmsUserFactor
  { smsUserFactorProfile = Nothing
  }

-- ** SmsUserFactorProfile
-- | SmsUserFactorProfile
data SmsUserFactorProfile = SmsUserFactorProfile
  { smsUserFactorProfilePhoneNumber :: !(Maybe Text) -- ^ "phoneNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmsUserFactorProfile
instance A.FromJSON SmsUserFactorProfile where
  parseJSON = A.withObject "SmsUserFactorProfile" $ \o ->
    SmsUserFactorProfile
      <$> (o .:? "phoneNumber")

-- | ToJSON SmsUserFactorProfile
instance A.ToJSON SmsUserFactorProfile where
  toJSON SmsUserFactorProfile {..} =
   _omitNulls
      [ "phoneNumber" .= smsUserFactorProfilePhoneNumber
      ]


-- | Construct a value of type 'SmsUserFactorProfile' (by applying it's required fields, if any)
mkSmsUserFactorProfile
  :: SmsUserFactorProfile
mkSmsUserFactorProfile =
  SmsUserFactorProfile
  { smsUserFactorProfilePhoneNumber = Nothing
  }

-- ** SocialAuthToken
-- | SocialAuthToken
data SocialAuthToken = SocialAuthToken
  { socialAuthTokenExpiresAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiresAt"
  , socialAuthTokenId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , socialAuthTokenScopes :: !(Maybe [Text]) -- ^ "scopes"
  , socialAuthTokenToken :: !(Maybe Text) -- ^ "token"
  , socialAuthTokenTokenAuthScheme :: !(Maybe Text) -- ^ "tokenAuthScheme"
  , socialAuthTokenTokenType :: !(Maybe Text) -- ^ "tokenType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SocialAuthToken
instance A.FromJSON SocialAuthToken where
  parseJSON = A.withObject "SocialAuthToken" $ \o ->
    SocialAuthToken
      <$> (o .:? "expiresAt")
      <*> (o .:? "id")
      <*> (o .:? "scopes")
      <*> (o .:? "token")
      <*> (o .:? "tokenAuthScheme")
      <*> (o .:? "tokenType")

-- | ToJSON SocialAuthToken
instance A.ToJSON SocialAuthToken where
  toJSON SocialAuthToken {..} =
   _omitNulls
      [ "expiresAt" .= socialAuthTokenExpiresAt
      , "id" .= socialAuthTokenId
      , "scopes" .= socialAuthTokenScopes
      , "token" .= socialAuthTokenToken
      , "tokenAuthScheme" .= socialAuthTokenTokenAuthScheme
      , "tokenType" .= socialAuthTokenTokenType
      ]


-- | Construct a value of type 'SocialAuthToken' (by applying it's required fields, if any)
mkSocialAuthToken
  :: SocialAuthToken
mkSocialAuthToken =
  SocialAuthToken
  { socialAuthTokenExpiresAt = Nothing
  , socialAuthTokenId = Nothing
  , socialAuthTokenScopes = Nothing
  , socialAuthTokenToken = Nothing
  , socialAuthTokenTokenAuthScheme = Nothing
  , socialAuthTokenTokenType = Nothing
  }

-- ** SpCertificate
-- | SpCertificate
data SpCertificate = SpCertificate
  { spCertificateX5c :: !(Maybe [Text]) -- ^ "x5c"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SpCertificate
instance A.FromJSON SpCertificate where
  parseJSON = A.withObject "SpCertificate" $ \o ->
    SpCertificate
      <$> (o .:? "x5c")

-- | ToJSON SpCertificate
instance A.ToJSON SpCertificate where
  toJSON SpCertificate {..} =
   _omitNulls
      [ "x5c" .= spCertificateX5c
      ]


-- | Construct a value of type 'SpCertificate' (by applying it's required fields, if any)
mkSpCertificate
  :: SpCertificate
mkSpCertificate =
  SpCertificate
  { spCertificateX5c = Nothing
  }

-- ** Subscription
-- | Subscription
data Subscription = Subscription
  { subscriptionNotificationType :: !(Maybe NotificationType) -- ^ "notificationType"
  , subscriptionChannels :: !(Maybe [Text]) -- ^ "channels"
  , subscriptionStatus :: !(Maybe SubscriptionStatus) -- ^ "status"
  , subscriptionLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Subscription
instance A.FromJSON Subscription where
  parseJSON = A.withObject "Subscription" $ \o ->
    Subscription
      <$> (o .:? "notificationType")
      <*> (o .:? "channels")
      <*> (o .:? "status")
      <*> (o .:? "_links")

-- | ToJSON Subscription
instance A.ToJSON Subscription where
  toJSON Subscription {..} =
   _omitNulls
      [ "notificationType" .= subscriptionNotificationType
      , "channels" .= subscriptionChannels
      , "status" .= subscriptionStatus
      , "_links" .= subscriptionLinks
      ]


-- | Construct a value of type 'Subscription' (by applying it's required fields, if any)
mkSubscription
  :: Subscription
mkSubscription =
  Subscription
  { subscriptionNotificationType = Nothing
  , subscriptionChannels = Nothing
  , subscriptionStatus = Nothing
  , subscriptionLinks = Nothing
  }

-- ** SwaApplication
-- | SwaApplication
data SwaApplication = SwaApplication
  { swaApplicationName :: !(Maybe A.Value) -- ^ "name"
  , swaApplicationSettings :: !(Maybe SwaApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaApplication
instance A.FromJSON SwaApplication where
  parseJSON = A.withObject "SwaApplication" $ \o ->
    SwaApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON SwaApplication
instance A.ToJSON SwaApplication where
  toJSON SwaApplication {..} =
   _omitNulls
      [ "name" .= swaApplicationName
      , "settings" .= swaApplicationSettings
      ]


-- | Construct a value of type 'SwaApplication' (by applying it's required fields, if any)
mkSwaApplication
  :: SwaApplication
mkSwaApplication =
  SwaApplication
  { swaApplicationName = Nothing
  , swaApplicationSettings = Nothing
  }

-- ** SwaApplicationSettings
-- | SwaApplicationSettings
data SwaApplicationSettings = SwaApplicationSettings
  { swaApplicationSettingsApp :: !(Maybe SwaApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaApplicationSettings
instance A.FromJSON SwaApplicationSettings where
  parseJSON = A.withObject "SwaApplicationSettings" $ \o ->
    SwaApplicationSettings
      <$> (o .:? "app")

-- | ToJSON SwaApplicationSettings
instance A.ToJSON SwaApplicationSettings where
  toJSON SwaApplicationSettings {..} =
   _omitNulls
      [ "app" .= swaApplicationSettingsApp
      ]


-- | Construct a value of type 'SwaApplicationSettings' (by applying it's required fields, if any)
mkSwaApplicationSettings
  :: SwaApplicationSettings
mkSwaApplicationSettings =
  SwaApplicationSettings
  { swaApplicationSettingsApp = Nothing
  }

-- ** SwaApplicationSettingsApplication
-- | SwaApplicationSettingsApplication
data SwaApplicationSettingsApplication = SwaApplicationSettingsApplication
  { swaApplicationSettingsApplicationButtonField :: !(Maybe Text) -- ^ "buttonField"
  , swaApplicationSettingsApplicationLoginUrlRegex :: !(Maybe Text) -- ^ "loginUrlRegex"
  , swaApplicationSettingsApplicationPasswordField :: !(Maybe Text) -- ^ "passwordField"
  , swaApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  , swaApplicationSettingsApplicationUsernameField :: !(Maybe Text) -- ^ "usernameField"
  , swaApplicationSettingsApplicationRedirectUrl :: !(Maybe Text) -- ^ "redirectUrl"
  , swaApplicationSettingsApplicationCheckbox :: !(Maybe Text) -- ^ "checkbox"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaApplicationSettingsApplication
instance A.FromJSON SwaApplicationSettingsApplication where
  parseJSON = A.withObject "SwaApplicationSettingsApplication" $ \o ->
    SwaApplicationSettingsApplication
      <$> (o .:? "buttonField")
      <*> (o .:? "loginUrlRegex")
      <*> (o .:? "passwordField")
      <*> (o .:? "url")
      <*> (o .:? "usernameField")
      <*> (o .:? "redirectUrl")
      <*> (o .:? "checkbox")

-- | ToJSON SwaApplicationSettingsApplication
instance A.ToJSON SwaApplicationSettingsApplication where
  toJSON SwaApplicationSettingsApplication {..} =
   _omitNulls
      [ "buttonField" .= swaApplicationSettingsApplicationButtonField
      , "loginUrlRegex" .= swaApplicationSettingsApplicationLoginUrlRegex
      , "passwordField" .= swaApplicationSettingsApplicationPasswordField
      , "url" .= swaApplicationSettingsApplicationUrl
      , "usernameField" .= swaApplicationSettingsApplicationUsernameField
      , "redirectUrl" .= swaApplicationSettingsApplicationRedirectUrl
      , "checkbox" .= swaApplicationSettingsApplicationCheckbox
      ]


-- | Construct a value of type 'SwaApplicationSettingsApplication' (by applying it's required fields, if any)
mkSwaApplicationSettingsApplication
  :: SwaApplicationSettingsApplication
mkSwaApplicationSettingsApplication =
  SwaApplicationSettingsApplication
  { swaApplicationSettingsApplicationButtonField = Nothing
  , swaApplicationSettingsApplicationLoginUrlRegex = Nothing
  , swaApplicationSettingsApplicationPasswordField = Nothing
  , swaApplicationSettingsApplicationUrl = Nothing
  , swaApplicationSettingsApplicationUsernameField = Nothing
  , swaApplicationSettingsApplicationRedirectUrl = Nothing
  , swaApplicationSettingsApplicationCheckbox = Nothing
  }

-- ** SwaThreeFieldApplication
-- | SwaThreeFieldApplication
data SwaThreeFieldApplication = SwaThreeFieldApplication
  { swaThreeFieldApplicationName :: !(Maybe A.Value) -- ^ "name"
  , swaThreeFieldApplicationSettings :: !(Maybe SwaThreeFieldApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaThreeFieldApplication
instance A.FromJSON SwaThreeFieldApplication where
  parseJSON = A.withObject "SwaThreeFieldApplication" $ \o ->
    SwaThreeFieldApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON SwaThreeFieldApplication
instance A.ToJSON SwaThreeFieldApplication where
  toJSON SwaThreeFieldApplication {..} =
   _omitNulls
      [ "name" .= swaThreeFieldApplicationName
      , "settings" .= swaThreeFieldApplicationSettings
      ]


-- | Construct a value of type 'SwaThreeFieldApplication' (by applying it's required fields, if any)
mkSwaThreeFieldApplication
  :: SwaThreeFieldApplication
mkSwaThreeFieldApplication =
  SwaThreeFieldApplication
  { swaThreeFieldApplicationName = Nothing
  , swaThreeFieldApplicationSettings = Nothing
  }

-- ** SwaThreeFieldApplicationSettings
-- | SwaThreeFieldApplicationSettings
data SwaThreeFieldApplicationSettings = SwaThreeFieldApplicationSettings
  { swaThreeFieldApplicationSettingsApp :: !(Maybe SwaThreeFieldApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaThreeFieldApplicationSettings
instance A.FromJSON SwaThreeFieldApplicationSettings where
  parseJSON = A.withObject "SwaThreeFieldApplicationSettings" $ \o ->
    SwaThreeFieldApplicationSettings
      <$> (o .:? "app")

-- | ToJSON SwaThreeFieldApplicationSettings
instance A.ToJSON SwaThreeFieldApplicationSettings where
  toJSON SwaThreeFieldApplicationSettings {..} =
   _omitNulls
      [ "app" .= swaThreeFieldApplicationSettingsApp
      ]


-- | Construct a value of type 'SwaThreeFieldApplicationSettings' (by applying it's required fields, if any)
mkSwaThreeFieldApplicationSettings
  :: SwaThreeFieldApplicationSettings
mkSwaThreeFieldApplicationSettings =
  SwaThreeFieldApplicationSettings
  { swaThreeFieldApplicationSettingsApp = Nothing
  }

-- ** SwaThreeFieldApplicationSettingsApplication
-- | SwaThreeFieldApplicationSettingsApplication
data SwaThreeFieldApplicationSettingsApplication = SwaThreeFieldApplicationSettingsApplication
  { swaThreeFieldApplicationSettingsApplicationButtonSelector :: !(Maybe Text) -- ^ "buttonSelector"
  , swaThreeFieldApplicationSettingsApplicationExtraFieldSelector :: !(Maybe Text) -- ^ "extraFieldSelector"
  , swaThreeFieldApplicationSettingsApplicationExtraFieldValue :: !(Maybe Text) -- ^ "extraFieldValue"
  , swaThreeFieldApplicationSettingsApplicationLoginUrlRegex :: !(Maybe Text) -- ^ "loginUrlRegex"
  , swaThreeFieldApplicationSettingsApplicationPasswordSelector :: !(Maybe Text) -- ^ "passwordSelector"
  , swaThreeFieldApplicationSettingsApplicationTargetUrl :: !(Maybe Text) -- ^ "targetURL"
  , swaThreeFieldApplicationSettingsApplicationUserNameSelector :: !(Maybe Text) -- ^ "userNameSelector"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaThreeFieldApplicationSettingsApplication
instance A.FromJSON SwaThreeFieldApplicationSettingsApplication where
  parseJSON = A.withObject "SwaThreeFieldApplicationSettingsApplication" $ \o ->
    SwaThreeFieldApplicationSettingsApplication
      <$> (o .:? "buttonSelector")
      <*> (o .:? "extraFieldSelector")
      <*> (o .:? "extraFieldValue")
      <*> (o .:? "loginUrlRegex")
      <*> (o .:? "passwordSelector")
      <*> (o .:? "targetURL")
      <*> (o .:? "userNameSelector")

-- | ToJSON SwaThreeFieldApplicationSettingsApplication
instance A.ToJSON SwaThreeFieldApplicationSettingsApplication where
  toJSON SwaThreeFieldApplicationSettingsApplication {..} =
   _omitNulls
      [ "buttonSelector" .= swaThreeFieldApplicationSettingsApplicationButtonSelector
      , "extraFieldSelector" .= swaThreeFieldApplicationSettingsApplicationExtraFieldSelector
      , "extraFieldValue" .= swaThreeFieldApplicationSettingsApplicationExtraFieldValue
      , "loginUrlRegex" .= swaThreeFieldApplicationSettingsApplicationLoginUrlRegex
      , "passwordSelector" .= swaThreeFieldApplicationSettingsApplicationPasswordSelector
      , "targetURL" .= swaThreeFieldApplicationSettingsApplicationTargetUrl
      , "userNameSelector" .= swaThreeFieldApplicationSettingsApplicationUserNameSelector
      ]


-- | Construct a value of type 'SwaThreeFieldApplicationSettingsApplication' (by applying it's required fields, if any)
mkSwaThreeFieldApplicationSettingsApplication
  :: SwaThreeFieldApplicationSettingsApplication
mkSwaThreeFieldApplicationSettingsApplication =
  SwaThreeFieldApplicationSettingsApplication
  { swaThreeFieldApplicationSettingsApplicationButtonSelector = Nothing
  , swaThreeFieldApplicationSettingsApplicationExtraFieldSelector = Nothing
  , swaThreeFieldApplicationSettingsApplicationExtraFieldValue = Nothing
  , swaThreeFieldApplicationSettingsApplicationLoginUrlRegex = Nothing
  , swaThreeFieldApplicationSettingsApplicationPasswordSelector = Nothing
  , swaThreeFieldApplicationSettingsApplicationTargetUrl = Nothing
  , swaThreeFieldApplicationSettingsApplicationUserNameSelector = Nothing
  }

-- ** TempPassword
-- | TempPassword
data TempPassword = TempPassword
  { tempPasswordTempPassword :: !(Maybe Text) -- ^ /ReadOnly/ "tempPassword"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TempPassword
instance A.FromJSON TempPassword where
  parseJSON = A.withObject "TempPassword" $ \o ->
    TempPassword
      <$> (o .:? "tempPassword")

-- | ToJSON TempPassword
instance A.ToJSON TempPassword where
  toJSON TempPassword {..} =
   _omitNulls
      [ "tempPassword" .= tempPasswordTempPassword
      ]


-- | Construct a value of type 'TempPassword' (by applying it's required fields, if any)
mkTempPassword
  :: TempPassword
mkTempPassword =
  TempPassword
  { tempPasswordTempPassword = Nothing
  }

-- ** Theme
-- | Theme
data Theme = Theme
  { themeBackgroundImage :: !(Maybe Text) -- ^ /ReadOnly/ "backgroundImage"
  , themePrimaryColorHex :: !(Maybe Text) -- ^ "primaryColorHex"
  , themePrimaryColorContrastHex :: !(Maybe Text) -- ^ "primaryColorContrastHex"
  , themeSecondaryColorHex :: !(Maybe Text) -- ^ "secondaryColorHex"
  , themeSecondaryColorContrastHex :: !(Maybe Text) -- ^ "secondaryColorContrastHex"
  , themeSignInPageTouchPointVariant :: !(Maybe SignInPageTouchPointVariant) -- ^ "signInPageTouchPointVariant"
  , themeEndUserDashboardTouchPointVariant :: !(Maybe EndUserDashboardTouchPointVariant) -- ^ "endUserDashboardTouchPointVariant"
  , themeErrorPageTouchPointVariant :: !(Maybe ErrorPageTouchPointVariant) -- ^ "errorPageTouchPointVariant"
  , themeEmailTemplateTouchPointVariant :: !(Maybe EmailTemplateTouchPointVariant) -- ^ "emailTemplateTouchPointVariant"
  , themeLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Theme
instance A.FromJSON Theme where
  parseJSON = A.withObject "Theme" $ \o ->
    Theme
      <$> (o .:? "backgroundImage")
      <*> (o .:? "primaryColorHex")
      <*> (o .:? "primaryColorContrastHex")
      <*> (o .:? "secondaryColorHex")
      <*> (o .:? "secondaryColorContrastHex")
      <*> (o .:? "signInPageTouchPointVariant")
      <*> (o .:? "endUserDashboardTouchPointVariant")
      <*> (o .:? "errorPageTouchPointVariant")
      <*> (o .:? "emailTemplateTouchPointVariant")
      <*> (o .:? "_links")

-- | ToJSON Theme
instance A.ToJSON Theme where
  toJSON Theme {..} =
   _omitNulls
      [ "backgroundImage" .= themeBackgroundImage
      , "primaryColorHex" .= themePrimaryColorHex
      , "primaryColorContrastHex" .= themePrimaryColorContrastHex
      , "secondaryColorHex" .= themeSecondaryColorHex
      , "secondaryColorContrastHex" .= themeSecondaryColorContrastHex
      , "signInPageTouchPointVariant" .= themeSignInPageTouchPointVariant
      , "endUserDashboardTouchPointVariant" .= themeEndUserDashboardTouchPointVariant
      , "errorPageTouchPointVariant" .= themeErrorPageTouchPointVariant
      , "emailTemplateTouchPointVariant" .= themeEmailTemplateTouchPointVariant
      , "_links" .= themeLinks
      ]


-- | Construct a value of type 'Theme' (by applying it's required fields, if any)
mkTheme
  :: Theme
mkTheme =
  Theme
  { themeBackgroundImage = Nothing
  , themePrimaryColorHex = Nothing
  , themePrimaryColorContrastHex = Nothing
  , themeSecondaryColorHex = Nothing
  , themeSecondaryColorContrastHex = Nothing
  , themeSignInPageTouchPointVariant = Nothing
  , themeEndUserDashboardTouchPointVariant = Nothing
  , themeErrorPageTouchPointVariant = Nothing
  , themeEmailTemplateTouchPointVariant = Nothing
  , themeLinks = Nothing
  }

-- ** ThemeResponse
-- | ThemeResponse
data ThemeResponse = ThemeResponse
  { themeResponseId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , themeResponseLogo :: !(Maybe Text) -- ^ /ReadOnly/ "logo"
  , themeResponseFavicon :: !(Maybe Text) -- ^ /ReadOnly/ "favicon"
  , themeResponseBackgroundImage :: !(Maybe Text) -- ^ /ReadOnly/ "backgroundImage"
  , themeResponsePrimaryColorHex :: !(Maybe Text) -- ^ "primaryColorHex"
  , themeResponsePrimaryColorContrastHex :: !(Maybe Text) -- ^ "primaryColorContrastHex"
  , themeResponseSecondaryColorHex :: !(Maybe Text) -- ^ "secondaryColorHex"
  , themeResponseSecondaryColorContrastHex :: !(Maybe Text) -- ^ "secondaryColorContrastHex"
  , themeResponseSignInPageTouchPointVariant :: !(Maybe SignInPageTouchPointVariant) -- ^ "signInPageTouchPointVariant"
  , themeResponseEndUserDashboardTouchPointVariant :: !(Maybe EndUserDashboardTouchPointVariant) -- ^ "endUserDashboardTouchPointVariant"
  , themeResponseErrorPageTouchPointVariant :: !(Maybe ErrorPageTouchPointVariant) -- ^ "errorPageTouchPointVariant"
  , themeResponseEmailTemplateTouchPointVariant :: !(Maybe EmailTemplateTouchPointVariant) -- ^ "emailTemplateTouchPointVariant"
  , themeResponseLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThemeResponse
instance A.FromJSON ThemeResponse where
  parseJSON = A.withObject "ThemeResponse" $ \o ->
    ThemeResponse
      <$> (o .:? "id")
      <*> (o .:? "logo")
      <*> (o .:? "favicon")
      <*> (o .:? "backgroundImage")
      <*> (o .:? "primaryColorHex")
      <*> (o .:? "primaryColorContrastHex")
      <*> (o .:? "secondaryColorHex")
      <*> (o .:? "secondaryColorContrastHex")
      <*> (o .:? "signInPageTouchPointVariant")
      <*> (o .:? "endUserDashboardTouchPointVariant")
      <*> (o .:? "errorPageTouchPointVariant")
      <*> (o .:? "emailTemplateTouchPointVariant")
      <*> (o .:? "_links")

-- | ToJSON ThemeResponse
instance A.ToJSON ThemeResponse where
  toJSON ThemeResponse {..} =
   _omitNulls
      [ "id" .= themeResponseId
      , "logo" .= themeResponseLogo
      , "favicon" .= themeResponseFavicon
      , "backgroundImage" .= themeResponseBackgroundImage
      , "primaryColorHex" .= themeResponsePrimaryColorHex
      , "primaryColorContrastHex" .= themeResponsePrimaryColorContrastHex
      , "secondaryColorHex" .= themeResponseSecondaryColorHex
      , "secondaryColorContrastHex" .= themeResponseSecondaryColorContrastHex
      , "signInPageTouchPointVariant" .= themeResponseSignInPageTouchPointVariant
      , "endUserDashboardTouchPointVariant" .= themeResponseEndUserDashboardTouchPointVariant
      , "errorPageTouchPointVariant" .= themeResponseErrorPageTouchPointVariant
      , "emailTemplateTouchPointVariant" .= themeResponseEmailTemplateTouchPointVariant
      , "_links" .= themeResponseLinks
      ]


-- | Construct a value of type 'ThemeResponse' (by applying it's required fields, if any)
mkThemeResponse
  :: ThemeResponse
mkThemeResponse =
  ThemeResponse
  { themeResponseId = Nothing
  , themeResponseLogo = Nothing
  , themeResponseFavicon = Nothing
  , themeResponseBackgroundImage = Nothing
  , themeResponsePrimaryColorHex = Nothing
  , themeResponsePrimaryColorContrastHex = Nothing
  , themeResponseSecondaryColorHex = Nothing
  , themeResponseSecondaryColorContrastHex = Nothing
  , themeResponseSignInPageTouchPointVariant = Nothing
  , themeResponseEndUserDashboardTouchPointVariant = Nothing
  , themeResponseErrorPageTouchPointVariant = Nothing
  , themeResponseEmailTemplateTouchPointVariant = Nothing
  , themeResponseLinks = Nothing
  }

-- ** ThreatInsightConfiguration
-- | ThreatInsightConfiguration
data ThreatInsightConfiguration = ThreatInsightConfiguration
  { threatInsightConfigurationAction :: !(Maybe Text) -- ^ "action"
  , threatInsightConfigurationExcludeZones :: !(Maybe [Text]) -- ^ "excludeZones"
  , threatInsightConfigurationCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , threatInsightConfigurationLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , threatInsightConfigurationLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThreatInsightConfiguration
instance A.FromJSON ThreatInsightConfiguration where
  parseJSON = A.withObject "ThreatInsightConfiguration" $ \o ->
    ThreatInsightConfiguration
      <$> (o .:? "action")
      <*> (o .:? "excludeZones")
      <*> (o .:? "created")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "_links")

-- | ToJSON ThreatInsightConfiguration
instance A.ToJSON ThreatInsightConfiguration where
  toJSON ThreatInsightConfiguration {..} =
   _omitNulls
      [ "action" .= threatInsightConfigurationAction
      , "excludeZones" .= threatInsightConfigurationExcludeZones
      , "created" .= threatInsightConfigurationCreated
      , "lastUpdated" .= threatInsightConfigurationLastUpdated
      , "_links" .= threatInsightConfigurationLinks
      ]


-- | Construct a value of type 'ThreatInsightConfiguration' (by applying it's required fields, if any)
mkThreatInsightConfiguration
  :: ThreatInsightConfiguration
mkThreatInsightConfiguration =
  ThreatInsightConfiguration
  { threatInsightConfigurationAction = Nothing
  , threatInsightConfigurationExcludeZones = Nothing
  , threatInsightConfigurationCreated = Nothing
  , threatInsightConfigurationLastUpdated = Nothing
  , threatInsightConfigurationLinks = Nothing
  }

-- ** TokenAuthorizationServerPolicyRuleAction
-- | TokenAuthorizationServerPolicyRuleAction
data TokenAuthorizationServerPolicyRuleAction = TokenAuthorizationServerPolicyRuleAction
  { tokenAuthorizationServerPolicyRuleActionAccessTokenLifetimeMinutes :: !(Maybe Int) -- ^ "accessTokenLifetimeMinutes"
  , tokenAuthorizationServerPolicyRuleActionRefreshTokenLifetimeMinutes :: !(Maybe Int) -- ^ "refreshTokenLifetimeMinutes"
  , tokenAuthorizationServerPolicyRuleActionRefreshTokenWindowMinutes :: !(Maybe Int) -- ^ "refreshTokenWindowMinutes"
  , tokenAuthorizationServerPolicyRuleActionInlineHook :: !(Maybe TokenAuthorizationServerPolicyRuleActionInlineHook) -- ^ "inlineHook"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenAuthorizationServerPolicyRuleAction
instance A.FromJSON TokenAuthorizationServerPolicyRuleAction where
  parseJSON = A.withObject "TokenAuthorizationServerPolicyRuleAction" $ \o ->
    TokenAuthorizationServerPolicyRuleAction
      <$> (o .:? "accessTokenLifetimeMinutes")
      <*> (o .:? "refreshTokenLifetimeMinutes")
      <*> (o .:? "refreshTokenWindowMinutes")
      <*> (o .:? "inlineHook")

-- | ToJSON TokenAuthorizationServerPolicyRuleAction
instance A.ToJSON TokenAuthorizationServerPolicyRuleAction where
  toJSON TokenAuthorizationServerPolicyRuleAction {..} =
   _omitNulls
      [ "accessTokenLifetimeMinutes" .= tokenAuthorizationServerPolicyRuleActionAccessTokenLifetimeMinutes
      , "refreshTokenLifetimeMinutes" .= tokenAuthorizationServerPolicyRuleActionRefreshTokenLifetimeMinutes
      , "refreshTokenWindowMinutes" .= tokenAuthorizationServerPolicyRuleActionRefreshTokenWindowMinutes
      , "inlineHook" .= tokenAuthorizationServerPolicyRuleActionInlineHook
      ]


-- | Construct a value of type 'TokenAuthorizationServerPolicyRuleAction' (by applying it's required fields, if any)
mkTokenAuthorizationServerPolicyRuleAction
  :: TokenAuthorizationServerPolicyRuleAction
mkTokenAuthorizationServerPolicyRuleAction =
  TokenAuthorizationServerPolicyRuleAction
  { tokenAuthorizationServerPolicyRuleActionAccessTokenLifetimeMinutes = Nothing
  , tokenAuthorizationServerPolicyRuleActionRefreshTokenLifetimeMinutes = Nothing
  , tokenAuthorizationServerPolicyRuleActionRefreshTokenWindowMinutes = Nothing
  , tokenAuthorizationServerPolicyRuleActionInlineHook = Nothing
  }

-- ** TokenAuthorizationServerPolicyRuleActionInlineHook
-- | TokenAuthorizationServerPolicyRuleActionInlineHook
data TokenAuthorizationServerPolicyRuleActionInlineHook = TokenAuthorizationServerPolicyRuleActionInlineHook
  { tokenAuthorizationServerPolicyRuleActionInlineHookId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenAuthorizationServerPolicyRuleActionInlineHook
instance A.FromJSON TokenAuthorizationServerPolicyRuleActionInlineHook where
  parseJSON = A.withObject "TokenAuthorizationServerPolicyRuleActionInlineHook" $ \o ->
    TokenAuthorizationServerPolicyRuleActionInlineHook
      <$> (o .:? "id")

-- | ToJSON TokenAuthorizationServerPolicyRuleActionInlineHook
instance A.ToJSON TokenAuthorizationServerPolicyRuleActionInlineHook where
  toJSON TokenAuthorizationServerPolicyRuleActionInlineHook {..} =
   _omitNulls
      [ "id" .= tokenAuthorizationServerPolicyRuleActionInlineHookId
      ]


-- | Construct a value of type 'TokenAuthorizationServerPolicyRuleActionInlineHook' (by applying it's required fields, if any)
mkTokenAuthorizationServerPolicyRuleActionInlineHook
  :: TokenAuthorizationServerPolicyRuleActionInlineHook
mkTokenAuthorizationServerPolicyRuleActionInlineHook =
  TokenAuthorizationServerPolicyRuleActionInlineHook
  { tokenAuthorizationServerPolicyRuleActionInlineHookId = Nothing
  }

-- ** TokenUserFactor
-- | TokenUserFactor
data TokenUserFactor = TokenUserFactor
  { tokenUserFactorProfile :: !(Maybe TokenUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenUserFactor
instance A.FromJSON TokenUserFactor where
  parseJSON = A.withObject "TokenUserFactor" $ \o ->
    TokenUserFactor
      <$> (o .:? "profile")

-- | ToJSON TokenUserFactor
instance A.ToJSON TokenUserFactor where
  toJSON TokenUserFactor {..} =
   _omitNulls
      [ "profile" .= tokenUserFactorProfile
      ]


-- | Construct a value of type 'TokenUserFactor' (by applying it's required fields, if any)
mkTokenUserFactor
  :: TokenUserFactor
mkTokenUserFactor =
  TokenUserFactor
  { tokenUserFactorProfile = Nothing
  }

-- ** TokenUserFactorProfile
-- | TokenUserFactorProfile
data TokenUserFactorProfile = TokenUserFactorProfile
  { tokenUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenUserFactorProfile
instance A.FromJSON TokenUserFactorProfile where
  parseJSON = A.withObject "TokenUserFactorProfile" $ \o ->
    TokenUserFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON TokenUserFactorProfile
instance A.ToJSON TokenUserFactorProfile where
  toJSON TokenUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= tokenUserFactorProfileCredentialId
      ]


-- | Construct a value of type 'TokenUserFactorProfile' (by applying it's required fields, if any)
mkTokenUserFactorProfile
  :: TokenUserFactorProfile
mkTokenUserFactorProfile =
  TokenUserFactorProfile
  { tokenUserFactorProfileCredentialId = Nothing
  }

-- ** TotpUserFactor
-- | TotpUserFactor
data TotpUserFactor = TotpUserFactor
  { totpUserFactorProfile :: !(Maybe TotpUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TotpUserFactor
instance A.FromJSON TotpUserFactor where
  parseJSON = A.withObject "TotpUserFactor" $ \o ->
    TotpUserFactor
      <$> (o .:? "profile")

-- | ToJSON TotpUserFactor
instance A.ToJSON TotpUserFactor where
  toJSON TotpUserFactor {..} =
   _omitNulls
      [ "profile" .= totpUserFactorProfile
      ]


-- | Construct a value of type 'TotpUserFactor' (by applying it's required fields, if any)
mkTotpUserFactor
  :: TotpUserFactor
mkTotpUserFactor =
  TotpUserFactor
  { totpUserFactorProfile = Nothing
  }

-- ** TotpUserFactorProfile
-- | TotpUserFactorProfile
data TotpUserFactorProfile = TotpUserFactorProfile
  { totpUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TotpUserFactorProfile
instance A.FromJSON TotpUserFactorProfile where
  parseJSON = A.withObject "TotpUserFactorProfile" $ \o ->
    TotpUserFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON TotpUserFactorProfile
instance A.ToJSON TotpUserFactorProfile where
  toJSON TotpUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= totpUserFactorProfileCredentialId
      ]


-- | Construct a value of type 'TotpUserFactorProfile' (by applying it's required fields, if any)
mkTotpUserFactorProfile
  :: TotpUserFactorProfile
mkTotpUserFactorProfile =
  TotpUserFactorProfile
  { totpUserFactorProfileCredentialId = Nothing
  }

-- ** TrustedOrigin
-- | TrustedOrigin
data TrustedOrigin = TrustedOrigin
  { trustedOriginLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , trustedOriginCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , trustedOriginCreatedBy :: !(Maybe Text) -- ^ "createdBy"
  , trustedOriginId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , trustedOriginLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , trustedOriginLastUpdatedBy :: !(Maybe Text) -- ^ "lastUpdatedBy"
  , trustedOriginName :: !(Maybe Text) -- ^ "name"
  , trustedOriginOrigin :: !(Maybe Text) -- ^ "origin"
  , trustedOriginScopes :: !(Maybe [Scope]) -- ^ "scopes"
  , trustedOriginStatus :: !(Maybe Text) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TrustedOrigin
instance A.FromJSON TrustedOrigin where
  parseJSON = A.withObject "TrustedOrigin" $ \o ->
    TrustedOrigin
      <$> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "createdBy")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "lastUpdatedBy")
      <*> (o .:? "name")
      <*> (o .:? "origin")
      <*> (o .:? "scopes")
      <*> (o .:? "status")

-- | ToJSON TrustedOrigin
instance A.ToJSON TrustedOrigin where
  toJSON TrustedOrigin {..} =
   _omitNulls
      [ "_links" .= trustedOriginLinks
      , "created" .= trustedOriginCreated
      , "createdBy" .= trustedOriginCreatedBy
      , "id" .= trustedOriginId
      , "lastUpdated" .= trustedOriginLastUpdated
      , "lastUpdatedBy" .= trustedOriginLastUpdatedBy
      , "name" .= trustedOriginName
      , "origin" .= trustedOriginOrigin
      , "scopes" .= trustedOriginScopes
      , "status" .= trustedOriginStatus
      ]


-- | Construct a value of type 'TrustedOrigin' (by applying it's required fields, if any)
mkTrustedOrigin
  :: TrustedOrigin
mkTrustedOrigin =
  TrustedOrigin
  { trustedOriginLinks = Nothing
  , trustedOriginCreated = Nothing
  , trustedOriginCreatedBy = Nothing
  , trustedOriginId = Nothing
  , trustedOriginLastUpdated = Nothing
  , trustedOriginLastUpdatedBy = Nothing
  , trustedOriginName = Nothing
  , trustedOriginOrigin = Nothing
  , trustedOriginScopes = Nothing
  , trustedOriginStatus = Nothing
  }

-- ** U2fUserFactor
-- | U2fUserFactor
data U2fUserFactor = U2fUserFactor
  { u2fUserFactorProfile :: !(Maybe U2fUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON U2fUserFactor
instance A.FromJSON U2fUserFactor where
  parseJSON = A.withObject "U2fUserFactor" $ \o ->
    U2fUserFactor
      <$> (o .:? "profile")

-- | ToJSON U2fUserFactor
instance A.ToJSON U2fUserFactor where
  toJSON U2fUserFactor {..} =
   _omitNulls
      [ "profile" .= u2fUserFactorProfile
      ]


-- | Construct a value of type 'U2fUserFactor' (by applying it's required fields, if any)
mkU2fUserFactor
  :: U2fUserFactor
mkU2fUserFactor =
  U2fUserFactor
  { u2fUserFactorProfile = Nothing
  }

-- ** U2fUserFactorProfile
-- | U2fUserFactorProfile
data U2fUserFactorProfile = U2fUserFactorProfile
  { u2fUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON U2fUserFactorProfile
instance A.FromJSON U2fUserFactorProfile where
  parseJSON = A.withObject "U2fUserFactorProfile" $ \o ->
    U2fUserFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON U2fUserFactorProfile
instance A.ToJSON U2fUserFactorProfile where
  toJSON U2fUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= u2fUserFactorProfileCredentialId
      ]


-- | Construct a value of type 'U2fUserFactorProfile' (by applying it's required fields, if any)
mkU2fUserFactorProfile
  :: U2fUserFactorProfile
mkU2fUserFactorProfile =
  U2fUserFactorProfile
  { u2fUserFactorProfileCredentialId = Nothing
  }

-- | A quick hack to expose custom profile attributes by default
type User = UserP A.Object

-- | Access to typed original auto-generated UserProfile
type User' = UserP UserProfile

-- ** User
-- | User
data UserP p = User
  { userEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , userLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , userActivated :: !(Maybe DateTime) -- ^ /ReadOnly/ "activated"
  , userCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , userCredentials :: !(Maybe UserCredentials) -- ^ "credentials"
  , userGroupIds :: !(Maybe [Text]) -- ^ "groupIds"
  , userId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , userLastLogin :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastLogin"
  , userLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , userPasswordChanged :: !(Maybe DateTime) -- ^ /ReadOnly/ "passwordChanged"
  , userProfile :: !(Maybe p) -- ^ "profile"
  , userStatus :: !(Maybe UserStatus) -- ^ "status"
  , userStatusChanged :: !(Maybe DateTime) -- ^ /ReadOnly/ "statusChanged"
  , userTransitioningToStatus :: !(Maybe UserStatus) -- ^ "transitioningToStatus"
  , userType :: !(Maybe UserType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON p => A.FromJSON (UserP p) where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "activated")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "groupIds")
      <*> (o .:? "id")
      <*> (o .:? "lastLogin")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "passwordChanged")
      <*> (o .:? "profile")
      <*> (o .:? "status")
      <*> (o .:? "statusChanged")
      <*> (o .:? "transitioningToStatus")
      <*> (o .:? "type")

-- | ToJSON User
instance A.ToJSON p => A.ToJSON (UserP p) where
  toJSON User {..} =
   _omitNulls
      [ "_embedded" .= userEmbedded
      , "_links" .= userLinks
      , "activated" .= userActivated
      , "created" .= userCreated
      , "credentials" .= userCredentials
      , "groupIds" .= userGroupIds
      , "id" .= userId
      , "lastLogin" .= userLastLogin
      , "lastUpdated" .= userLastUpdated
      , "passwordChanged" .= userPasswordChanged
      , "profile" .= userProfile
      , "status" .= userStatus
      , "statusChanged" .= userStatusChanged
      , "transitioningToStatus" .= userTransitioningToStatus
      , "type" .= userType
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userEmbedded = Nothing
  , userLinks = Nothing
  , userActivated = Nothing
  , userCreated = Nothing
  , userCredentials = Nothing
  , userGroupIds = Nothing
  , userId = Nothing
  , userLastLogin = Nothing
  , userLastUpdated = Nothing
  , userPasswordChanged = Nothing
  , userProfile = Nothing
  , userStatus = Nothing
  , userStatusChanged = Nothing
  , userTransitioningToStatus = Nothing
  , userType = Nothing
  }

-- ** UserActivationToken
-- | UserActivationToken
data UserActivationToken = UserActivationToken
  { userActivationTokenActivationToken :: !(Maybe Text) -- ^ /ReadOnly/ "activationToken"
  , userActivationTokenActivationUrl :: !(Maybe Text) -- ^ /ReadOnly/ "activationUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserActivationToken
instance A.FromJSON UserActivationToken where
  parseJSON = A.withObject "UserActivationToken" $ \o ->
    UserActivationToken
      <$> (o .:? "activationToken")
      <*> (o .:? "activationUrl")

-- | ToJSON UserActivationToken
instance A.ToJSON UserActivationToken where
  toJSON UserActivationToken {..} =
   _omitNulls
      [ "activationToken" .= userActivationTokenActivationToken
      , "activationUrl" .= userActivationTokenActivationUrl
      ]


-- | Construct a value of type 'UserActivationToken' (by applying it's required fields, if any)
mkUserActivationToken
  :: UserActivationToken
mkUserActivationToken =
  UserActivationToken
  { userActivationTokenActivationToken = Nothing
  , userActivationTokenActivationUrl = Nothing
  }

-- ** UserCondition
-- | UserCondition
data UserCondition = UserCondition
  { userConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , userConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCondition
instance A.FromJSON UserCondition where
  parseJSON = A.withObject "UserCondition" $ \o ->
    UserCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON UserCondition
instance A.ToJSON UserCondition where
  toJSON UserCondition {..} =
   _omitNulls
      [ "exclude" .= userConditionExclude
      , "include" .= userConditionInclude
      ]


-- | Construct a value of type 'UserCondition' (by applying it's required fields, if any)
mkUserCondition
  :: UserCondition
mkUserCondition =
  UserCondition
  { userConditionExclude = Nothing
  , userConditionInclude = Nothing
  }

-- ** UserCredentials
-- | UserCredentials
data UserCredentials = UserCredentials
  { userCredentialsPassword :: !(Maybe PasswordCredential) -- ^ "password"
  , userCredentialsProvider :: !(Maybe AuthenticationProvider) -- ^ "provider"
  , userCredentialsRecoveryQuestion :: !(Maybe RecoveryQuestionCredential) -- ^ "recovery_question"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCredentials
instance A.FromJSON UserCredentials where
  parseJSON = A.withObject "UserCredentials" $ \o ->
    UserCredentials
      <$> (o .:? "password")
      <*> (o .:? "provider")
      <*> (o .:? "recovery_question")

-- | ToJSON UserCredentials
instance A.ToJSON UserCredentials where
  toJSON UserCredentials {..} =
   _omitNulls
      [ "password" .= userCredentialsPassword
      , "provider" .= userCredentialsProvider
      , "recovery_question" .= userCredentialsRecoveryQuestion
      ]


-- | Construct a value of type 'UserCredentials' (by applying it's required fields, if any)
mkUserCredentials
  :: UserCredentials
mkUserCredentials =
  UserCredentials
  { userCredentialsPassword = Nothing
  , userCredentialsProvider = Nothing
  , userCredentialsRecoveryQuestion = Nothing
  }

-- ** UserFactor
-- | UserFactor
data UserFactor = UserFactor
  { userFactorEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , userFactorLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , userFactorCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , userFactorFactorType :: !(Maybe FactorType) -- ^ "factorType"
  , userFactorId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , userFactorLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , userFactorProvider :: !(Maybe FactorProvider) -- ^ "provider"
  , userFactorStatus :: !(Maybe FactorStatus) -- ^ "status"
  , userFactorVerify :: !(Maybe VerifyFactorRequest) -- ^ "verify"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserFactor
instance A.FromJSON UserFactor where
  parseJSON = A.withObject "UserFactor" $ \o ->
    UserFactor
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "factorType")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "provider")
      <*> (o .:? "status")
      <*> (o .:? "verify")

-- | ToJSON UserFactor
instance A.ToJSON UserFactor where
  toJSON UserFactor {..} =
   _omitNulls
      [ "_embedded" .= userFactorEmbedded
      , "_links" .= userFactorLinks
      , "created" .= userFactorCreated
      , "factorType" .= userFactorFactorType
      , "id" .= userFactorId
      , "lastUpdated" .= userFactorLastUpdated
      , "provider" .= userFactorProvider
      , "status" .= userFactorStatus
      , "verify" .= userFactorVerify
      ]


-- | Construct a value of type 'UserFactor' (by applying it's required fields, if any)
mkUserFactor
  :: UserFactor
mkUserFactor =
  UserFactor
  { userFactorEmbedded = Nothing
  , userFactorLinks = Nothing
  , userFactorCreated = Nothing
  , userFactorFactorType = Nothing
  , userFactorId = Nothing
  , userFactorLastUpdated = Nothing
  , userFactorProvider = Nothing
  , userFactorStatus = Nothing
  , userFactorVerify = Nothing
  }

-- ** UserIdString
-- | UserIdString
data UserIdString = UserIdString
  { userIdStringUserId :: !(Maybe Text) -- ^ "userId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserIdString
instance A.FromJSON UserIdString where
  parseJSON = A.withObject "UserIdString" $ \o ->
    UserIdString
      <$> (o .:? "userId")

-- | ToJSON UserIdString
instance A.ToJSON UserIdString where
  toJSON UserIdString {..} =
   _omitNulls
      [ "userId" .= userIdStringUserId
      ]


-- | Construct a value of type 'UserIdString' (by applying it's required fields, if any)
mkUserIdString
  :: UserIdString
mkUserIdString =
  UserIdString
  { userIdStringUserId = Nothing
  }

-- ** UserIdentifierConditionEvaluatorPattern
-- | UserIdentifierConditionEvaluatorPattern
data UserIdentifierConditionEvaluatorPattern = UserIdentifierConditionEvaluatorPattern
  { userIdentifierConditionEvaluatorPatternMatchType :: !(Maybe E'MatchType2) -- ^ "matchType"
  , userIdentifierConditionEvaluatorPatternValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserIdentifierConditionEvaluatorPattern
instance A.FromJSON UserIdentifierConditionEvaluatorPattern where
  parseJSON = A.withObject "UserIdentifierConditionEvaluatorPattern" $ \o ->
    UserIdentifierConditionEvaluatorPattern
      <$> (o .:? "matchType")
      <*> (o .:? "value")

-- | ToJSON UserIdentifierConditionEvaluatorPattern
instance A.ToJSON UserIdentifierConditionEvaluatorPattern where
  toJSON UserIdentifierConditionEvaluatorPattern {..} =
   _omitNulls
      [ "matchType" .= userIdentifierConditionEvaluatorPatternMatchType
      , "value" .= userIdentifierConditionEvaluatorPatternValue
      ]


-- | Construct a value of type 'UserIdentifierConditionEvaluatorPattern' (by applying it's required fields, if any)
mkUserIdentifierConditionEvaluatorPattern
  :: UserIdentifierConditionEvaluatorPattern
mkUserIdentifierConditionEvaluatorPattern =
  UserIdentifierConditionEvaluatorPattern
  { userIdentifierConditionEvaluatorPatternMatchType = Nothing
  , userIdentifierConditionEvaluatorPatternValue = Nothing
  }

-- ** UserIdentifierPolicyRuleCondition
-- | UserIdentifierPolicyRuleCondition
data UserIdentifierPolicyRuleCondition = UserIdentifierPolicyRuleCondition
  { userIdentifierPolicyRuleConditionAttribute :: !(Maybe Text) -- ^ "attribute"
  , userIdentifierPolicyRuleConditionPatterns :: !(Maybe [UserIdentifierConditionEvaluatorPattern]) -- ^ "patterns"
  , userIdentifierPolicyRuleConditionType :: !(Maybe E'Type11) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserIdentifierPolicyRuleCondition
instance A.FromJSON UserIdentifierPolicyRuleCondition where
  parseJSON = A.withObject "UserIdentifierPolicyRuleCondition" $ \o ->
    UserIdentifierPolicyRuleCondition
      <$> (o .:? "attribute")
      <*> (o .:? "patterns")
      <*> (o .:? "type")

-- | ToJSON UserIdentifierPolicyRuleCondition
instance A.ToJSON UserIdentifierPolicyRuleCondition where
  toJSON UserIdentifierPolicyRuleCondition {..} =
   _omitNulls
      [ "attribute" .= userIdentifierPolicyRuleConditionAttribute
      , "patterns" .= userIdentifierPolicyRuleConditionPatterns
      , "type" .= userIdentifierPolicyRuleConditionType
      ]


-- | Construct a value of type 'UserIdentifierPolicyRuleCondition' (by applying it's required fields, if any)
mkUserIdentifierPolicyRuleCondition
  :: UserIdentifierPolicyRuleCondition
mkUserIdentifierPolicyRuleCondition =
  UserIdentifierPolicyRuleCondition
  { userIdentifierPolicyRuleConditionAttribute = Nothing
  , userIdentifierPolicyRuleConditionPatterns = Nothing
  , userIdentifierPolicyRuleConditionType = Nothing
  }

-- ** UserIdentityProviderLinkRequest
-- | UserIdentityProviderLinkRequest
data UserIdentityProviderLinkRequest = UserIdentityProviderLinkRequest
  { userIdentityProviderLinkRequestExternalId :: !(Maybe Text) -- ^ "externalId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserIdentityProviderLinkRequest
instance A.FromJSON UserIdentityProviderLinkRequest where
  parseJSON = A.withObject "UserIdentityProviderLinkRequest" $ \o ->
    UserIdentityProviderLinkRequest
      <$> (o .:? "externalId")

-- | ToJSON UserIdentityProviderLinkRequest
instance A.ToJSON UserIdentityProviderLinkRequest where
  toJSON UserIdentityProviderLinkRequest {..} =
   _omitNulls
      [ "externalId" .= userIdentityProviderLinkRequestExternalId
      ]


-- | Construct a value of type 'UserIdentityProviderLinkRequest' (by applying it's required fields, if any)
mkUserIdentityProviderLinkRequest
  :: UserIdentityProviderLinkRequest
mkUserIdentityProviderLinkRequest =
  UserIdentityProviderLinkRequest
  { userIdentityProviderLinkRequestExternalId = Nothing
  }

-- ** UserLifecycleAttributePolicyRuleCondition
-- | UserLifecycleAttributePolicyRuleCondition
data UserLifecycleAttributePolicyRuleCondition = UserLifecycleAttributePolicyRuleCondition
  { userLifecycleAttributePolicyRuleConditionAttributeName :: !(Maybe Text) -- ^ "attributeName"
  , userLifecycleAttributePolicyRuleConditionMatchingValue :: !(Maybe Text) -- ^ "matchingValue"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserLifecycleAttributePolicyRuleCondition
instance A.FromJSON UserLifecycleAttributePolicyRuleCondition where
  parseJSON = A.withObject "UserLifecycleAttributePolicyRuleCondition" $ \o ->
    UserLifecycleAttributePolicyRuleCondition
      <$> (o .:? "attributeName")
      <*> (o .:? "matchingValue")

-- | ToJSON UserLifecycleAttributePolicyRuleCondition
instance A.ToJSON UserLifecycleAttributePolicyRuleCondition where
  toJSON UserLifecycleAttributePolicyRuleCondition {..} =
   _omitNulls
      [ "attributeName" .= userLifecycleAttributePolicyRuleConditionAttributeName
      , "matchingValue" .= userLifecycleAttributePolicyRuleConditionMatchingValue
      ]


-- | Construct a value of type 'UserLifecycleAttributePolicyRuleCondition' (by applying it's required fields, if any)
mkUserLifecycleAttributePolicyRuleCondition
  :: UserLifecycleAttributePolicyRuleCondition
mkUserLifecycleAttributePolicyRuleCondition =
  UserLifecycleAttributePolicyRuleCondition
  { userLifecycleAttributePolicyRuleConditionAttributeName = Nothing
  , userLifecycleAttributePolicyRuleConditionMatchingValue = Nothing
  }

-- ** UserPolicyRuleCondition
-- | UserPolicyRuleCondition
data UserPolicyRuleCondition = UserPolicyRuleCondition
  { userPolicyRuleConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , userPolicyRuleConditionInactivity :: !(Maybe InactivityPolicyRuleCondition) -- ^ "inactivity"
  , userPolicyRuleConditionInclude :: !(Maybe [Text]) -- ^ "include"
  , userPolicyRuleConditionLifecycleExpiration :: !(Maybe LifecycleExpirationPolicyRuleCondition) -- ^ "lifecycleExpiration"
  , userPolicyRuleConditionPasswordExpiration :: !(Maybe PasswordExpirationPolicyRuleCondition) -- ^ "passwordExpiration"
  , userPolicyRuleConditionUserLifecycleAttribute :: !(Maybe UserLifecycleAttributePolicyRuleCondition) -- ^ "userLifecycleAttribute"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserPolicyRuleCondition
instance A.FromJSON UserPolicyRuleCondition where
  parseJSON = A.withObject "UserPolicyRuleCondition" $ \o ->
    UserPolicyRuleCondition
      <$> (o .:? "exclude")
      <*> (o .:? "inactivity")
      <*> (o .:? "include")
      <*> (o .:? "lifecycleExpiration")
      <*> (o .:? "passwordExpiration")
      <*> (o .:? "userLifecycleAttribute")

-- | ToJSON UserPolicyRuleCondition
instance A.ToJSON UserPolicyRuleCondition where
  toJSON UserPolicyRuleCondition {..} =
   _omitNulls
      [ "exclude" .= userPolicyRuleConditionExclude
      , "inactivity" .= userPolicyRuleConditionInactivity
      , "include" .= userPolicyRuleConditionInclude
      , "lifecycleExpiration" .= userPolicyRuleConditionLifecycleExpiration
      , "passwordExpiration" .= userPolicyRuleConditionPasswordExpiration
      , "userLifecycleAttribute" .= userPolicyRuleConditionUserLifecycleAttribute
      ]


-- | Construct a value of type 'UserPolicyRuleCondition' (by applying it's required fields, if any)
mkUserPolicyRuleCondition
  :: UserPolicyRuleCondition
mkUserPolicyRuleCondition =
  UserPolicyRuleCondition
  { userPolicyRuleConditionExclude = Nothing
  , userPolicyRuleConditionInactivity = Nothing
  , userPolicyRuleConditionInclude = Nothing
  , userPolicyRuleConditionLifecycleExpiration = Nothing
  , userPolicyRuleConditionPasswordExpiration = Nothing
  , userPolicyRuleConditionUserLifecycleAttribute = Nothing
  }

-- ** UserProfile
-- | UserProfile
data UserProfile = UserProfile
  { userProfileCity :: !(Maybe Text) -- ^ "city"
  , userProfileCostCenter :: !(Maybe Text) -- ^ "costCenter"
  , userProfileCountryCode :: !(Maybe Text) -- ^ "countryCode"
  , userProfileDepartment :: !(Maybe Text) -- ^ "department"
  , userProfileDisplayName :: !(Maybe Text) -- ^ "displayName"
  , userProfileDivision :: !(Maybe Text) -- ^ "division"
  , userProfileEmail :: !(Maybe Text) -- ^ "email"
  , userProfileEmployeeNumber :: !(Maybe Text) -- ^ "employeeNumber"
  , userProfileFirstName :: !(Maybe Text) -- ^ "firstName"
  , userProfileHonorificPrefix :: !(Maybe Text) -- ^ "honorificPrefix"
  , userProfileHonorificSuffix :: !(Maybe Text) -- ^ "honorificSuffix"
  , userProfileLastName :: !(Maybe Text) -- ^ "lastName"
  , userProfileLocale :: !(Maybe Text) -- ^ "locale"
  , userProfileLogin :: !(Maybe Text) -- ^ "login"
  , userProfileManager :: !(Maybe Text) -- ^ "manager"
  , userProfileManagerId :: !(Maybe Text) -- ^ "managerId"
  , userProfileMiddleName :: !(Maybe Text) -- ^ "middleName"
  , userProfileMobilePhone :: !(Maybe Text) -- ^ "mobilePhone"
  , userProfileNickName :: !(Maybe Text) -- ^ "nickName"
  , userProfileOrganization :: !(Maybe Text) -- ^ "organization"
  , userProfilePostalAddress :: !(Maybe Text) -- ^ "postalAddress"
  , userProfilePreferredLanguage :: !(Maybe Text) -- ^ "preferredLanguage"
  , userProfilePrimaryPhone :: !(Maybe Text) -- ^ "primaryPhone"
  , userProfileProfileUrl :: !(Maybe Text) -- ^ "profileUrl"
  , userProfileSecondEmail :: !(Maybe Text) -- ^ "secondEmail"
  , userProfileState :: !(Maybe Text) -- ^ "state"
  , userProfileStreetAddress :: !(Maybe Text) -- ^ "streetAddress"
  , userProfileTimezone :: !(Maybe Text) -- ^ "timezone"
  , userProfileTitle :: !(Maybe Text) -- ^ "title"
  , userProfileUserType :: !(Maybe Text) -- ^ "userType"
  , userProfileZipCode :: !(Maybe Text) -- ^ "zipCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserProfile
instance A.FromJSON UserProfile where
  parseJSON = A.withObject "UserProfile" $ \o ->
    UserProfile
      <$> (o .:? "city")
      <*> (o .:? "costCenter")
      <*> (o .:? "countryCode")
      <*> (o .:? "department")
      <*> (o .:? "displayName")
      <*> (o .:? "division")
      <*> (o .:? "email")
      <*> (o .:? "employeeNumber")
      <*> (o .:? "firstName")
      <*> (o .:? "honorificPrefix")
      <*> (o .:? "honorificSuffix")
      <*> (o .:? "lastName")
      <*> (o .:? "locale")
      <*> (o .:? "login")
      <*> (o .:? "manager")
      <*> (o .:? "managerId")
      <*> (o .:? "middleName")
      <*> (o .:? "mobilePhone")
      <*> (o .:? "nickName")
      <*> (o .:? "organization")
      <*> (o .:? "postalAddress")
      <*> (o .:? "preferredLanguage")
      <*> (o .:? "primaryPhone")
      <*> (o .:? "profileUrl")
      <*> (o .:? "secondEmail")
      <*> (o .:? "state")
      <*> (o .:? "streetAddress")
      <*> (o .:? "timezone")
      <*> (o .:? "title")
      <*> (o .:? "userType")
      <*> (o .:? "zipCode")

-- | ToJSON UserProfile
instance A.ToJSON UserProfile where
  toJSON UserProfile {..} =
   _omitNulls
      [ "city" .= userProfileCity
      , "costCenter" .= userProfileCostCenter
      , "countryCode" .= userProfileCountryCode
      , "department" .= userProfileDepartment
      , "displayName" .= userProfileDisplayName
      , "division" .= userProfileDivision
      , "email" .= userProfileEmail
      , "employeeNumber" .= userProfileEmployeeNumber
      , "firstName" .= userProfileFirstName
      , "honorificPrefix" .= userProfileHonorificPrefix
      , "honorificSuffix" .= userProfileHonorificSuffix
      , "lastName" .= userProfileLastName
      , "locale" .= userProfileLocale
      , "login" .= userProfileLogin
      , "manager" .= userProfileManager
      , "managerId" .= userProfileManagerId
      , "middleName" .= userProfileMiddleName
      , "mobilePhone" .= userProfileMobilePhone
      , "nickName" .= userProfileNickName
      , "organization" .= userProfileOrganization
      , "postalAddress" .= userProfilePostalAddress
      , "preferredLanguage" .= userProfilePreferredLanguage
      , "primaryPhone" .= userProfilePrimaryPhone
      , "profileUrl" .= userProfileProfileUrl
      , "secondEmail" .= userProfileSecondEmail
      , "state" .= userProfileState
      , "streetAddress" .= userProfileStreetAddress
      , "timezone" .= userProfileTimezone
      , "title" .= userProfileTitle
      , "userType" .= userProfileUserType
      , "zipCode" .= userProfileZipCode
      ]


-- | Construct a value of type 'UserProfile' (by applying it's required fields, if any)
mkUserProfile
  :: UserProfile
mkUserProfile =
  UserProfile
  { userProfileCity = Nothing
  , userProfileCostCenter = Nothing
  , userProfileCountryCode = Nothing
  , userProfileDepartment = Nothing
  , userProfileDisplayName = Nothing
  , userProfileDivision = Nothing
  , userProfileEmail = Nothing
  , userProfileEmployeeNumber = Nothing
  , userProfileFirstName = Nothing
  , userProfileHonorificPrefix = Nothing
  , userProfileHonorificSuffix = Nothing
  , userProfileLastName = Nothing
  , userProfileLocale = Nothing
  , userProfileLogin = Nothing
  , userProfileManager = Nothing
  , userProfileManagerId = Nothing
  , userProfileMiddleName = Nothing
  , userProfileMobilePhone = Nothing
  , userProfileNickName = Nothing
  , userProfileOrganization = Nothing
  , userProfilePostalAddress = Nothing
  , userProfilePreferredLanguage = Nothing
  , userProfilePrimaryPhone = Nothing
  , userProfileProfileUrl = Nothing
  , userProfileSecondEmail = Nothing
  , userProfileState = Nothing
  , userProfileStreetAddress = Nothing
  , userProfileTimezone = Nothing
  , userProfileTitle = Nothing
  , userProfileUserType = Nothing
  , userProfileZipCode = Nothing
  }

-- ** UserSchema
-- | UserSchema
data UserSchema = UserSchema
  { userSchemaId :: !(Maybe Text) -- ^ /ReadOnly/ "id"
  , userSchemaSchema :: !(Maybe Text) -- ^ /ReadOnly/ "$schema"
  , userSchemaName :: !(Maybe Text) -- ^ /ReadOnly/ "name"
  , userSchemaTitle :: !(Maybe Text) -- ^ "title"
  , userSchemaLastUpdated :: !(Maybe Text) -- ^ /ReadOnly/ "lastUpdated"
  , userSchemaCreated :: !(Maybe Text) -- ^ /ReadOnly/ "created"
  , userSchemaDefinitions :: !(Maybe UserSchemaDefinitions) -- ^ "definitions"
  , userSchemaType :: !(Maybe Text) -- ^ /ReadOnly/ "type"
  , userSchemaProperties :: !(Maybe UserSchemaProperties) -- ^ "properties"
  , userSchemaLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchema
instance A.FromJSON UserSchema where
  parseJSON = A.withObject "UserSchema" $ \o ->
    UserSchema
      <$> (o .:? "id")
      <*> (o .:? "$schema")
      <*> (o .:? "name")
      <*> (o .:? "title")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "created")
      <*> (o .:? "definitions")
      <*> (o .:? "type")
      <*> (o .:? "properties")
      <*> (o .:? "_links")

-- | ToJSON UserSchema
instance A.ToJSON UserSchema where
  toJSON UserSchema {..} =
   _omitNulls
      [ "id" .= userSchemaId
      , "$schema" .= userSchemaSchema
      , "name" .= userSchemaName
      , "title" .= userSchemaTitle
      , "lastUpdated" .= userSchemaLastUpdated
      , "created" .= userSchemaCreated
      , "definitions" .= userSchemaDefinitions
      , "type" .= userSchemaType
      , "properties" .= userSchemaProperties
      , "_links" .= userSchemaLinks
      ]


-- | Construct a value of type 'UserSchema' (by applying it's required fields, if any)
mkUserSchema
  :: UserSchema
mkUserSchema =
  UserSchema
  { userSchemaId = Nothing
  , userSchemaSchema = Nothing
  , userSchemaName = Nothing
  , userSchemaTitle = Nothing
  , userSchemaLastUpdated = Nothing
  , userSchemaCreated = Nothing
  , userSchemaDefinitions = Nothing
  , userSchemaType = Nothing
  , userSchemaProperties = Nothing
  , userSchemaLinks = Nothing
  }

-- ** UserSchemaAttribute
-- | UserSchemaAttribute
data UserSchemaAttribute = UserSchemaAttribute
  { userSchemaAttributeTitle :: !(Maybe Text) -- ^ "title"
  , userSchemaAttributeType :: !(Maybe UserSchemaAttributeType) -- ^ "type"
  , userSchemaAttributeRequired :: !(Maybe Bool) -- ^ "required"
  , userSchemaAttributeMutability :: !(Maybe Text) -- ^ "mutability"
  , userSchemaAttributeScope :: !(Maybe UserSchemaAttributeScope) -- ^ "scope"
  , userSchemaAttributeEnum :: !(Maybe [Text]) -- ^ "enum"
  , userSchemaAttributeOneOf :: !(Maybe [UserSchemaAttributeEnum]) -- ^ "oneOf"
  , userSchemaAttributeMinLength :: !(Maybe Int) -- ^ "minLength"
  , userSchemaAttributeMaxLength :: !(Maybe Int) -- ^ "maxLength"
  , userSchemaAttributeDescription :: !(Maybe Text) -- ^ "description"
  , userSchemaAttributePermissions :: !(Maybe [UserSchemaAttributePermission]) -- ^ "permissions"
  , userSchemaAttributeMaster :: !(Maybe UserSchemaAttributeMaster) -- ^ "master"
  , userSchemaAttributeUnion :: !(Maybe UserSchemaAttributeUnion) -- ^ "union"
  , userSchemaAttributeItems :: !(Maybe UserSchemaAttributeItems) -- ^ "items"
  , userSchemaAttributePattern :: !(Maybe Text) -- ^ "pattern"
  , userSchemaAttributeUnique :: !(Maybe Text) -- ^ "unique"
  , userSchemaAttributeExternalName :: !(Maybe Text) -- ^ "externalName"
  , userSchemaAttributeExternalNamespace :: !(Maybe Text) -- ^ "externalNamespace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttribute
instance A.FromJSON UserSchemaAttribute where
  parseJSON = A.withObject "UserSchemaAttribute" $ \o ->
    UserSchemaAttribute
      <$> (o .:? "title")
      <*> (o .:? "type")
      <*> (o .:? "required")
      <*> (o .:? "mutability")
      <*> (o .:? "scope")
      <*> (o .:? "enum")
      <*> (o .:? "oneOf")
      <*> (o .:? "minLength")
      <*> (o .:? "maxLength")
      <*> (o .:? "description")
      <*> (o .:? "permissions")
      <*> (o .:? "master")
      <*> (o .:? "union")
      <*> (o .:? "items")
      <*> (o .:? "pattern")
      <*> (o .:? "unique")
      <*> (o .:? "externalName")
      <*> (o .:? "externalNamespace")

-- | ToJSON UserSchemaAttribute
instance A.ToJSON UserSchemaAttribute where
  toJSON UserSchemaAttribute {..} =
   _omitNulls
      [ "title" .= userSchemaAttributeTitle
      , "type" .= userSchemaAttributeType
      , "required" .= userSchemaAttributeRequired
      , "mutability" .= userSchemaAttributeMutability
      , "scope" .= userSchemaAttributeScope
      , "enum" .= userSchemaAttributeEnum
      , "oneOf" .= userSchemaAttributeOneOf
      , "minLength" .= userSchemaAttributeMinLength
      , "maxLength" .= userSchemaAttributeMaxLength
      , "description" .= userSchemaAttributeDescription
      , "permissions" .= userSchemaAttributePermissions
      , "master" .= userSchemaAttributeMaster
      , "union" .= userSchemaAttributeUnion
      , "items" .= userSchemaAttributeItems
      , "pattern" .= userSchemaAttributePattern
      , "unique" .= userSchemaAttributeUnique
      , "externalName" .= userSchemaAttributeExternalName
      , "externalNamespace" .= userSchemaAttributeExternalNamespace
      ]


-- | Construct a value of type 'UserSchemaAttribute' (by applying it's required fields, if any)
mkUserSchemaAttribute
  :: UserSchemaAttribute
mkUserSchemaAttribute =
  UserSchemaAttribute
  { userSchemaAttributeTitle = Nothing
  , userSchemaAttributeType = Nothing
  , userSchemaAttributeRequired = Nothing
  , userSchemaAttributeMutability = Nothing
  , userSchemaAttributeScope = Nothing
  , userSchemaAttributeEnum = Nothing
  , userSchemaAttributeOneOf = Nothing
  , userSchemaAttributeMinLength = Nothing
  , userSchemaAttributeMaxLength = Nothing
  , userSchemaAttributeDescription = Nothing
  , userSchemaAttributePermissions = Nothing
  , userSchemaAttributeMaster = Nothing
  , userSchemaAttributeUnion = Nothing
  , userSchemaAttributeItems = Nothing
  , userSchemaAttributePattern = Nothing
  , userSchemaAttributeUnique = Nothing
  , userSchemaAttributeExternalName = Nothing
  , userSchemaAttributeExternalNamespace = Nothing
  }

-- ** UserSchemaAttributeEnum
-- | UserSchemaAttributeEnum
data UserSchemaAttributeEnum = UserSchemaAttributeEnum
  { userSchemaAttributeEnumConst :: !(Maybe Text) -- ^ "const"
  , userSchemaAttributeEnumTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributeEnum
instance A.FromJSON UserSchemaAttributeEnum where
  parseJSON = A.withObject "UserSchemaAttributeEnum" $ \o ->
    UserSchemaAttributeEnum
      <$> (o .:? "const")
      <*> (o .:? "title")

-- | ToJSON UserSchemaAttributeEnum
instance A.ToJSON UserSchemaAttributeEnum where
  toJSON UserSchemaAttributeEnum {..} =
   _omitNulls
      [ "const" .= userSchemaAttributeEnumConst
      , "title" .= userSchemaAttributeEnumTitle
      ]


-- | Construct a value of type 'UserSchemaAttributeEnum' (by applying it's required fields, if any)
mkUserSchemaAttributeEnum
  :: UserSchemaAttributeEnum
mkUserSchemaAttributeEnum =
  UserSchemaAttributeEnum
  { userSchemaAttributeEnumConst = Nothing
  , userSchemaAttributeEnumTitle = Nothing
  }

-- ** UserSchemaAttributeItems
-- | UserSchemaAttributeItems
data UserSchemaAttributeItems = UserSchemaAttributeItems
  { userSchemaAttributeItemsEnum :: !(Maybe [Text]) -- ^ "enum"
  , userSchemaAttributeItemsOneOf :: !(Maybe [UserSchemaAttributeEnum]) -- ^ "oneOf"
  , userSchemaAttributeItemsType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributeItems
instance A.FromJSON UserSchemaAttributeItems where
  parseJSON = A.withObject "UserSchemaAttributeItems" $ \o ->
    UserSchemaAttributeItems
      <$> (o .:? "enum")
      <*> (o .:? "oneOf")
      <*> (o .:? "type")

-- | ToJSON UserSchemaAttributeItems
instance A.ToJSON UserSchemaAttributeItems where
  toJSON UserSchemaAttributeItems {..} =
   _omitNulls
      [ "enum" .= userSchemaAttributeItemsEnum
      , "oneOf" .= userSchemaAttributeItemsOneOf
      , "type" .= userSchemaAttributeItemsType
      ]


-- | Construct a value of type 'UserSchemaAttributeItems' (by applying it's required fields, if any)
mkUserSchemaAttributeItems
  :: UserSchemaAttributeItems
mkUserSchemaAttributeItems =
  UserSchemaAttributeItems
  { userSchemaAttributeItemsEnum = Nothing
  , userSchemaAttributeItemsOneOf = Nothing
  , userSchemaAttributeItemsType = Nothing
  }

-- ** UserSchemaAttributeMaster
-- | UserSchemaAttributeMaster
data UserSchemaAttributeMaster = UserSchemaAttributeMaster
  { userSchemaAttributeMasterType :: !(Maybe UserSchemaAttributeMasterType) -- ^ "type"
  , userSchemaAttributeMasterPriority :: !(Maybe [UserSchemaAttributeMasterPriority]) -- ^ "priority"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributeMaster
instance A.FromJSON UserSchemaAttributeMaster where
  parseJSON = A.withObject "UserSchemaAttributeMaster" $ \o ->
    UserSchemaAttributeMaster
      <$> (o .:? "type")
      <*> (o .:? "priority")

-- | ToJSON UserSchemaAttributeMaster
instance A.ToJSON UserSchemaAttributeMaster where
  toJSON UserSchemaAttributeMaster {..} =
   _omitNulls
      [ "type" .= userSchemaAttributeMasterType
      , "priority" .= userSchemaAttributeMasterPriority
      ]


-- | Construct a value of type 'UserSchemaAttributeMaster' (by applying it's required fields, if any)
mkUserSchemaAttributeMaster
  :: UserSchemaAttributeMaster
mkUserSchemaAttributeMaster =
  UserSchemaAttributeMaster
  { userSchemaAttributeMasterType = Nothing
  , userSchemaAttributeMasterPriority = Nothing
  }

-- ** UserSchemaAttributeMasterPriority
-- | UserSchemaAttributeMasterPriority
data UserSchemaAttributeMasterPriority = UserSchemaAttributeMasterPriority
  { userSchemaAttributeMasterPriorityType :: !(Maybe Text) -- ^ "type"
  , userSchemaAttributeMasterPriorityValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributeMasterPriority
instance A.FromJSON UserSchemaAttributeMasterPriority where
  parseJSON = A.withObject "UserSchemaAttributeMasterPriority" $ \o ->
    UserSchemaAttributeMasterPriority
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON UserSchemaAttributeMasterPriority
instance A.ToJSON UserSchemaAttributeMasterPriority where
  toJSON UserSchemaAttributeMasterPriority {..} =
   _omitNulls
      [ "type" .= userSchemaAttributeMasterPriorityType
      , "value" .= userSchemaAttributeMasterPriorityValue
      ]


-- | Construct a value of type 'UserSchemaAttributeMasterPriority' (by applying it's required fields, if any)
mkUserSchemaAttributeMasterPriority
  :: UserSchemaAttributeMasterPriority
mkUserSchemaAttributeMasterPriority =
  UserSchemaAttributeMasterPriority
  { userSchemaAttributeMasterPriorityType = Nothing
  , userSchemaAttributeMasterPriorityValue = Nothing
  }

-- ** UserSchemaAttributePermission
-- | UserSchemaAttributePermission
data UserSchemaAttributePermission = UserSchemaAttributePermission
  { userSchemaAttributePermissionPrincipal :: !(Maybe Text) -- ^ "principal"
  , userSchemaAttributePermissionAction :: !(Maybe Text) -- ^ "action"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributePermission
instance A.FromJSON UserSchemaAttributePermission where
  parseJSON = A.withObject "UserSchemaAttributePermission" $ \o ->
    UserSchemaAttributePermission
      <$> (o .:? "principal")
      <*> (o .:? "action")

-- | ToJSON UserSchemaAttributePermission
instance A.ToJSON UserSchemaAttributePermission where
  toJSON UserSchemaAttributePermission {..} =
   _omitNulls
      [ "principal" .= userSchemaAttributePermissionPrincipal
      , "action" .= userSchemaAttributePermissionAction
      ]


-- | Construct a value of type 'UserSchemaAttributePermission' (by applying it's required fields, if any)
mkUserSchemaAttributePermission
  :: UserSchemaAttributePermission
mkUserSchemaAttributePermission =
  UserSchemaAttributePermission
  { userSchemaAttributePermissionPrincipal = Nothing
  , userSchemaAttributePermissionAction = Nothing
  }

-- ** UserSchemaAttributeScope
-- | UserSchemaAttributeScope
data UserSchemaAttributeScope = UserSchemaAttributeScope
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributeScope
instance A.FromJSON UserSchemaAttributeScope where
  parseJSON = A.withObject "UserSchemaAttributeScope" $ \o ->
    pure UserSchemaAttributeScope
      

-- | ToJSON UserSchemaAttributeScope
instance A.ToJSON UserSchemaAttributeScope where
  toJSON UserSchemaAttributeScope  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserSchemaAttributeScope' (by applying it's required fields, if any)
mkUserSchemaAttributeScope
  :: UserSchemaAttributeScope
mkUserSchemaAttributeScope =
  UserSchemaAttributeScope
  { 
  }

-- ** UserSchemaAttributeUnion
-- | UserSchemaAttributeUnion
data UserSchemaAttributeUnion = UserSchemaAttributeUnion
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaAttributeUnion
instance A.FromJSON UserSchemaAttributeUnion where
  parseJSON = A.withObject "UserSchemaAttributeUnion" $ \o ->
    pure UserSchemaAttributeUnion
      

-- | ToJSON UserSchemaAttributeUnion
instance A.ToJSON UserSchemaAttributeUnion where
  toJSON UserSchemaAttributeUnion  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'UserSchemaAttributeUnion' (by applying it's required fields, if any)
mkUserSchemaAttributeUnion
  :: UserSchemaAttributeUnion
mkUserSchemaAttributeUnion =
  UserSchemaAttributeUnion
  { 
  }

-- ** UserSchemaBase
-- | UserSchemaBase
data UserSchemaBase = UserSchemaBase
  { userSchemaBaseId :: !(Maybe Text) -- ^ "id"
  , userSchemaBaseType :: !(Maybe Text) -- ^ "type"
  , userSchemaBaseProperties :: !(Maybe UserSchemaBaseProperties) -- ^ "properties"
  , userSchemaBaseRequired :: !(Maybe [Text]) -- ^ "required"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaBase
instance A.FromJSON UserSchemaBase where
  parseJSON = A.withObject "UserSchemaBase" $ \o ->
    UserSchemaBase
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "properties")
      <*> (o .:? "required")

-- | ToJSON UserSchemaBase
instance A.ToJSON UserSchemaBase where
  toJSON UserSchemaBase {..} =
   _omitNulls
      [ "id" .= userSchemaBaseId
      , "type" .= userSchemaBaseType
      , "properties" .= userSchemaBaseProperties
      , "required" .= userSchemaBaseRequired
      ]


-- | Construct a value of type 'UserSchemaBase' (by applying it's required fields, if any)
mkUserSchemaBase
  :: UserSchemaBase
mkUserSchemaBase =
  UserSchemaBase
  { userSchemaBaseId = Nothing
  , userSchemaBaseType = Nothing
  , userSchemaBaseProperties = Nothing
  , userSchemaBaseRequired = Nothing
  }

-- ** UserSchemaBaseProperties
-- | UserSchemaBaseProperties
data UserSchemaBaseProperties = UserSchemaBaseProperties
  { userSchemaBasePropertiesLogin :: !(Maybe UserSchemaAttribute) -- ^ "login"
  , userSchemaBasePropertiesFirstName :: !(Maybe UserSchemaAttribute) -- ^ "firstName"
  , userSchemaBasePropertiesLastName :: !(Maybe UserSchemaAttribute) -- ^ "lastName"
  , userSchemaBasePropertiesMiddleName :: !(Maybe UserSchemaAttribute) -- ^ "middleName"
  , userSchemaBasePropertiesHonorificPrefix :: !(Maybe UserSchemaAttribute) -- ^ "honorificPrefix"
  , userSchemaBasePropertiesHonorificSuffix :: !(Maybe UserSchemaAttribute) -- ^ "honorificSuffix"
  , userSchemaBasePropertiesEmail :: !(Maybe UserSchemaAttribute) -- ^ "email"
  , userSchemaBasePropertiesTitle :: !(Maybe UserSchemaAttribute) -- ^ "title"
  , userSchemaBasePropertiesDisplayName :: !(Maybe UserSchemaAttribute) -- ^ "displayName"
  , userSchemaBasePropertiesNickName :: !(Maybe UserSchemaAttribute) -- ^ "nickName"
  , userSchemaBasePropertiesProfileUrl :: !(Maybe UserSchemaAttribute) -- ^ "profileUrl"
  , userSchemaBasePropertiesSecondEmail :: !(Maybe UserSchemaAttribute) -- ^ "secondEmail"
  , userSchemaBasePropertiesMobilePhone :: !(Maybe UserSchemaAttribute) -- ^ "mobilePhone"
  , userSchemaBasePropertiesPrimaryPhone :: !(Maybe UserSchemaAttribute) -- ^ "primaryPhone"
  , userSchemaBasePropertiesStreetAddress :: !(Maybe UserSchemaAttribute) -- ^ "streetAddress"
  , userSchemaBasePropertiesCity :: !(Maybe UserSchemaAttribute) -- ^ "city"
  , userSchemaBasePropertiesState :: !(Maybe UserSchemaAttribute) -- ^ "state"
  , userSchemaBasePropertiesZipCode :: !(Maybe UserSchemaAttribute) -- ^ "zipCode"
  , userSchemaBasePropertiesCountryCode :: !(Maybe UserSchemaAttribute) -- ^ "countryCode"
  , userSchemaBasePropertiesPostalAddress :: !(Maybe UserSchemaAttribute) -- ^ "postalAddress"
  , userSchemaBasePropertiesPreferredLanguage :: !(Maybe UserSchemaAttribute) -- ^ "preferredLanguage"
  , userSchemaBasePropertiesLocale :: !(Maybe UserSchemaAttribute) -- ^ "locale"
  , userSchemaBasePropertiesTimezone :: !(Maybe UserSchemaAttribute) -- ^ "timezone"
  , userSchemaBasePropertiesUserType :: !(Maybe UserSchemaAttribute) -- ^ "userType"
  , userSchemaBasePropertiesEmployeeNumber :: !(Maybe UserSchemaAttribute) -- ^ "employeeNumber"
  , userSchemaBasePropertiesCostCenter :: !(Maybe UserSchemaAttribute) -- ^ "costCenter"
  , userSchemaBasePropertiesOrganization :: !(Maybe UserSchemaAttribute) -- ^ "organization"
  , userSchemaBasePropertiesDivision :: !(Maybe UserSchemaAttribute) -- ^ "division"
  , userSchemaBasePropertiesDepartment :: !(Maybe UserSchemaAttribute) -- ^ "department"
  , userSchemaBasePropertiesManagerId :: !(Maybe UserSchemaAttribute) -- ^ "managerId"
  , userSchemaBasePropertiesManager :: !(Maybe UserSchemaAttribute) -- ^ "manager"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaBaseProperties
instance A.FromJSON UserSchemaBaseProperties where
  parseJSON = A.withObject "UserSchemaBaseProperties" $ \o ->
    UserSchemaBaseProperties
      <$> (o .:? "login")
      <*> (o .:? "firstName")
      <*> (o .:? "lastName")
      <*> (o .:? "middleName")
      <*> (o .:? "honorificPrefix")
      <*> (o .:? "honorificSuffix")
      <*> (o .:? "email")
      <*> (o .:? "title")
      <*> (o .:? "displayName")
      <*> (o .:? "nickName")
      <*> (o .:? "profileUrl")
      <*> (o .:? "secondEmail")
      <*> (o .:? "mobilePhone")
      <*> (o .:? "primaryPhone")
      <*> (o .:? "streetAddress")
      <*> (o .:? "city")
      <*> (o .:? "state")
      <*> (o .:? "zipCode")
      <*> (o .:? "countryCode")
      <*> (o .:? "postalAddress")
      <*> (o .:? "preferredLanguage")
      <*> (o .:? "locale")
      <*> (o .:? "timezone")
      <*> (o .:? "userType")
      <*> (o .:? "employeeNumber")
      <*> (o .:? "costCenter")
      <*> (o .:? "organization")
      <*> (o .:? "division")
      <*> (o .:? "department")
      <*> (o .:? "managerId")
      <*> (o .:? "manager")

-- | ToJSON UserSchemaBaseProperties
instance A.ToJSON UserSchemaBaseProperties where
  toJSON UserSchemaBaseProperties {..} =
   _omitNulls
      [ "login" .= userSchemaBasePropertiesLogin
      , "firstName" .= userSchemaBasePropertiesFirstName
      , "lastName" .= userSchemaBasePropertiesLastName
      , "middleName" .= userSchemaBasePropertiesMiddleName
      , "honorificPrefix" .= userSchemaBasePropertiesHonorificPrefix
      , "honorificSuffix" .= userSchemaBasePropertiesHonorificSuffix
      , "email" .= userSchemaBasePropertiesEmail
      , "title" .= userSchemaBasePropertiesTitle
      , "displayName" .= userSchemaBasePropertiesDisplayName
      , "nickName" .= userSchemaBasePropertiesNickName
      , "profileUrl" .= userSchemaBasePropertiesProfileUrl
      , "secondEmail" .= userSchemaBasePropertiesSecondEmail
      , "mobilePhone" .= userSchemaBasePropertiesMobilePhone
      , "primaryPhone" .= userSchemaBasePropertiesPrimaryPhone
      , "streetAddress" .= userSchemaBasePropertiesStreetAddress
      , "city" .= userSchemaBasePropertiesCity
      , "state" .= userSchemaBasePropertiesState
      , "zipCode" .= userSchemaBasePropertiesZipCode
      , "countryCode" .= userSchemaBasePropertiesCountryCode
      , "postalAddress" .= userSchemaBasePropertiesPostalAddress
      , "preferredLanguage" .= userSchemaBasePropertiesPreferredLanguage
      , "locale" .= userSchemaBasePropertiesLocale
      , "timezone" .= userSchemaBasePropertiesTimezone
      , "userType" .= userSchemaBasePropertiesUserType
      , "employeeNumber" .= userSchemaBasePropertiesEmployeeNumber
      , "costCenter" .= userSchemaBasePropertiesCostCenter
      , "organization" .= userSchemaBasePropertiesOrganization
      , "division" .= userSchemaBasePropertiesDivision
      , "department" .= userSchemaBasePropertiesDepartment
      , "managerId" .= userSchemaBasePropertiesManagerId
      , "manager" .= userSchemaBasePropertiesManager
      ]


-- | Construct a value of type 'UserSchemaBaseProperties' (by applying it's required fields, if any)
mkUserSchemaBaseProperties
  :: UserSchemaBaseProperties
mkUserSchemaBaseProperties =
  UserSchemaBaseProperties
  { userSchemaBasePropertiesLogin = Nothing
  , userSchemaBasePropertiesFirstName = Nothing
  , userSchemaBasePropertiesLastName = Nothing
  , userSchemaBasePropertiesMiddleName = Nothing
  , userSchemaBasePropertiesHonorificPrefix = Nothing
  , userSchemaBasePropertiesHonorificSuffix = Nothing
  , userSchemaBasePropertiesEmail = Nothing
  , userSchemaBasePropertiesTitle = Nothing
  , userSchemaBasePropertiesDisplayName = Nothing
  , userSchemaBasePropertiesNickName = Nothing
  , userSchemaBasePropertiesProfileUrl = Nothing
  , userSchemaBasePropertiesSecondEmail = Nothing
  , userSchemaBasePropertiesMobilePhone = Nothing
  , userSchemaBasePropertiesPrimaryPhone = Nothing
  , userSchemaBasePropertiesStreetAddress = Nothing
  , userSchemaBasePropertiesCity = Nothing
  , userSchemaBasePropertiesState = Nothing
  , userSchemaBasePropertiesZipCode = Nothing
  , userSchemaBasePropertiesCountryCode = Nothing
  , userSchemaBasePropertiesPostalAddress = Nothing
  , userSchemaBasePropertiesPreferredLanguage = Nothing
  , userSchemaBasePropertiesLocale = Nothing
  , userSchemaBasePropertiesTimezone = Nothing
  , userSchemaBasePropertiesUserType = Nothing
  , userSchemaBasePropertiesEmployeeNumber = Nothing
  , userSchemaBasePropertiesCostCenter = Nothing
  , userSchemaBasePropertiesOrganization = Nothing
  , userSchemaBasePropertiesDivision = Nothing
  , userSchemaBasePropertiesDepartment = Nothing
  , userSchemaBasePropertiesManagerId = Nothing
  , userSchemaBasePropertiesManager = Nothing
  }

-- ** UserSchemaDefinitions
-- | UserSchemaDefinitions
data UserSchemaDefinitions = UserSchemaDefinitions
  { userSchemaDefinitionsBase :: !(Maybe UserSchemaBase) -- ^ "base"
  , userSchemaDefinitionsCustom :: !(Maybe UserSchemaPublic) -- ^ "custom"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaDefinitions
instance A.FromJSON UserSchemaDefinitions where
  parseJSON = A.withObject "UserSchemaDefinitions" $ \o ->
    UserSchemaDefinitions
      <$> (o .:? "base")
      <*> (o .:? "custom")

-- | ToJSON UserSchemaDefinitions
instance A.ToJSON UserSchemaDefinitions where
  toJSON UserSchemaDefinitions {..} =
   _omitNulls
      [ "base" .= userSchemaDefinitionsBase
      , "custom" .= userSchemaDefinitionsCustom
      ]


-- | Construct a value of type 'UserSchemaDefinitions' (by applying it's required fields, if any)
mkUserSchemaDefinitions
  :: UserSchemaDefinitions
mkUserSchemaDefinitions =
  UserSchemaDefinitions
  { userSchemaDefinitionsBase = Nothing
  , userSchemaDefinitionsCustom = Nothing
  }

-- ** UserSchemaProperties
-- | UserSchemaProperties
data UserSchemaProperties = UserSchemaProperties
  { userSchemaPropertiesProfile :: !(Maybe UserSchemaPropertiesProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaProperties
instance A.FromJSON UserSchemaProperties where
  parseJSON = A.withObject "UserSchemaProperties" $ \o ->
    UserSchemaProperties
      <$> (o .:? "profile")

-- | ToJSON UserSchemaProperties
instance A.ToJSON UserSchemaProperties where
  toJSON UserSchemaProperties {..} =
   _omitNulls
      [ "profile" .= userSchemaPropertiesProfile
      ]


-- | Construct a value of type 'UserSchemaProperties' (by applying it's required fields, if any)
mkUserSchemaProperties
  :: UserSchemaProperties
mkUserSchemaProperties =
  UserSchemaProperties
  { userSchemaPropertiesProfile = Nothing
  }

-- ** UserSchemaPropertiesProfile
-- | UserSchemaPropertiesProfile
data UserSchemaPropertiesProfile = UserSchemaPropertiesProfile
  { userSchemaPropertiesProfileAllOf :: !(Maybe [UserSchemaPropertiesProfileItem]) -- ^ "allOf"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaPropertiesProfile
instance A.FromJSON UserSchemaPropertiesProfile where
  parseJSON = A.withObject "UserSchemaPropertiesProfile" $ \o ->
    UserSchemaPropertiesProfile
      <$> (o .:? "allOf")

-- | ToJSON UserSchemaPropertiesProfile
instance A.ToJSON UserSchemaPropertiesProfile where
  toJSON UserSchemaPropertiesProfile {..} =
   _omitNulls
      [ "allOf" .= userSchemaPropertiesProfileAllOf
      ]


-- | Construct a value of type 'UserSchemaPropertiesProfile' (by applying it's required fields, if any)
mkUserSchemaPropertiesProfile
  :: UserSchemaPropertiesProfile
mkUserSchemaPropertiesProfile =
  UserSchemaPropertiesProfile
  { userSchemaPropertiesProfileAllOf = Nothing
  }

-- ** UserSchemaPropertiesProfileItem
-- | UserSchemaPropertiesProfileItem
data UserSchemaPropertiesProfileItem = UserSchemaPropertiesProfileItem
  { userSchemaPropertiesProfileItemRef :: !(Maybe Text) -- ^ "$ref"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaPropertiesProfileItem
instance A.FromJSON UserSchemaPropertiesProfileItem where
  parseJSON = A.withObject "UserSchemaPropertiesProfileItem" $ \o ->
    UserSchemaPropertiesProfileItem
      <$> (o .:? "$ref")

-- | ToJSON UserSchemaPropertiesProfileItem
instance A.ToJSON UserSchemaPropertiesProfileItem where
  toJSON UserSchemaPropertiesProfileItem {..} =
   _omitNulls
      [ "$ref" .= userSchemaPropertiesProfileItemRef
      ]


-- | Construct a value of type 'UserSchemaPropertiesProfileItem' (by applying it's required fields, if any)
mkUserSchemaPropertiesProfileItem
  :: UserSchemaPropertiesProfileItem
mkUserSchemaPropertiesProfileItem =
  UserSchemaPropertiesProfileItem
  { userSchemaPropertiesProfileItemRef = Nothing
  }

-- ** UserSchemaPublic
-- | UserSchemaPublic
data UserSchemaPublic = UserSchemaPublic
  { userSchemaPublicId :: !(Maybe Text) -- ^ "id"
  , userSchemaPublicType :: !(Maybe Text) -- ^ "type"
  , userSchemaPublicProperties :: !(Maybe (Map.Map String UserSchemaAttribute)) -- ^ "properties"
  , userSchemaPublicRequired :: !(Maybe [Text]) -- ^ "required"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSchemaPublic
instance A.FromJSON UserSchemaPublic where
  parseJSON = A.withObject "UserSchemaPublic" $ \o ->
    UserSchemaPublic
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "properties")
      <*> (o .:? "required")

-- | ToJSON UserSchemaPublic
instance A.ToJSON UserSchemaPublic where
  toJSON UserSchemaPublic {..} =
   _omitNulls
      [ "id" .= userSchemaPublicId
      , "type" .= userSchemaPublicType
      , "properties" .= userSchemaPublicProperties
      , "required" .= userSchemaPublicRequired
      ]


-- | Construct a value of type 'UserSchemaPublic' (by applying it's required fields, if any)
mkUserSchemaPublic
  :: UserSchemaPublic
mkUserSchemaPublic =
  UserSchemaPublic
  { userSchemaPublicId = Nothing
  , userSchemaPublicType = Nothing
  , userSchemaPublicProperties = Nothing
  , userSchemaPublicRequired = Nothing
  }

-- ** UserStatusPolicyRuleCondition
-- | UserStatusPolicyRuleCondition
data UserStatusPolicyRuleCondition = UserStatusPolicyRuleCondition
  { userStatusPolicyRuleConditionValue :: !(Maybe E'Status4) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserStatusPolicyRuleCondition
instance A.FromJSON UserStatusPolicyRuleCondition where
  parseJSON = A.withObject "UserStatusPolicyRuleCondition" $ \o ->
    UserStatusPolicyRuleCondition
      <$> (o .:? "value")

-- | ToJSON UserStatusPolicyRuleCondition
instance A.ToJSON UserStatusPolicyRuleCondition where
  toJSON UserStatusPolicyRuleCondition {..} =
   _omitNulls
      [ "value" .= userStatusPolicyRuleConditionValue
      ]


-- | Construct a value of type 'UserStatusPolicyRuleCondition' (by applying it's required fields, if any)
mkUserStatusPolicyRuleCondition
  :: UserStatusPolicyRuleCondition
mkUserStatusPolicyRuleCondition =
  UserStatusPolicyRuleCondition
  { userStatusPolicyRuleConditionValue = Nothing
  }

-- ** UserType
-- | UserType
data UserType = UserType
  { userTypeLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , userTypeCreated :: !(Maybe DateTime) -- ^ /ReadOnly/ "created"
  , userTypeCreatedBy :: !(Maybe Text) -- ^ /ReadOnly/ "createdBy"
  , userTypeDefault :: !(Maybe Bool) -- ^ /ReadOnly/ "default"
  , userTypeDescription :: !(Maybe Text) -- ^ "description"
  , userTypeDisplayName :: !(Maybe Text) -- ^ "displayName"
  , userTypeId :: !(Maybe Text) -- ^ "id"
  , userTypeLastUpdated :: !(Maybe DateTime) -- ^ /ReadOnly/ "lastUpdated"
  , userTypeLastUpdatedBy :: !(Maybe Text) -- ^ /ReadOnly/ "lastUpdatedBy"
  , userTypeName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserType
instance A.FromJSON UserType where
  parseJSON = A.withObject "UserType" $ \o ->
    UserType
      <$> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "createdBy")
      <*> (o .:? "default")
      <*> (o .:? "description")
      <*> (o .:? "displayName")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "lastUpdatedBy")
      <*> (o .:? "name")

-- | ToJSON UserType
instance A.ToJSON UserType where
  toJSON UserType {..} =
   _omitNulls
      [ "_links" .= userTypeLinks
      , "created" .= userTypeCreated
      , "createdBy" .= userTypeCreatedBy
      , "default" .= userTypeDefault
      , "description" .= userTypeDescription
      , "displayName" .= userTypeDisplayName
      , "id" .= userTypeId
      , "lastUpdated" .= userTypeLastUpdated
      , "lastUpdatedBy" .= userTypeLastUpdatedBy
      , "name" .= userTypeName
      ]


-- | Construct a value of type 'UserType' (by applying it's required fields, if any)
mkUserType
  :: UserType
mkUserType =
  UserType
  { userTypeLinks = Nothing
  , userTypeCreated = Nothing
  , userTypeCreatedBy = Nothing
  , userTypeDefault = Nothing
  , userTypeDescription = Nothing
  , userTypeDisplayName = Nothing
  , userTypeId = Nothing
  , userTypeLastUpdated = Nothing
  , userTypeLastUpdatedBy = Nothing
  , userTypeName = Nothing
  }

-- ** UserTypeCondition
-- | UserTypeCondition
data UserTypeCondition = UserTypeCondition
  { userTypeConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , userTypeConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTypeCondition
instance A.FromJSON UserTypeCondition where
  parseJSON = A.withObject "UserTypeCondition" $ \o ->
    UserTypeCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON UserTypeCondition
instance A.ToJSON UserTypeCondition where
  toJSON UserTypeCondition {..} =
   _omitNulls
      [ "exclude" .= userTypeConditionExclude
      , "include" .= userTypeConditionInclude
      ]


-- | Construct a value of type 'UserTypeCondition' (by applying it's required fields, if any)
mkUserTypeCondition
  :: UserTypeCondition
mkUserTypeCondition =
  UserTypeCondition
  { userTypeConditionExclude = Nothing
  , userTypeConditionInclude = Nothing
  }

-- ** VerificationMethod
-- | VerificationMethod
data VerificationMethod = VerificationMethod
  { verificationMethodFactorMode :: !(Maybe Text) -- ^ "factorMode"
  , verificationMethodType :: !(Maybe Text) -- ^ "type"
  , verificationMethodReauthenticateIn :: !(Maybe Text) -- ^ "reauthenticateIn"
  , verificationMethodConstraints :: !(Maybe [AccessPolicyConstraints]) -- ^ "constraints"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerificationMethod
instance A.FromJSON VerificationMethod where
  parseJSON = A.withObject "VerificationMethod" $ \o ->
    VerificationMethod
      <$> (o .:? "factorMode")
      <*> (o .:? "type")
      <*> (o .:? "reauthenticateIn")
      <*> (o .:? "constraints")

-- | ToJSON VerificationMethod
instance A.ToJSON VerificationMethod where
  toJSON VerificationMethod {..} =
   _omitNulls
      [ "factorMode" .= verificationMethodFactorMode
      , "type" .= verificationMethodType
      , "reauthenticateIn" .= verificationMethodReauthenticateIn
      , "constraints" .= verificationMethodConstraints
      ]


-- | Construct a value of type 'VerificationMethod' (by applying it's required fields, if any)
mkVerificationMethod
  :: VerificationMethod
mkVerificationMethod =
  VerificationMethod
  { verificationMethodFactorMode = Nothing
  , verificationMethodType = Nothing
  , verificationMethodReauthenticateIn = Nothing
  , verificationMethodConstraints = Nothing
  }

-- ** VerifyFactorRequest
-- | VerifyFactorRequest
data VerifyFactorRequest = VerifyFactorRequest
  { verifyFactorRequestActivationToken :: !(Maybe Text) -- ^ "activationToken"
  , verifyFactorRequestAnswer :: !(Maybe Text) -- ^ "answer"
  , verifyFactorRequestAttestation :: !(Maybe Text) -- ^ "attestation"
  , verifyFactorRequestClientData :: !(Maybe Text) -- ^ "clientData"
  , verifyFactorRequestNextPassCode :: !(Maybe Text) -- ^ "nextPassCode"
  , verifyFactorRequestPassCode :: !(Maybe Text) -- ^ "passCode"
  , verifyFactorRequestRegistrationData :: !(Maybe Text) -- ^ "registrationData"
  , verifyFactorRequestStateToken :: !(Maybe Text) -- ^ "stateToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyFactorRequest
instance A.FromJSON VerifyFactorRequest where
  parseJSON = A.withObject "VerifyFactorRequest" $ \o ->
    VerifyFactorRequest
      <$> (o .:? "activationToken")
      <*> (o .:? "answer")
      <*> (o .:? "attestation")
      <*> (o .:? "clientData")
      <*> (o .:? "nextPassCode")
      <*> (o .:? "passCode")
      <*> (o .:? "registrationData")
      <*> (o .:? "stateToken")

-- | ToJSON VerifyFactorRequest
instance A.ToJSON VerifyFactorRequest where
  toJSON VerifyFactorRequest {..} =
   _omitNulls
      [ "activationToken" .= verifyFactorRequestActivationToken
      , "answer" .= verifyFactorRequestAnswer
      , "attestation" .= verifyFactorRequestAttestation
      , "clientData" .= verifyFactorRequestClientData
      , "nextPassCode" .= verifyFactorRequestNextPassCode
      , "passCode" .= verifyFactorRequestPassCode
      , "registrationData" .= verifyFactorRequestRegistrationData
      , "stateToken" .= verifyFactorRequestStateToken
      ]


-- | Construct a value of type 'VerifyFactorRequest' (by applying it's required fields, if any)
mkVerifyFactorRequest
  :: VerifyFactorRequest
mkVerifyFactorRequest =
  VerifyFactorRequest
  { verifyFactorRequestActivationToken = Nothing
  , verifyFactorRequestAnswer = Nothing
  , verifyFactorRequestAttestation = Nothing
  , verifyFactorRequestClientData = Nothing
  , verifyFactorRequestNextPassCode = Nothing
  , verifyFactorRequestPassCode = Nothing
  , verifyFactorRequestRegistrationData = Nothing
  , verifyFactorRequestStateToken = Nothing
  }

-- ** VerifyUserFactorResponse
-- | VerifyUserFactorResponse
data VerifyUserFactorResponse = VerifyUserFactorResponse
  { verifyUserFactorResponseEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_embedded"
  , verifyUserFactorResponseLinks :: !(Maybe (Map.Map String A.Value)) -- ^ /ReadOnly/ "_links"
  , verifyUserFactorResponseExpiresAt :: !(Maybe DateTime) -- ^ /ReadOnly/ "expiresAt"
  , verifyUserFactorResponseFactorResult :: !(Maybe E'FactorResult) -- ^ "factorResult"
  , verifyUserFactorResponseFactorResultMessage :: !(Maybe Text) -- ^ "factorResultMessage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyUserFactorResponse
instance A.FromJSON VerifyUserFactorResponse where
  parseJSON = A.withObject "VerifyUserFactorResponse" $ \o ->
    VerifyUserFactorResponse
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "expiresAt")
      <*> (o .:? "factorResult")
      <*> (o .:? "factorResultMessage")

-- | ToJSON VerifyUserFactorResponse
instance A.ToJSON VerifyUserFactorResponse where
  toJSON VerifyUserFactorResponse {..} =
   _omitNulls
      [ "_embedded" .= verifyUserFactorResponseEmbedded
      , "_links" .= verifyUserFactorResponseLinks
      , "expiresAt" .= verifyUserFactorResponseExpiresAt
      , "factorResult" .= verifyUserFactorResponseFactorResult
      , "factorResultMessage" .= verifyUserFactorResponseFactorResultMessage
      ]


-- | Construct a value of type 'VerifyUserFactorResponse' (by applying it's required fields, if any)
mkVerifyUserFactorResponse
  :: VerifyUserFactorResponse
mkVerifyUserFactorResponse =
  VerifyUserFactorResponse
  { verifyUserFactorResponseEmbedded = Nothing
  , verifyUserFactorResponseLinks = Nothing
  , verifyUserFactorResponseExpiresAt = Nothing
  , verifyUserFactorResponseFactorResult = Nothing
  , verifyUserFactorResponseFactorResultMessage = Nothing
  }

-- ** WebAuthnUserFactor
-- | WebAuthnUserFactor
data WebAuthnUserFactor = WebAuthnUserFactor
  { webAuthnUserFactorProfile :: !(Maybe WebAuthnUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebAuthnUserFactor
instance A.FromJSON WebAuthnUserFactor where
  parseJSON = A.withObject "WebAuthnUserFactor" $ \o ->
    WebAuthnUserFactor
      <$> (o .:? "profile")

-- | ToJSON WebAuthnUserFactor
instance A.ToJSON WebAuthnUserFactor where
  toJSON WebAuthnUserFactor {..} =
   _omitNulls
      [ "profile" .= webAuthnUserFactorProfile
      ]


-- | Construct a value of type 'WebAuthnUserFactor' (by applying it's required fields, if any)
mkWebAuthnUserFactor
  :: WebAuthnUserFactor
mkWebAuthnUserFactor =
  WebAuthnUserFactor
  { webAuthnUserFactorProfile = Nothing
  }

-- ** WebAuthnUserFactorProfile
-- | WebAuthnUserFactorProfile
data WebAuthnUserFactorProfile = WebAuthnUserFactorProfile
  { webAuthnUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  , webAuthnUserFactorProfileAuthenticatorName :: !(Maybe Text) -- ^ "authenticatorName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebAuthnUserFactorProfile
instance A.FromJSON WebAuthnUserFactorProfile where
  parseJSON = A.withObject "WebAuthnUserFactorProfile" $ \o ->
    WebAuthnUserFactorProfile
      <$> (o .:? "credentialId")
      <*> (o .:? "authenticatorName")

-- | ToJSON WebAuthnUserFactorProfile
instance A.ToJSON WebAuthnUserFactorProfile where
  toJSON WebAuthnUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= webAuthnUserFactorProfileCredentialId
      , "authenticatorName" .= webAuthnUserFactorProfileAuthenticatorName
      ]


-- | Construct a value of type 'WebAuthnUserFactorProfile' (by applying it's required fields, if any)
mkWebAuthnUserFactorProfile
  :: WebAuthnUserFactorProfile
mkWebAuthnUserFactorProfile =
  WebAuthnUserFactorProfile
  { webAuthnUserFactorProfileCredentialId = Nothing
  , webAuthnUserFactorProfileAuthenticatorName = Nothing
  }

-- ** WebUserFactor
-- | WebUserFactor
data WebUserFactor = WebUserFactor
  { webUserFactorProfile :: !(Maybe WebUserFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebUserFactor
instance A.FromJSON WebUserFactor where
  parseJSON = A.withObject "WebUserFactor" $ \o ->
    WebUserFactor
      <$> (o .:? "profile")

-- | ToJSON WebUserFactor
instance A.ToJSON WebUserFactor where
  toJSON WebUserFactor {..} =
   _omitNulls
      [ "profile" .= webUserFactorProfile
      ]


-- | Construct a value of type 'WebUserFactor' (by applying it's required fields, if any)
mkWebUserFactor
  :: WebUserFactor
mkWebUserFactor =
  WebUserFactor
  { webUserFactorProfile = Nothing
  }

-- ** WebUserFactorProfile
-- | WebUserFactorProfile
data WebUserFactorProfile = WebUserFactorProfile
  { webUserFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebUserFactorProfile
instance A.FromJSON WebUserFactorProfile where
  parseJSON = A.withObject "WebUserFactorProfile" $ \o ->
    WebUserFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON WebUserFactorProfile
instance A.ToJSON WebUserFactorProfile where
  toJSON WebUserFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= webUserFactorProfileCredentialId
      ]


-- | Construct a value of type 'WebUserFactorProfile' (by applying it's required fields, if any)
mkWebUserFactorProfile
  :: WebUserFactorProfile
mkWebUserFactorProfile =
  WebUserFactorProfile
  { webUserFactorProfileCredentialId = Nothing
  }

-- ** WsFederationApplication
-- | WsFederationApplication
data WsFederationApplication = WsFederationApplication
  { wsFederationApplicationName :: !(Maybe A.Value) -- ^ "name"
  , wsFederationApplicationSettings :: !(Maybe WsFederationApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WsFederationApplication
instance A.FromJSON WsFederationApplication where
  parseJSON = A.withObject "WsFederationApplication" $ \o ->
    WsFederationApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON WsFederationApplication
instance A.ToJSON WsFederationApplication where
  toJSON WsFederationApplication {..} =
   _omitNulls
      [ "name" .= wsFederationApplicationName
      , "settings" .= wsFederationApplicationSettings
      ]


-- | Construct a value of type 'WsFederationApplication' (by applying it's required fields, if any)
mkWsFederationApplication
  :: WsFederationApplication
mkWsFederationApplication =
  WsFederationApplication
  { wsFederationApplicationName = Nothing
  , wsFederationApplicationSettings = Nothing
  }

-- ** WsFederationApplicationSettings
-- | WsFederationApplicationSettings
data WsFederationApplicationSettings = WsFederationApplicationSettings
  { wsFederationApplicationSettingsApp :: !(Maybe WsFederationApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WsFederationApplicationSettings
instance A.FromJSON WsFederationApplicationSettings where
  parseJSON = A.withObject "WsFederationApplicationSettings" $ \o ->
    WsFederationApplicationSettings
      <$> (o .:? "app")

-- | ToJSON WsFederationApplicationSettings
instance A.ToJSON WsFederationApplicationSettings where
  toJSON WsFederationApplicationSettings {..} =
   _omitNulls
      [ "app" .= wsFederationApplicationSettingsApp
      ]


-- | Construct a value of type 'WsFederationApplicationSettings' (by applying it's required fields, if any)
mkWsFederationApplicationSettings
  :: WsFederationApplicationSettings
mkWsFederationApplicationSettings =
  WsFederationApplicationSettings
  { wsFederationApplicationSettingsApp = Nothing
  }

-- ** WsFederationApplicationSettingsApplication
-- | WsFederationApplicationSettingsApplication
data WsFederationApplicationSettingsApplication = WsFederationApplicationSettingsApplication
  { wsFederationApplicationSettingsApplicationAttributeStatements :: !(Maybe Text) -- ^ "attributeStatements"
  , wsFederationApplicationSettingsApplicationAudienceRestriction :: !(Maybe Text) -- ^ "audienceRestriction"
  , wsFederationApplicationSettingsApplicationAuthnContextClassRef :: !(Maybe Text) -- ^ "authnContextClassRef"
  , wsFederationApplicationSettingsApplicationGroupFilter :: !(Maybe Text) -- ^ "groupFilter"
  , wsFederationApplicationSettingsApplicationGroupName :: !(Maybe Text) -- ^ "groupName"
  , wsFederationApplicationSettingsApplicationGroupValueFormat :: !(Maybe Text) -- ^ "groupValueFormat"
  , wsFederationApplicationSettingsApplicationNameIdFormat :: !(Maybe Text) -- ^ "nameIDFormat"
  , wsFederationApplicationSettingsApplicationRealm :: !(Maybe Text) -- ^ "realm"
  , wsFederationApplicationSettingsApplicationSiteUrl :: !(Maybe Text) -- ^ "siteURL"
  , wsFederationApplicationSettingsApplicationUsernameAttribute :: !(Maybe Text) -- ^ "usernameAttribute"
  , wsFederationApplicationSettingsApplicationWReplyOverride :: !(Maybe Bool) -- ^ "wReplyOverride"
  , wsFederationApplicationSettingsApplicationWReplyUrl :: !(Maybe Text) -- ^ "wReplyURL"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WsFederationApplicationSettingsApplication
instance A.FromJSON WsFederationApplicationSettingsApplication where
  parseJSON = A.withObject "WsFederationApplicationSettingsApplication" $ \o ->
    WsFederationApplicationSettingsApplication
      <$> (o .:? "attributeStatements")
      <*> (o .:? "audienceRestriction")
      <*> (o .:? "authnContextClassRef")
      <*> (o .:? "groupFilter")
      <*> (o .:? "groupName")
      <*> (o .:? "groupValueFormat")
      <*> (o .:? "nameIDFormat")
      <*> (o .:? "realm")
      <*> (o .:? "siteURL")
      <*> (o .:? "usernameAttribute")
      <*> (o .:? "wReplyOverride")
      <*> (o .:? "wReplyURL")

-- | ToJSON WsFederationApplicationSettingsApplication
instance A.ToJSON WsFederationApplicationSettingsApplication where
  toJSON WsFederationApplicationSettingsApplication {..} =
   _omitNulls
      [ "attributeStatements" .= wsFederationApplicationSettingsApplicationAttributeStatements
      , "audienceRestriction" .= wsFederationApplicationSettingsApplicationAudienceRestriction
      , "authnContextClassRef" .= wsFederationApplicationSettingsApplicationAuthnContextClassRef
      , "groupFilter" .= wsFederationApplicationSettingsApplicationGroupFilter
      , "groupName" .= wsFederationApplicationSettingsApplicationGroupName
      , "groupValueFormat" .= wsFederationApplicationSettingsApplicationGroupValueFormat
      , "nameIDFormat" .= wsFederationApplicationSettingsApplicationNameIdFormat
      , "realm" .= wsFederationApplicationSettingsApplicationRealm
      , "siteURL" .= wsFederationApplicationSettingsApplicationSiteUrl
      , "usernameAttribute" .= wsFederationApplicationSettingsApplicationUsernameAttribute
      , "wReplyOverride" .= wsFederationApplicationSettingsApplicationWReplyOverride
      , "wReplyURL" .= wsFederationApplicationSettingsApplicationWReplyUrl
      ]


-- | Construct a value of type 'WsFederationApplicationSettingsApplication' (by applying it's required fields, if any)
mkWsFederationApplicationSettingsApplication
  :: WsFederationApplicationSettingsApplication
mkWsFederationApplicationSettingsApplication =
  WsFederationApplicationSettingsApplication
  { wsFederationApplicationSettingsApplicationAttributeStatements = Nothing
  , wsFederationApplicationSettingsApplicationAudienceRestriction = Nothing
  , wsFederationApplicationSettingsApplicationAuthnContextClassRef = Nothing
  , wsFederationApplicationSettingsApplicationGroupFilter = Nothing
  , wsFederationApplicationSettingsApplicationGroupName = Nothing
  , wsFederationApplicationSettingsApplicationGroupValueFormat = Nothing
  , wsFederationApplicationSettingsApplicationNameIdFormat = Nothing
  , wsFederationApplicationSettingsApplicationRealm = Nothing
  , wsFederationApplicationSettingsApplicationSiteUrl = Nothing
  , wsFederationApplicationSettingsApplicationUsernameAttribute = Nothing
  , wsFederationApplicationSettingsApplicationWReplyOverride = Nothing
  , wsFederationApplicationSettingsApplicationWReplyUrl = Nothing
  }


-- * Enums


-- ** AllowedForEnum

-- | Enum of 'Text'
data AllowedForEnum
  = AllowedForEnum'Recovery -- ^ @"recovery"@
  | AllowedForEnum'Sso -- ^ @"sso"@
  | AllowedForEnum'Any -- ^ @"any"@
  | AllowedForEnum'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AllowedForEnum where toJSON = A.toJSON . fromAllowedForEnum
instance A.FromJSON AllowedForEnum where parseJSON o = P.either P.fail (pure . P.id) . toAllowedForEnum =<< A.parseJSON o
instance WH.ToHttpApiData AllowedForEnum where toQueryParam = WH.toQueryParam . fromAllowedForEnum
instance WH.FromHttpApiData AllowedForEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAllowedForEnum
instance MimeRender MimeMultipartFormData AllowedForEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AllowedForEnum' enum
fromAllowedForEnum :: AllowedForEnum -> Text
fromAllowedForEnum = \case
  AllowedForEnum'Recovery -> "recovery"
  AllowedForEnum'Sso -> "sso"
  AllowedForEnum'Any -> "any"
  AllowedForEnum'None -> "none"

-- | parse 'AllowedForEnum' enum
toAllowedForEnum :: Text -> P.Either String AllowedForEnum
toAllowedForEnum = \case
  "recovery" -> P.Right AllowedForEnum'Recovery
  "sso" -> P.Right AllowedForEnum'Sso
  "any" -> P.Right AllowedForEnum'Any
  "none" -> P.Right AllowedForEnum'None
  s -> P.Left $ "toAllowedForEnum: enum parse failure: " P.++ P.show s


-- ** ApplicationCredentialsScheme

-- | Enum of 'Text'
data ApplicationCredentialsScheme
  = ApplicationCredentialsScheme'SHARED_USERNAME_AND_PASSWORD -- ^ @"SHARED_USERNAME_AND_PASSWORD"@
  | ApplicationCredentialsScheme'EXTERNAL_PASSWORD_SYNC -- ^ @"EXTERNAL_PASSWORD_SYNC"@
  | ApplicationCredentialsScheme'EDIT_USERNAME_AND_PASSWORD -- ^ @"EDIT_USERNAME_AND_PASSWORD"@
  | ApplicationCredentialsScheme'EDIT_PASSWORD_ONLY -- ^ @"EDIT_PASSWORD_ONLY"@
  | ApplicationCredentialsScheme'ADMIN_SETS_CREDENTIALS -- ^ @"ADMIN_SETS_CREDENTIALS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApplicationCredentialsScheme where toJSON = A.toJSON . fromApplicationCredentialsScheme
instance A.FromJSON ApplicationCredentialsScheme where parseJSON o = P.either P.fail (pure . P.id) . toApplicationCredentialsScheme =<< A.parseJSON o
instance WH.ToHttpApiData ApplicationCredentialsScheme where toQueryParam = WH.toQueryParam . fromApplicationCredentialsScheme
instance WH.FromHttpApiData ApplicationCredentialsScheme where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApplicationCredentialsScheme
instance MimeRender MimeMultipartFormData ApplicationCredentialsScheme where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApplicationCredentialsScheme' enum
fromApplicationCredentialsScheme :: ApplicationCredentialsScheme -> Text
fromApplicationCredentialsScheme = \case
  ApplicationCredentialsScheme'SHARED_USERNAME_AND_PASSWORD -> "SHARED_USERNAME_AND_PASSWORD"
  ApplicationCredentialsScheme'EXTERNAL_PASSWORD_SYNC -> "EXTERNAL_PASSWORD_SYNC"
  ApplicationCredentialsScheme'EDIT_USERNAME_AND_PASSWORD -> "EDIT_USERNAME_AND_PASSWORD"
  ApplicationCredentialsScheme'EDIT_PASSWORD_ONLY -> "EDIT_PASSWORD_ONLY"
  ApplicationCredentialsScheme'ADMIN_SETS_CREDENTIALS -> "ADMIN_SETS_CREDENTIALS"

-- | parse 'ApplicationCredentialsScheme' enum
toApplicationCredentialsScheme :: Text -> P.Either String ApplicationCredentialsScheme
toApplicationCredentialsScheme = \case
  "SHARED_USERNAME_AND_PASSWORD" -> P.Right ApplicationCredentialsScheme'SHARED_USERNAME_AND_PASSWORD
  "EXTERNAL_PASSWORD_SYNC" -> P.Right ApplicationCredentialsScheme'EXTERNAL_PASSWORD_SYNC
  "EDIT_USERNAME_AND_PASSWORD" -> P.Right ApplicationCredentialsScheme'EDIT_USERNAME_AND_PASSWORD
  "EDIT_PASSWORD_ONLY" -> P.Right ApplicationCredentialsScheme'EDIT_PASSWORD_ONLY
  "ADMIN_SETS_CREDENTIALS" -> P.Right ApplicationCredentialsScheme'ADMIN_SETS_CREDENTIALS
  s -> P.Left $ "toApplicationCredentialsScheme: enum parse failure: " P.++ P.show s


-- ** ApplicationCredentialsSigningUse

-- | Enum of 'Text'
data ApplicationCredentialsSigningUse
  = ApplicationCredentialsSigningUse'Sig -- ^ @"sig"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApplicationCredentialsSigningUse where toJSON = A.toJSON . fromApplicationCredentialsSigningUse
instance A.FromJSON ApplicationCredentialsSigningUse where parseJSON o = P.either P.fail (pure . P.id) . toApplicationCredentialsSigningUse =<< A.parseJSON o
instance WH.ToHttpApiData ApplicationCredentialsSigningUse where toQueryParam = WH.toQueryParam . fromApplicationCredentialsSigningUse
instance WH.FromHttpApiData ApplicationCredentialsSigningUse where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApplicationCredentialsSigningUse
instance MimeRender MimeMultipartFormData ApplicationCredentialsSigningUse where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApplicationCredentialsSigningUse' enum
fromApplicationCredentialsSigningUse :: ApplicationCredentialsSigningUse -> Text
fromApplicationCredentialsSigningUse = \case
  ApplicationCredentialsSigningUse'Sig -> "sig"

-- | parse 'ApplicationCredentialsSigningUse' enum
toApplicationCredentialsSigningUse :: Text -> P.Either String ApplicationCredentialsSigningUse
toApplicationCredentialsSigningUse = \case
  "sig" -> P.Right ApplicationCredentialsSigningUse'Sig
  s -> P.Left $ "toApplicationCredentialsSigningUse: enum parse failure: " P.++ P.show s


-- ** ApplicationSignOnMode

-- | Enum of 'Text'
data ApplicationSignOnMode
  = ApplicationSignOnMode'BOOKMARK -- ^ @"BOOKMARK"@
  | ApplicationSignOnMode'BASIC_AUTH -- ^ @"BASIC_AUTH"@
  | ApplicationSignOnMode'BROWSER_PLUGIN -- ^ @"BROWSER_PLUGIN"@
  | ApplicationSignOnMode'SECURE_PASSWORD_STORE -- ^ @"SECURE_PASSWORD_STORE"@
  | ApplicationSignOnMode'AUTO_LOGIN -- ^ @"AUTO_LOGIN"@
  | ApplicationSignOnMode'WS_FEDERATION -- ^ @"WS_FEDERATION"@
  | ApplicationSignOnMode'SAML_2_0 -- ^ @"SAML_2_0"@
  | ApplicationSignOnMode'OPENID_CONNECT -- ^ @"OPENID_CONNECT"@
  | ApplicationSignOnMode'SAML_1_1 -- ^ @"SAML_1_1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApplicationSignOnMode where toJSON = A.toJSON . fromApplicationSignOnMode
instance A.FromJSON ApplicationSignOnMode where parseJSON o = P.either P.fail (pure . P.id) . toApplicationSignOnMode =<< A.parseJSON o
instance WH.ToHttpApiData ApplicationSignOnMode where toQueryParam = WH.toQueryParam . fromApplicationSignOnMode
instance WH.FromHttpApiData ApplicationSignOnMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApplicationSignOnMode
instance MimeRender MimeMultipartFormData ApplicationSignOnMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApplicationSignOnMode' enum
fromApplicationSignOnMode :: ApplicationSignOnMode -> Text
fromApplicationSignOnMode = \case
  ApplicationSignOnMode'BOOKMARK -> "BOOKMARK"
  ApplicationSignOnMode'BASIC_AUTH -> "BASIC_AUTH"
  ApplicationSignOnMode'BROWSER_PLUGIN -> "BROWSER_PLUGIN"
  ApplicationSignOnMode'SECURE_PASSWORD_STORE -> "SECURE_PASSWORD_STORE"
  ApplicationSignOnMode'AUTO_LOGIN -> "AUTO_LOGIN"
  ApplicationSignOnMode'WS_FEDERATION -> "WS_FEDERATION"
  ApplicationSignOnMode'SAML_2_0 -> "SAML_2_0"
  ApplicationSignOnMode'OPENID_CONNECT -> "OPENID_CONNECT"
  ApplicationSignOnMode'SAML_1_1 -> "SAML_1_1"

-- | parse 'ApplicationSignOnMode' enum
toApplicationSignOnMode :: Text -> P.Either String ApplicationSignOnMode
toApplicationSignOnMode = \case
  "BOOKMARK" -> P.Right ApplicationSignOnMode'BOOKMARK
  "BASIC_AUTH" -> P.Right ApplicationSignOnMode'BASIC_AUTH
  "BROWSER_PLUGIN" -> P.Right ApplicationSignOnMode'BROWSER_PLUGIN
  "SECURE_PASSWORD_STORE" -> P.Right ApplicationSignOnMode'SECURE_PASSWORD_STORE
  "AUTO_LOGIN" -> P.Right ApplicationSignOnMode'AUTO_LOGIN
  "WS_FEDERATION" -> P.Right ApplicationSignOnMode'WS_FEDERATION
  "SAML_2_0" -> P.Right ApplicationSignOnMode'SAML_2_0
  "OPENID_CONNECT" -> P.Right ApplicationSignOnMode'OPENID_CONNECT
  "SAML_1_1" -> P.Right ApplicationSignOnMode'SAML_1_1
  s -> P.Left $ "toApplicationSignOnMode: enum parse failure: " P.++ P.show s


-- ** AuthenticationProviderType

-- | Enum of 'Text'
data AuthenticationProviderType
  = AuthenticationProviderType'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | AuthenticationProviderType'FEDERATION -- ^ @"FEDERATION"@
  | AuthenticationProviderType'LDAP -- ^ @"LDAP"@
  | AuthenticationProviderType'OKTA -- ^ @"OKTA"@
  | AuthenticationProviderType'SOCIAL -- ^ @"SOCIAL"@
  | AuthenticationProviderType'IMPORT -- ^ @"IMPORT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AuthenticationProviderType where toJSON = A.toJSON . fromAuthenticationProviderType
instance A.FromJSON AuthenticationProviderType where parseJSON o = P.either P.fail (pure . P.id) . toAuthenticationProviderType =<< A.parseJSON o
instance WH.ToHttpApiData AuthenticationProviderType where toQueryParam = WH.toQueryParam . fromAuthenticationProviderType
instance WH.FromHttpApiData AuthenticationProviderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAuthenticationProviderType
instance MimeRender MimeMultipartFormData AuthenticationProviderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AuthenticationProviderType' enum
fromAuthenticationProviderType :: AuthenticationProviderType -> Text
fromAuthenticationProviderType = \case
  AuthenticationProviderType'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  AuthenticationProviderType'FEDERATION -> "FEDERATION"
  AuthenticationProviderType'LDAP -> "LDAP"
  AuthenticationProviderType'OKTA -> "OKTA"
  AuthenticationProviderType'SOCIAL -> "SOCIAL"
  AuthenticationProviderType'IMPORT -> "IMPORT"

-- | parse 'AuthenticationProviderType' enum
toAuthenticationProviderType :: Text -> P.Either String AuthenticationProviderType
toAuthenticationProviderType = \case
  "ACTIVE_DIRECTORY" -> P.Right AuthenticationProviderType'ACTIVE_DIRECTORY
  "FEDERATION" -> P.Right AuthenticationProviderType'FEDERATION
  "LDAP" -> P.Right AuthenticationProviderType'LDAP
  "OKTA" -> P.Right AuthenticationProviderType'OKTA
  "SOCIAL" -> P.Right AuthenticationProviderType'SOCIAL
  "IMPORT" -> P.Right AuthenticationProviderType'IMPORT
  s -> P.Left $ "toAuthenticationProviderType: enum parse failure: " P.++ P.show s


-- ** AuthenticatorStatus

-- | Enum of 'Text'
data AuthenticatorStatus
  = AuthenticatorStatus'ACTIVE -- ^ @"ACTIVE"@
  | AuthenticatorStatus'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AuthenticatorStatus where toJSON = A.toJSON . fromAuthenticatorStatus
instance A.FromJSON AuthenticatorStatus where parseJSON o = P.either P.fail (pure . P.id) . toAuthenticatorStatus =<< A.parseJSON o
instance WH.ToHttpApiData AuthenticatorStatus where toQueryParam = WH.toQueryParam . fromAuthenticatorStatus
instance WH.FromHttpApiData AuthenticatorStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAuthenticatorStatus
instance MimeRender MimeMultipartFormData AuthenticatorStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AuthenticatorStatus' enum
fromAuthenticatorStatus :: AuthenticatorStatus -> Text
fromAuthenticatorStatus = \case
  AuthenticatorStatus'ACTIVE -> "ACTIVE"
  AuthenticatorStatus'INACTIVE -> "INACTIVE"

-- | parse 'AuthenticatorStatus' enum
toAuthenticatorStatus :: Text -> P.Either String AuthenticatorStatus
toAuthenticatorStatus = \case
  "ACTIVE" -> P.Right AuthenticatorStatus'ACTIVE
  "INACTIVE" -> P.Right AuthenticatorStatus'INACTIVE
  s -> P.Left $ "toAuthenticatorStatus: enum parse failure: " P.++ P.show s


-- ** AuthenticatorType

-- | Enum of 'Text'
data AuthenticatorType
  = AuthenticatorType'App -- ^ @"app"@
  | AuthenticatorType'Password -- ^ @"password"@
  | AuthenticatorType'Security_question -- ^ @"security_question"@
  | AuthenticatorType'Phone -- ^ @"phone"@
  | AuthenticatorType'Email -- ^ @"email"@
  | AuthenticatorType'Security_key -- ^ @"security_key"@
  | AuthenticatorType'Federated -- ^ @"federated"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AuthenticatorType where toJSON = A.toJSON . fromAuthenticatorType
instance A.FromJSON AuthenticatorType where parseJSON o = P.either P.fail (pure . P.id) . toAuthenticatorType =<< A.parseJSON o
instance WH.ToHttpApiData AuthenticatorType where toQueryParam = WH.toQueryParam . fromAuthenticatorType
instance WH.FromHttpApiData AuthenticatorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAuthenticatorType
instance MimeRender MimeMultipartFormData AuthenticatorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AuthenticatorType' enum
fromAuthenticatorType :: AuthenticatorType -> Text
fromAuthenticatorType = \case
  AuthenticatorType'App -> "app"
  AuthenticatorType'Password -> "password"
  AuthenticatorType'Security_question -> "security_question"
  AuthenticatorType'Phone -> "phone"
  AuthenticatorType'Email -> "email"
  AuthenticatorType'Security_key -> "security_key"
  AuthenticatorType'Federated -> "federated"

-- | parse 'AuthenticatorType' enum
toAuthenticatorType :: Text -> P.Either String AuthenticatorType
toAuthenticatorType = \case
  "app" -> P.Right AuthenticatorType'App
  "password" -> P.Right AuthenticatorType'Password
  "security_question" -> P.Right AuthenticatorType'Security_question
  "phone" -> P.Right AuthenticatorType'Phone
  "email" -> P.Right AuthenticatorType'Email
  "security_key" -> P.Right AuthenticatorType'Security_key
  "federated" -> P.Right AuthenticatorType'Federated
  s -> P.Left $ "toAuthenticatorType: enum parse failure: " P.++ P.show s


-- ** AuthorizationServerCredentialsRotationMode

-- | Enum of 'Text'
data AuthorizationServerCredentialsRotationMode
  = AuthorizationServerCredentialsRotationMode'AUTO -- ^ @"AUTO"@
  | AuthorizationServerCredentialsRotationMode'MANUAL -- ^ @"MANUAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AuthorizationServerCredentialsRotationMode where toJSON = A.toJSON . fromAuthorizationServerCredentialsRotationMode
instance A.FromJSON AuthorizationServerCredentialsRotationMode where parseJSON o = P.either P.fail (pure . P.id) . toAuthorizationServerCredentialsRotationMode =<< A.parseJSON o
instance WH.ToHttpApiData AuthorizationServerCredentialsRotationMode where toQueryParam = WH.toQueryParam . fromAuthorizationServerCredentialsRotationMode
instance WH.FromHttpApiData AuthorizationServerCredentialsRotationMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAuthorizationServerCredentialsRotationMode
instance MimeRender MimeMultipartFormData AuthorizationServerCredentialsRotationMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AuthorizationServerCredentialsRotationMode' enum
fromAuthorizationServerCredentialsRotationMode :: AuthorizationServerCredentialsRotationMode -> Text
fromAuthorizationServerCredentialsRotationMode = \case
  AuthorizationServerCredentialsRotationMode'AUTO -> "AUTO"
  AuthorizationServerCredentialsRotationMode'MANUAL -> "MANUAL"

-- | parse 'AuthorizationServerCredentialsRotationMode' enum
toAuthorizationServerCredentialsRotationMode :: Text -> P.Either String AuthorizationServerCredentialsRotationMode
toAuthorizationServerCredentialsRotationMode = \case
  "AUTO" -> P.Right AuthorizationServerCredentialsRotationMode'AUTO
  "MANUAL" -> P.Right AuthorizationServerCredentialsRotationMode'MANUAL
  s -> P.Left $ "toAuthorizationServerCredentialsRotationMode: enum parse failure: " P.++ P.show s


-- ** AuthorizationServerCredentialsUse

-- | Enum of 'Text'
data AuthorizationServerCredentialsUse
  = AuthorizationServerCredentialsUse'Sig -- ^ @"sig"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AuthorizationServerCredentialsUse where toJSON = A.toJSON . fromAuthorizationServerCredentialsUse
instance A.FromJSON AuthorizationServerCredentialsUse where parseJSON o = P.either P.fail (pure . P.id) . toAuthorizationServerCredentialsUse =<< A.parseJSON o
instance WH.ToHttpApiData AuthorizationServerCredentialsUse where toQueryParam = WH.toQueryParam . fromAuthorizationServerCredentialsUse
instance WH.FromHttpApiData AuthorizationServerCredentialsUse where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAuthorizationServerCredentialsUse
instance MimeRender MimeMultipartFormData AuthorizationServerCredentialsUse where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AuthorizationServerCredentialsUse' enum
fromAuthorizationServerCredentialsUse :: AuthorizationServerCredentialsUse -> Text
fromAuthorizationServerCredentialsUse = \case
  AuthorizationServerCredentialsUse'Sig -> "sig"

-- | parse 'AuthorizationServerCredentialsUse' enum
toAuthorizationServerCredentialsUse :: Text -> P.Either String AuthorizationServerCredentialsUse
toAuthorizationServerCredentialsUse = \case
  "sig" -> P.Right AuthorizationServerCredentialsUse'Sig
  s -> P.Left $ "toAuthorizationServerCredentialsUse: enum parse failure: " P.++ P.show s


-- ** CatalogApplicationStatus

-- | Enum of 'Text'
data CatalogApplicationStatus
  = CatalogApplicationStatus'ACTIVE -- ^ @"ACTIVE"@
  | CatalogApplicationStatus'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON CatalogApplicationStatus where toJSON = A.toJSON . fromCatalogApplicationStatus
instance A.FromJSON CatalogApplicationStatus where parseJSON o = P.either P.fail (pure . P.id) . toCatalogApplicationStatus =<< A.parseJSON o
instance WH.ToHttpApiData CatalogApplicationStatus where toQueryParam = WH.toQueryParam . fromCatalogApplicationStatus
instance WH.FromHttpApiData CatalogApplicationStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toCatalogApplicationStatus
instance MimeRender MimeMultipartFormData CatalogApplicationStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'CatalogApplicationStatus' enum
fromCatalogApplicationStatus :: CatalogApplicationStatus -> Text
fromCatalogApplicationStatus = \case
  CatalogApplicationStatus'ACTIVE -> "ACTIVE"
  CatalogApplicationStatus'INACTIVE -> "INACTIVE"

-- | parse 'CatalogApplicationStatus' enum
toCatalogApplicationStatus :: Text -> P.Either String CatalogApplicationStatus
toCatalogApplicationStatus = \case
  "ACTIVE" -> P.Right CatalogApplicationStatus'ACTIVE
  "INACTIVE" -> P.Right CatalogApplicationStatus'INACTIVE
  s -> P.Left $ "toCatalogApplicationStatus: enum parse failure: " P.++ P.show s


-- ** ChangeEnum

-- | Enum of 'Text'
data ChangeEnum
  = ChangeEnum'KEEP_EXISTING -- ^ @"KEEP_EXISTING"@
  | ChangeEnum'CHANGE -- ^ @"CHANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChangeEnum where toJSON = A.toJSON . fromChangeEnum
instance A.FromJSON ChangeEnum where parseJSON o = P.either P.fail (pure . P.id) . toChangeEnum =<< A.parseJSON o
instance WH.ToHttpApiData ChangeEnum where toQueryParam = WH.toQueryParam . fromChangeEnum
instance WH.FromHttpApiData ChangeEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChangeEnum
instance MimeRender MimeMultipartFormData ChangeEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChangeEnum' enum
fromChangeEnum :: ChangeEnum -> Text
fromChangeEnum = \case
  ChangeEnum'KEEP_EXISTING -> "KEEP_EXISTING"
  ChangeEnum'CHANGE -> "CHANGE"

-- | parse 'ChangeEnum' enum
toChangeEnum :: Text -> P.Either String ChangeEnum
toChangeEnum = \case
  "KEEP_EXISTING" -> P.Right ChangeEnum'KEEP_EXISTING
  "CHANGE" -> P.Right ChangeEnum'CHANGE
  s -> P.Left $ "toChangeEnum: enum parse failure: " P.++ P.show s


-- ** DNSRecordType

-- | Enum of 'Text'
data DNSRecordType
  = DNSRecordType'TXT -- ^ @"TXT"@
  | DNSRecordType'CNAME -- ^ @"CNAME"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DNSRecordType where toJSON = A.toJSON . fromDNSRecordType
instance A.FromJSON DNSRecordType where parseJSON o = P.either P.fail (pure . P.id) . toDNSRecordType =<< A.parseJSON o
instance WH.ToHttpApiData DNSRecordType where toQueryParam = WH.toQueryParam . fromDNSRecordType
instance WH.FromHttpApiData DNSRecordType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDNSRecordType
instance MimeRender MimeMultipartFormData DNSRecordType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DNSRecordType' enum
fromDNSRecordType :: DNSRecordType -> Text
fromDNSRecordType = \case
  DNSRecordType'TXT -> "TXT"
  DNSRecordType'CNAME -> "CNAME"

-- | parse 'DNSRecordType' enum
toDNSRecordType :: Text -> P.Either String DNSRecordType
toDNSRecordType = \case
  "TXT" -> P.Right DNSRecordType'TXT
  "CNAME" -> P.Right DNSRecordType'CNAME
  s -> P.Left $ "toDNSRecordType: enum parse failure: " P.++ P.show s


-- ** DomainCertificateSourceType

-- | Enum of 'Text'
data DomainCertificateSourceType
  = DomainCertificateSourceType'MANUAL -- ^ @"MANUAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DomainCertificateSourceType where toJSON = A.toJSON . fromDomainCertificateSourceType
instance A.FromJSON DomainCertificateSourceType where parseJSON o = P.either P.fail (pure . P.id) . toDomainCertificateSourceType =<< A.parseJSON o
instance WH.ToHttpApiData DomainCertificateSourceType where toQueryParam = WH.toQueryParam . fromDomainCertificateSourceType
instance WH.FromHttpApiData DomainCertificateSourceType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDomainCertificateSourceType
instance MimeRender MimeMultipartFormData DomainCertificateSourceType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DomainCertificateSourceType' enum
fromDomainCertificateSourceType :: DomainCertificateSourceType -> Text
fromDomainCertificateSourceType = \case
  DomainCertificateSourceType'MANUAL -> "MANUAL"

-- | parse 'DomainCertificateSourceType' enum
toDomainCertificateSourceType :: Text -> P.Either String DomainCertificateSourceType
toDomainCertificateSourceType = \case
  "MANUAL" -> P.Right DomainCertificateSourceType'MANUAL
  s -> P.Left $ "toDomainCertificateSourceType: enum parse failure: " P.++ P.show s


-- ** DomainCertificateType

-- | Enum of 'Text'
data DomainCertificateType
  = DomainCertificateType'PEM -- ^ @"PEM"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DomainCertificateType where toJSON = A.toJSON . fromDomainCertificateType
instance A.FromJSON DomainCertificateType where parseJSON o = P.either P.fail (pure . P.id) . toDomainCertificateType =<< A.parseJSON o
instance WH.ToHttpApiData DomainCertificateType where toQueryParam = WH.toQueryParam . fromDomainCertificateType
instance WH.FromHttpApiData DomainCertificateType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDomainCertificateType
instance MimeRender MimeMultipartFormData DomainCertificateType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DomainCertificateType' enum
fromDomainCertificateType :: DomainCertificateType -> Text
fromDomainCertificateType = \case
  DomainCertificateType'PEM -> "PEM"

-- | parse 'DomainCertificateType' enum
toDomainCertificateType :: Text -> P.Either String DomainCertificateType
toDomainCertificateType = \case
  "PEM" -> P.Right DomainCertificateType'PEM
  s -> P.Left $ "toDomainCertificateType: enum parse failure: " P.++ P.show s


-- ** DomainValidationStatus

-- | Enum of 'Text'
data DomainValidationStatus
  = DomainValidationStatus'NOT_STARTED -- ^ @"NOT_STARTED"@
  | DomainValidationStatus'IN_PROGRESS -- ^ @"IN_PROGRESS"@
  | DomainValidationStatus'VERIFIED -- ^ @"VERIFIED"@
  | DomainValidationStatus'COMPLETED -- ^ @"COMPLETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON DomainValidationStatus where toJSON = A.toJSON . fromDomainValidationStatus
instance A.FromJSON DomainValidationStatus where parseJSON o = P.either P.fail (pure . P.id) . toDomainValidationStatus =<< A.parseJSON o
instance WH.ToHttpApiData DomainValidationStatus where toQueryParam = WH.toQueryParam . fromDomainValidationStatus
instance WH.FromHttpApiData DomainValidationStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toDomainValidationStatus
instance MimeRender MimeMultipartFormData DomainValidationStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'DomainValidationStatus' enum
fromDomainValidationStatus :: DomainValidationStatus -> Text
fromDomainValidationStatus = \case
  DomainValidationStatus'NOT_STARTED -> "NOT_STARTED"
  DomainValidationStatus'IN_PROGRESS -> "IN_PROGRESS"
  DomainValidationStatus'VERIFIED -> "VERIFIED"
  DomainValidationStatus'COMPLETED -> "COMPLETED"

-- | parse 'DomainValidationStatus' enum
toDomainValidationStatus :: Text -> P.Either String DomainValidationStatus
toDomainValidationStatus = \case
  "NOT_STARTED" -> P.Right DomainValidationStatus'NOT_STARTED
  "IN_PROGRESS" -> P.Right DomainValidationStatus'IN_PROGRESS
  "VERIFIED" -> P.Right DomainValidationStatus'VERIFIED
  "COMPLETED" -> P.Right DomainValidationStatus'COMPLETED
  s -> P.Left $ "toDomainValidationStatus: enum parse failure: " P.++ P.show s


-- ** E'Access

-- | Enum of 'Text'
data E'Access
  = E'Access'ALLOW -- ^ @"ALLOW"@
  | E'Access'DENY -- ^ @"DENY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Access where toJSON = A.toJSON . fromE'Access
instance A.FromJSON E'Access where parseJSON o = P.either P.fail (pure . P.id) . toE'Access =<< A.parseJSON o
instance WH.ToHttpApiData E'Access where toQueryParam = WH.toQueryParam . fromE'Access
instance WH.FromHttpApiData E'Access where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Access
instance MimeRender MimeMultipartFormData E'Access where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Access' enum
fromE'Access :: E'Access -> Text
fromE'Access = \case
  E'Access'ALLOW -> "ALLOW"
  E'Access'DENY -> "DENY"

-- | parse 'E'Access' enum
toE'Access :: Text -> P.Either String E'Access
toE'Access = \case
  "ALLOW" -> P.Right E'Access'ALLOW
  "DENY" -> P.Right E'Access'DENY
  s -> P.Left $ "toE'Access: enum parse failure: " P.++ P.show s


-- ** E'Action

-- | Enum of 'Text'
data E'Action
  = E'Action'AUTO -- ^ @"AUTO"@
  | E'Action'DISABLED -- ^ @"DISABLED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Action where toJSON = A.toJSON . fromE'Action
instance A.FromJSON E'Action where parseJSON o = P.either P.fail (pure . P.id) . toE'Action =<< A.parseJSON o
instance WH.ToHttpApiData E'Action where toQueryParam = WH.toQueryParam . fromE'Action
instance WH.FromHttpApiData E'Action where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Action
instance MimeRender MimeMultipartFormData E'Action where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Action' enum
fromE'Action :: E'Action -> Text
fromE'Action = \case
  E'Action'AUTO -> "AUTO"
  E'Action'DISABLED -> "DISABLED"

-- | parse 'E'Action' enum
toE'Action :: Text -> P.Either String E'Action
toE'Action = \case
  "AUTO" -> P.Right E'Action'AUTO
  "DISABLED" -> P.Right E'Action'DISABLED
  s -> P.Left $ "toE'Action: enum parse failure: " P.++ P.show s


-- ** E'Action2

-- | Enum of 'Text'
data E'Action2
  = E'Action2'AUTO -- ^ @"AUTO"@
  | E'Action2'CALLOUT -- ^ @"CALLOUT"@
  | E'Action2'DISABLED -- ^ @"DISABLED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Action2 where toJSON = A.toJSON . fromE'Action2
instance A.FromJSON E'Action2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Action2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Action2 where toQueryParam = WH.toQueryParam . fromE'Action2
instance WH.FromHttpApiData E'Action2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Action2
instance MimeRender MimeMultipartFormData E'Action2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Action2' enum
fromE'Action2 :: E'Action2 -> Text
fromE'Action2 = \case
  E'Action2'AUTO -> "AUTO"
  E'Action2'CALLOUT -> "CALLOUT"
  E'Action2'DISABLED -> "DISABLED"

-- | parse 'E'Action2' enum
toE'Action2 :: Text -> P.Either String E'Action2
toE'Action2 = \case
  "AUTO" -> P.Right E'Action2'AUTO
  "CALLOUT" -> P.Right E'Action2'CALLOUT
  "DISABLED" -> P.Right E'Action2'DISABLED
  s -> P.Left $ "toE'Action2: enum parse failure: " P.++ P.show s


-- ** E'Action3

-- | Enum of 'Text'
data E'Action3
  = E'Action3'NONE -- ^ @"NONE"@
  | E'Action3'REACTIVATE -- ^ @"REACTIVATE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Action3 where toJSON = A.toJSON . fromE'Action3
instance A.FromJSON E'Action3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Action3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Action3 where toQueryParam = WH.toQueryParam . fromE'Action3
instance WH.FromHttpApiData E'Action3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Action3
instance MimeRender MimeMultipartFormData E'Action3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Action3' enum
fromE'Action3 :: E'Action3 -> Text
fromE'Action3 = \case
  E'Action3'NONE -> "NONE"
  E'Action3'REACTIVATE -> "REACTIVATE"

-- | parse 'E'Action3' enum
toE'Action3 :: Text -> P.Either String E'Action3
toE'Action3 = \case
  "NONE" -> P.Right E'Action3'NONE
  "REACTIVATE" -> P.Right E'Action3'REACTIVATE
  s -> P.Left $ "toE'Action3: enum parse failure: " P.++ P.show s


-- ** E'Action4

-- | Enum of 'Text'
data E'Action4
  = E'Action4'NONE -- ^ @"NONE"@
  | E'Action4'APPEND -- ^ @"APPEND"@
  | E'Action4'SYNC -- ^ @"SYNC"@
  | E'Action4'ASSIGN -- ^ @"ASSIGN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Action4 where toJSON = A.toJSON . fromE'Action4
instance A.FromJSON E'Action4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Action4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Action4 where toQueryParam = WH.toQueryParam . fromE'Action4
instance WH.FromHttpApiData E'Action4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Action4
instance MimeRender MimeMultipartFormData E'Action4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Action4' enum
fromE'Action4 :: E'Action4 -> Text
fromE'Action4 = \case
  E'Action4'NONE -> "NONE"
  E'Action4'APPEND -> "APPEND"
  E'Action4'SYNC -> "SYNC"
  E'Action4'ASSIGN -> "ASSIGN"

-- | parse 'E'Action4' enum
toE'Action4 :: Text -> P.Either String E'Action4
toE'Action4 = \case
  "NONE" -> P.Right E'Action4'NONE
  "APPEND" -> P.Right E'Action4'APPEND
  "SYNC" -> P.Right E'Action4'SYNC
  "ASSIGN" -> P.Right E'Action4'ASSIGN
  s -> P.Left $ "toE'Action4: enum parse failure: " P.++ P.show s


-- ** E'Action5

-- | Enum of 'Text'
data E'Action5
  = E'Action5'NONE -- ^ @"NONE"@
  | E'Action5'UNSUSPEND -- ^ @"UNSUSPEND"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Action5 where toJSON = A.toJSON . fromE'Action5
instance A.FromJSON E'Action5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Action5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Action5 where toQueryParam = WH.toQueryParam . fromE'Action5
instance WH.FromHttpApiData E'Action5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Action5
instance MimeRender MimeMultipartFormData E'Action5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Action5' enum
fromE'Action5 :: E'Action5 -> Text
fromE'Action5 = \case
  E'Action5'NONE -> "NONE"
  E'Action5'UNSUSPEND -> "UNSUSPEND"

-- | parse 'E'Action5' enum
toE'Action5 :: Text -> P.Either String E'Action5
toE'Action5 = \case
  "NONE" -> P.Right E'Action5'NONE
  "UNSUSPEND" -> P.Right E'Action5'UNSUSPEND
  s -> P.Left $ "toE'Action5: enum parse failure: " P.++ P.show s


-- ** E'AuthType

-- | Enum of 'Text'
data E'AuthType
  = E'AuthType'ANY -- ^ @"ANY"@
  | E'AuthType'RADIUS -- ^ @"RADIUS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AuthType where toJSON = A.toJSON . fromE'AuthType
instance A.FromJSON E'AuthType where parseJSON o = P.either P.fail (pure . P.id) . toE'AuthType =<< A.parseJSON o
instance WH.ToHttpApiData E'AuthType where toQueryParam = WH.toQueryParam . fromE'AuthType
instance WH.FromHttpApiData E'AuthType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AuthType
instance MimeRender MimeMultipartFormData E'AuthType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AuthType' enum
fromE'AuthType :: E'AuthType -> Text
fromE'AuthType = \case
  E'AuthType'ANY -> "ANY"
  E'AuthType'RADIUS -> "RADIUS"

-- | parse 'E'AuthType' enum
toE'AuthType :: Text -> P.Either String E'AuthType
toE'AuthType = \case
  "ANY" -> P.Right E'AuthType'ANY
  "RADIUS" -> P.Right E'AuthType'RADIUS
  s -> P.Left $ "toE'AuthType: enum parse failure: " P.++ P.show s


-- ** E'Binding

-- | Enum of 'Text'
data E'Binding
  = E'Binding'POST -- ^ @"HTTP-POST"@
  | E'Binding'REDIRECT -- ^ @"HTTP-REDIRECT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Binding where toJSON = A.toJSON . fromE'Binding
instance A.FromJSON E'Binding where parseJSON o = P.either P.fail (pure . P.id) . toE'Binding =<< A.parseJSON o
instance WH.ToHttpApiData E'Binding where toQueryParam = WH.toQueryParam . fromE'Binding
instance WH.FromHttpApiData E'Binding where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Binding
instance MimeRender MimeMultipartFormData E'Binding where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Binding' enum
fromE'Binding :: E'Binding -> Text
fromE'Binding = \case
  E'Binding'POST -> "HTTP-POST"
  E'Binding'REDIRECT -> "HTTP-REDIRECT"

-- | parse 'E'Binding' enum
toE'Binding :: Text -> P.Either String E'Binding
toE'Binding = \case
  "HTTP-POST" -> P.Right E'Binding'POST
  "HTTP-REDIRECT" -> P.Right E'Binding'REDIRECT
  s -> P.Left $ "toE'Binding: enum parse failure: " P.++ P.show s


-- ** E'ClaimType

-- | Enum of 'Text'
data E'ClaimType
  = E'ClaimType'IDENTITY -- ^ @"IDENTITY"@
  | E'ClaimType'RESOURCE -- ^ @"RESOURCE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ClaimType where toJSON = A.toJSON . fromE'ClaimType
instance A.FromJSON E'ClaimType where parseJSON o = P.either P.fail (pure . P.id) . toE'ClaimType =<< A.parseJSON o
instance WH.ToHttpApiData E'ClaimType where toQueryParam = WH.toQueryParam . fromE'ClaimType
instance WH.FromHttpApiData E'ClaimType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ClaimType
instance MimeRender MimeMultipartFormData E'ClaimType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ClaimType' enum
fromE'ClaimType :: E'ClaimType -> Text
fromE'ClaimType = \case
  E'ClaimType'IDENTITY -> "IDENTITY"
  E'ClaimType'RESOURCE -> "RESOURCE"

-- | parse 'E'ClaimType' enum
toE'ClaimType :: Text -> P.Either String E'ClaimType
toE'ClaimType = \case
  "IDENTITY" -> P.Right E'ClaimType'IDENTITY
  "RESOURCE" -> P.Right E'ClaimType'RESOURCE
  s -> P.Left $ "toE'ClaimType: enum parse failure: " P.++ P.show s


-- ** E'Connection

-- | Enum of 'Text'
data E'Connection
  = E'Connection'ANYWHERE -- ^ @"ANYWHERE"@
  | E'Connection'ZONE -- ^ @"ZONE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Connection where toJSON = A.toJSON . fromE'Connection
instance A.FromJSON E'Connection where parseJSON o = P.either P.fail (pure . P.id) . toE'Connection =<< A.parseJSON o
instance WH.ToHttpApiData E'Connection where toQueryParam = WH.toQueryParam . fromE'Connection
instance WH.FromHttpApiData E'Connection where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Connection
instance MimeRender MimeMultipartFormData E'Connection where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Connection' enum
fromE'Connection :: E'Connection -> Text
fromE'Connection = \case
  E'Connection'ANYWHERE -> "ANYWHERE"
  E'Connection'ZONE -> "ZONE"

-- | parse 'E'Connection' enum
toE'Connection :: Text -> P.Either String E'Connection
toE'Connection = \case
  "ANYWHERE" -> P.Right E'Connection'ANYWHERE
  "ZONE" -> P.Right E'Connection'ZONE
  s -> P.Left $ "toE'Connection: enum parse failure: " P.++ P.show s


-- ** E'Consent

-- | Enum of 'Text'
data E'Consent
  = E'Consent'REQUIRED -- ^ @"REQUIRED"@
  | E'Consent'IMPLICIT -- ^ @"IMPLICIT"@
  | E'Consent'ADMIN -- ^ @"ADMIN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Consent where toJSON = A.toJSON . fromE'Consent
instance A.FromJSON E'Consent where parseJSON o = P.either P.fail (pure . P.id) . toE'Consent =<< A.parseJSON o
instance WH.ToHttpApiData E'Consent where toQueryParam = WH.toQueryParam . fromE'Consent
instance WH.FromHttpApiData E'Consent where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Consent
instance MimeRender MimeMultipartFormData E'Consent where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Consent' enum
fromE'Consent :: E'Consent -> Text
fromE'Consent = \case
  E'Consent'REQUIRED -> "REQUIRED"
  E'Consent'IMPLICIT -> "IMPLICIT"
  E'Consent'ADMIN -> "ADMIN"

-- | parse 'E'Consent' enum
toE'Consent :: Text -> P.Either String E'Consent
toE'Consent = \case
  "REQUIRED" -> P.Right E'Consent'REQUIRED
  "IMPLICIT" -> P.Right E'Consent'IMPLICIT
  "ADMIN" -> P.Right E'Consent'ADMIN
  s -> P.Left $ "toE'Consent: enum parse failure: " P.++ P.show s


-- ** E'Enrollment

-- | Enum of 'Text'
data E'Enrollment
  = E'Enrollment'OMM -- ^ @"OMM"@
  | E'Enrollment'ANY_OR_NONE -- ^ @"ANY_OR_NONE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Enrollment where toJSON = A.toJSON . fromE'Enrollment
instance A.FromJSON E'Enrollment where parseJSON o = P.either P.fail (pure . P.id) . toE'Enrollment =<< A.parseJSON o
instance WH.ToHttpApiData E'Enrollment where toQueryParam = WH.toQueryParam . fromE'Enrollment
instance WH.FromHttpApiData E'Enrollment where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Enrollment
instance MimeRender MimeMultipartFormData E'Enrollment where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Enrollment' enum
fromE'Enrollment :: E'Enrollment -> Text
fromE'Enrollment = \case
  E'Enrollment'OMM -> "OMM"
  E'Enrollment'ANY_OR_NONE -> "ANY_OR_NONE"

-- | parse 'E'Enrollment' enum
toE'Enrollment :: Text -> P.Either String E'Enrollment
toE'Enrollment = \case
  "OMM" -> P.Right E'Enrollment'OMM
  "ANY_OR_NONE" -> P.Right E'Enrollment'ANY_OR_NONE
  s -> P.Left $ "toE'Enrollment: enum parse failure: " P.++ P.show s


-- ** E'FactorPromptMode

-- | Enum of 'Text'
data E'FactorPromptMode
  = E'FactorPromptMode'ALWAYS -- ^ @"ALWAYS"@
  | E'FactorPromptMode'DEVICE -- ^ @"DEVICE"@
  | E'FactorPromptMode'SESSION -- ^ @"SESSION"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FactorPromptMode where toJSON = A.toJSON . fromE'FactorPromptMode
instance A.FromJSON E'FactorPromptMode where parseJSON o = P.either P.fail (pure . P.id) . toE'FactorPromptMode =<< A.parseJSON o
instance WH.ToHttpApiData E'FactorPromptMode where toQueryParam = WH.toQueryParam . fromE'FactorPromptMode
instance WH.FromHttpApiData E'FactorPromptMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FactorPromptMode
instance MimeRender MimeMultipartFormData E'FactorPromptMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FactorPromptMode' enum
fromE'FactorPromptMode :: E'FactorPromptMode -> Text
fromE'FactorPromptMode = \case
  E'FactorPromptMode'ALWAYS -> "ALWAYS"
  E'FactorPromptMode'DEVICE -> "DEVICE"
  E'FactorPromptMode'SESSION -> "SESSION"

-- | parse 'E'FactorPromptMode' enum
toE'FactorPromptMode :: Text -> P.Either String E'FactorPromptMode
toE'FactorPromptMode = \case
  "ALWAYS" -> P.Right E'FactorPromptMode'ALWAYS
  "DEVICE" -> P.Right E'FactorPromptMode'DEVICE
  "SESSION" -> P.Right E'FactorPromptMode'SESSION
  s -> P.Left $ "toE'FactorPromptMode: enum parse failure: " P.++ P.show s


-- ** E'FactorResult

-- | Enum of 'Text'
data E'FactorResult
  = E'FactorResult'SUCCESS -- ^ @"SUCCESS"@
  | E'FactorResult'EXPIRED -- ^ @"EXPIRED"@
  | E'FactorResult'CHALLENGE -- ^ @"CHALLENGE"@
  | E'FactorResult'WAITING -- ^ @"WAITING"@
  | E'FactorResult'FAILED -- ^ @"FAILED"@
  | E'FactorResult'REJECTED -- ^ @"REJECTED"@
  | E'FactorResult'TIMEOUT -- ^ @"TIMEOUT"@
  | E'FactorResult'TIME_WINDOW_EXCEEDED -- ^ @"TIME_WINDOW_EXCEEDED"@
  | E'FactorResult'PASSCODE_REPLAYED -- ^ @"PASSCODE_REPLAYED"@
  | E'FactorResult'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FactorResult where toJSON = A.toJSON . fromE'FactorResult
instance A.FromJSON E'FactorResult where parseJSON o = P.either P.fail (pure . P.id) . toE'FactorResult =<< A.parseJSON o
instance WH.ToHttpApiData E'FactorResult where toQueryParam = WH.toQueryParam . fromE'FactorResult
instance WH.FromHttpApiData E'FactorResult where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FactorResult
instance MimeRender MimeMultipartFormData E'FactorResult where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FactorResult' enum
fromE'FactorResult :: E'FactorResult -> Text
fromE'FactorResult = \case
  E'FactorResult'SUCCESS -> "SUCCESS"
  E'FactorResult'EXPIRED -> "EXPIRED"
  E'FactorResult'CHALLENGE -> "CHALLENGE"
  E'FactorResult'WAITING -> "WAITING"
  E'FactorResult'FAILED -> "FAILED"
  E'FactorResult'REJECTED -> "REJECTED"
  E'FactorResult'TIMEOUT -> "TIMEOUT"
  E'FactorResult'TIME_WINDOW_EXCEEDED -> "TIME_WINDOW_EXCEEDED"
  E'FactorResult'PASSCODE_REPLAYED -> "PASSCODE_REPLAYED"
  E'FactorResult'ERROR -> "ERROR"

-- | parse 'E'FactorResult' enum
toE'FactorResult :: Text -> P.Either String E'FactorResult
toE'FactorResult = \case
  "SUCCESS" -> P.Right E'FactorResult'SUCCESS
  "EXPIRED" -> P.Right E'FactorResult'EXPIRED
  "CHALLENGE" -> P.Right E'FactorResult'CHALLENGE
  "WAITING" -> P.Right E'FactorResult'WAITING
  "FAILED" -> P.Right E'FactorResult'FAILED
  "REJECTED" -> P.Right E'FactorResult'REJECTED
  "TIMEOUT" -> P.Right E'FactorResult'TIMEOUT
  "TIME_WINDOW_EXCEEDED" -> P.Right E'FactorResult'TIME_WINDOW_EXCEEDED
  "PASSCODE_REPLAYED" -> P.Right E'FactorResult'PASSCODE_REPLAYED
  "ERROR" -> P.Right E'FactorResult'ERROR
  s -> P.Left $ "toE'FactorResult: enum parse failure: " P.++ P.show s


-- ** E'GroupFilterType

-- | Enum of 'Text'
data E'GroupFilterType
  = E'GroupFilterType'STARTS_WITH -- ^ @"STARTS_WITH"@
  | E'GroupFilterType'EQUALS -- ^ @"EQUALS"@
  | E'GroupFilterType'CONTAINS -- ^ @"CONTAINS"@
  | E'GroupFilterType'REGEX -- ^ @"REGEX"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'GroupFilterType where toJSON = A.toJSON . fromE'GroupFilterType
instance A.FromJSON E'GroupFilterType where parseJSON o = P.either P.fail (pure . P.id) . toE'GroupFilterType =<< A.parseJSON o
instance WH.ToHttpApiData E'GroupFilterType where toQueryParam = WH.toQueryParam . fromE'GroupFilterType
instance WH.FromHttpApiData E'GroupFilterType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'GroupFilterType
instance MimeRender MimeMultipartFormData E'GroupFilterType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'GroupFilterType' enum
fromE'GroupFilterType :: E'GroupFilterType -> Text
fromE'GroupFilterType = \case
  E'GroupFilterType'STARTS_WITH -> "STARTS_WITH"
  E'GroupFilterType'EQUALS -> "EQUALS"
  E'GroupFilterType'CONTAINS -> "CONTAINS"
  E'GroupFilterType'REGEX -> "REGEX"

-- | parse 'E'GroupFilterType' enum
toE'GroupFilterType :: Text -> P.Either String E'GroupFilterType
toE'GroupFilterType = \case
  "STARTS_WITH" -> P.Right E'GroupFilterType'STARTS_WITH
  "EQUALS" -> P.Right E'GroupFilterType'EQUALS
  "CONTAINS" -> P.Right E'GroupFilterType'CONTAINS
  "REGEX" -> P.Right E'GroupFilterType'REGEX
  s -> P.Left $ "toE'GroupFilterType: enum parse failure: " P.++ P.show s


-- ** E'IssuerMode

-- | Enum of 'Text'
data E'IssuerMode
  = E'IssuerMode'ORG_URL -- ^ @"ORG_URL"@
  | E'IssuerMode'CUSTOM_URL -- ^ @"CUSTOM_URL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'IssuerMode where toJSON = A.toJSON . fromE'IssuerMode
instance A.FromJSON E'IssuerMode where parseJSON o = P.either P.fail (pure . P.id) . toE'IssuerMode =<< A.parseJSON o
instance WH.ToHttpApiData E'IssuerMode where toQueryParam = WH.toQueryParam . fromE'IssuerMode
instance WH.FromHttpApiData E'IssuerMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'IssuerMode
instance MimeRender MimeMultipartFormData E'IssuerMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'IssuerMode' enum
fromE'IssuerMode :: E'IssuerMode -> Text
fromE'IssuerMode = \case
  E'IssuerMode'ORG_URL -> "ORG_URL"
  E'IssuerMode'CUSTOM_URL -> "CUSTOM_URL"

-- | parse 'E'IssuerMode' enum
toE'IssuerMode :: Text -> P.Either String E'IssuerMode
toE'IssuerMode = \case
  "ORG_URL" -> P.Right E'IssuerMode'ORG_URL
  "CUSTOM_URL" -> P.Right E'IssuerMode'CUSTOM_URL
  s -> P.Left $ "toE'IssuerMode: enum parse failure: " P.++ P.show s


-- ** E'MatchType

-- | Enum of 'Text'
data E'MatchType
  = E'MatchType'EXPRESSION -- ^ @"EXPRESSION"@
  | E'MatchType'SEMVER -- ^ @"SEMVER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'MatchType where toJSON = A.toJSON . fromE'MatchType
instance A.FromJSON E'MatchType where parseJSON o = P.either P.fail (pure . P.id) . toE'MatchType =<< A.parseJSON o
instance WH.ToHttpApiData E'MatchType where toQueryParam = WH.toQueryParam . fromE'MatchType
instance WH.FromHttpApiData E'MatchType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'MatchType
instance MimeRender MimeMultipartFormData E'MatchType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'MatchType' enum
fromE'MatchType :: E'MatchType -> Text
fromE'MatchType = \case
  E'MatchType'EXPRESSION -> "EXPRESSION"
  E'MatchType'SEMVER -> "SEMVER"

-- | parse 'E'MatchType' enum
toE'MatchType :: Text -> P.Either String E'MatchType
toE'MatchType = \case
  "EXPRESSION" -> P.Right E'MatchType'EXPRESSION
  "SEMVER" -> P.Right E'MatchType'SEMVER
  s -> P.Left $ "toE'MatchType: enum parse failure: " P.++ P.show s


-- ** E'MatchType2

-- | Enum of 'Text'
data E'MatchType2
  = E'MatchType2'SUFFIX -- ^ @"SUFFIX"@
  | E'MatchType2'EXPRESSION -- ^ @"EXPRESSION"@
  | E'MatchType2'STARTS_WITH -- ^ @"STARTS_WITH"@
  | E'MatchType2'EQUALS -- ^ @"EQUALS"@
  | E'MatchType2'CONTAINS -- ^ @"CONTAINS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'MatchType2 where toJSON = A.toJSON . fromE'MatchType2
instance A.FromJSON E'MatchType2 where parseJSON o = P.either P.fail (pure . P.id) . toE'MatchType2 =<< A.parseJSON o
instance WH.ToHttpApiData E'MatchType2 where toQueryParam = WH.toQueryParam . fromE'MatchType2
instance WH.FromHttpApiData E'MatchType2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'MatchType2
instance MimeRender MimeMultipartFormData E'MatchType2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'MatchType2' enum
fromE'MatchType2 :: E'MatchType2 -> Text
fromE'MatchType2 = \case
  E'MatchType2'SUFFIX -> "SUFFIX"
  E'MatchType2'EXPRESSION -> "EXPRESSION"
  E'MatchType2'STARTS_WITH -> "STARTS_WITH"
  E'MatchType2'EQUALS -> "EQUALS"
  E'MatchType2'CONTAINS -> "CONTAINS"

-- | parse 'E'MatchType2' enum
toE'MatchType2 :: Text -> P.Either String E'MatchType2
toE'MatchType2 = \case
  "SUFFIX" -> P.Right E'MatchType2'SUFFIX
  "EXPRESSION" -> P.Right E'MatchType2'EXPRESSION
  "STARTS_WITH" -> P.Right E'MatchType2'STARTS_WITH
  "EQUALS" -> P.Right E'MatchType2'EQUALS
  "CONTAINS" -> P.Right E'MatchType2'CONTAINS
  s -> P.Left $ "toE'MatchType2: enum parse failure: " P.++ P.show s


-- ** E'MetadataPublish

-- | Enum of 'Text'
data E'MetadataPublish
  = E'MetadataPublish'ALL_CLIENTS -- ^ @"ALL_CLIENTS"@
  | E'MetadataPublish'NO_CLIENTS -- ^ @"NO_CLIENTS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'MetadataPublish where toJSON = A.toJSON . fromE'MetadataPublish
instance A.FromJSON E'MetadataPublish where parseJSON o = P.either P.fail (pure . P.id) . toE'MetadataPublish =<< A.parseJSON o
instance WH.ToHttpApiData E'MetadataPublish where toQueryParam = WH.toQueryParam . fromE'MetadataPublish
instance WH.FromHttpApiData E'MetadataPublish where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'MetadataPublish
instance MimeRender MimeMultipartFormData E'MetadataPublish where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'MetadataPublish' enum
fromE'MetadataPublish :: E'MetadataPublish -> Text
fromE'MetadataPublish = \case
  E'MetadataPublish'ALL_CLIENTS -> "ALL_CLIENTS"
  E'MetadataPublish'NO_CLIENTS -> "NO_CLIENTS"

-- | parse 'E'MetadataPublish' enum
toE'MetadataPublish :: Text -> P.Either String E'MetadataPublish
toE'MetadataPublish = \case
  "ALL_CLIENTS" -> P.Right E'MetadataPublish'ALL_CLIENTS
  "NO_CLIENTS" -> P.Right E'MetadataPublish'NO_CLIENTS
  s -> P.Left $ "toE'MetadataPublish: enum parse failure: " P.++ P.show s


-- ** E'ProfileMappingPropertyPushStatus

-- | Enum of 'A.Value'
data E'ProfileMappingPropertyPushStatus
  = E'ProfileMappingPropertyPushStatus'PUSH -- ^ @"PUSH"@
  | E'ProfileMappingPropertyPushStatus'DONT_PUSH -- ^ @"DONT_PUSH"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ProfileMappingPropertyPushStatus where toJSON = A.toJSON . fromE'ProfileMappingPropertyPushStatus
instance A.FromJSON E'ProfileMappingPropertyPushStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'ProfileMappingPropertyPushStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'ProfileMappingPropertyPushStatus where toQueryParam = WH.toQueryParam . fromE'ProfileMappingPropertyPushStatus
instance WH.FromHttpApiData E'ProfileMappingPropertyPushStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ProfileMappingPropertyPushStatus
instance MimeRender MimeMultipartFormData E'ProfileMappingPropertyPushStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ProfileMappingPropertyPushStatus' enum
fromE'ProfileMappingPropertyPushStatus :: E'ProfileMappingPropertyPushStatus -> Text
fromE'ProfileMappingPropertyPushStatus = \case
  E'ProfileMappingPropertyPushStatus'PUSH -> "PUSH"
  E'ProfileMappingPropertyPushStatus'DONT_PUSH -> "DONT_PUSH"

-- | parse 'E'ProfileMappingPropertyPushStatus' enum
toE'ProfileMappingPropertyPushStatus :: Text -> P.Either String E'ProfileMappingPropertyPushStatus
toE'ProfileMappingPropertyPushStatus = \case
  "PUSH" -> P.Right E'ProfileMappingPropertyPushStatus'PUSH
  "DONT_PUSH" -> P.Right E'ProfileMappingPropertyPushStatus'DONT_PUSH
  s -> P.Left $ "toE'ProfileMappingPropertyPushStatus: enum parse failure: " P.++ P.show s


-- ** E'Provider

-- | Enum of 'Text'
data E'Provider
  = E'Provider'ANY -- ^ @"ANY"@
  | E'Provider'OKTA -- ^ @"OKTA"@
  | E'Provider'SPECIFIC_IDP -- ^ @"SPECIFIC_IDP"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Provider where toJSON = A.toJSON . fromE'Provider
instance A.FromJSON E'Provider where parseJSON o = P.either P.fail (pure . P.id) . toE'Provider =<< A.parseJSON o
instance WH.ToHttpApiData E'Provider where toQueryParam = WH.toQueryParam . fromE'Provider
instance WH.FromHttpApiData E'Provider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Provider
instance MimeRender MimeMultipartFormData E'Provider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Provider' enum
fromE'Provider :: E'Provider -> Text
fromE'Provider = \case
  E'Provider'ANY -> "ANY"
  E'Provider'OKTA -> "OKTA"
  E'Provider'SPECIFIC_IDP -> "SPECIFIC_IDP"

-- | parse 'E'Provider' enum
toE'Provider :: Text -> P.Either String E'Provider
toE'Provider = \case
  "ANY" -> P.Right E'Provider'ANY
  "OKTA" -> P.Right E'Provider'OKTA
  "SPECIFIC_IDP" -> P.Right E'Provider'SPECIFIC_IDP
  s -> P.Left $ "toE'Provider: enum parse failure: " P.++ P.show s


-- ** E'Provider2

-- | Enum of 'Text'
data E'Provider2
  = E'Provider2'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | E'Provider2'ANY -- ^ @"ANY"@
  | E'Provider2'LDAP -- ^ @"LDAP"@
  | E'Provider2'OKTA -- ^ @"OKTA"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Provider2 where toJSON = A.toJSON . fromE'Provider2
instance A.FromJSON E'Provider2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Provider2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Provider2 where toQueryParam = WH.toQueryParam . fromE'Provider2
instance WH.FromHttpApiData E'Provider2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Provider2
instance MimeRender MimeMultipartFormData E'Provider2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Provider2' enum
fromE'Provider2 :: E'Provider2 -> Text
fromE'Provider2 = \case
  E'Provider2'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  E'Provider2'ANY -> "ANY"
  E'Provider2'LDAP -> "LDAP"
  E'Provider2'OKTA -> "OKTA"

-- | parse 'E'Provider2' enum
toE'Provider2 :: Text -> P.Either String E'Provider2
toE'Provider2 = \case
  "ACTIVE_DIRECTORY" -> P.Right E'Provider2'ACTIVE_DIRECTORY
  "ANY" -> P.Right E'Provider2'ANY
  "LDAP" -> P.Right E'Provider2'LDAP
  "OKTA" -> P.Right E'Provider2'OKTA
  s -> P.Left $ "toE'Provider2: enum parse failure: " P.++ P.show s


-- ** E'Revocation

-- | Enum of 'Text'
data E'Revocation
  = E'Revocation'CRL -- ^ @"CRL"@
  | E'Revocation'DELTA_CRL -- ^ @"DELTA_CRL"@
  | E'Revocation'OCSP -- ^ @"OCSP"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Revocation where toJSON = A.toJSON . fromE'Revocation
instance A.FromJSON E'Revocation where parseJSON o = P.either P.fail (pure . P.id) . toE'Revocation =<< A.parseJSON o
instance WH.ToHttpApiData E'Revocation where toQueryParam = WH.toQueryParam . fromE'Revocation
instance WH.FromHttpApiData E'Revocation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Revocation
instance MimeRender MimeMultipartFormData E'Revocation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Revocation' enum
fromE'Revocation :: E'Revocation -> Text
fromE'Revocation = \case
  E'Revocation'CRL -> "CRL"
  E'Revocation'DELTA_CRL -> "DELTA_CRL"
  E'Revocation'OCSP -> "OCSP"

-- | parse 'E'Revocation' enum
toE'Revocation :: Text -> P.Either String E'Revocation
toE'Revocation = \case
  "CRL" -> P.Right E'Revocation'CRL
  "DELTA_CRL" -> P.Right E'Revocation'DELTA_CRL
  "OCSP" -> P.Right E'Revocation'OCSP
  s -> P.Left $ "toE'Revocation: enum parse failure: " P.++ P.show s


-- ** E'Scope

-- | Enum of 'Text'
data E'Scope
  = E'Scope'RESPONSE -- ^ @"RESPONSE"@
  | E'Scope'TOKEN -- ^ @"TOKEN"@
  | E'Scope'ANY -- ^ @"ANY"@
  | E'Scope'REQUEST -- ^ @"REQUEST"@
  | E'Scope'NONE -- ^ @"NONE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scope where toJSON = A.toJSON . fromE'Scope
instance A.FromJSON E'Scope where parseJSON o = P.either P.fail (pure . P.id) . toE'Scope =<< A.parseJSON o
instance WH.ToHttpApiData E'Scope where toQueryParam = WH.toQueryParam . fromE'Scope
instance WH.FromHttpApiData E'Scope where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scope
instance MimeRender MimeMultipartFormData E'Scope where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scope' enum
fromE'Scope :: E'Scope -> Text
fromE'Scope = \case
  E'Scope'RESPONSE -> "RESPONSE"
  E'Scope'TOKEN -> "TOKEN"
  E'Scope'ANY -> "ANY"
  E'Scope'REQUEST -> "REQUEST"
  E'Scope'NONE -> "NONE"

-- | parse 'E'Scope' enum
toE'Scope :: Text -> P.Either String E'Scope
toE'Scope = \case
  "RESPONSE" -> P.Right E'Scope'RESPONSE
  "TOKEN" -> P.Right E'Scope'TOKEN
  "ANY" -> P.Right E'Scope'ANY
  "REQUEST" -> P.Right E'Scope'REQUEST
  "NONE" -> P.Right E'Scope'NONE
  s -> P.Left $ "toE'Scope: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text'
data E'Status
  = E'Status'ACTIVE -- ^ @"ACTIVE"@
  | E'Status'INACTIVE -- ^ @"INACTIVE"@
  | E'Status'DELETED -- ^ @"DELETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'ACTIVE -> "ACTIVE"
  E'Status'INACTIVE -> "INACTIVE"
  E'Status'DELETED -> "DELETED"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "ACTIVE" -> P.Right E'Status'ACTIVE
  "INACTIVE" -> P.Right E'Status'INACTIVE
  "DELETED" -> P.Right E'Status'DELETED
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Status2

-- | Enum of 'Text'
data E'Status2
  = E'Status2'ACTIVE -- ^ @"ACTIVE"@
  | E'Status2'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status2 where toJSON = A.toJSON . fromE'Status2
instance A.FromJSON E'Status2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status2 where toQueryParam = WH.toQueryParam . fromE'Status2
instance WH.FromHttpApiData E'Status2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status2
instance MimeRender MimeMultipartFormData E'Status2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status2' enum
fromE'Status2 :: E'Status2 -> Text
fromE'Status2 = \case
  E'Status2'ACTIVE -> "ACTIVE"
  E'Status2'INACTIVE -> "INACTIVE"

-- | parse 'E'Status2' enum
toE'Status2 :: Text -> P.Either String E'Status2
toE'Status2 = \case
  "ACTIVE" -> P.Right E'Status2'ACTIVE
  "INACTIVE" -> P.Right E'Status2'INACTIVE
  s -> P.Left $ "toE'Status2: enum parse failure: " P.++ P.show s


-- ** E'Status3

-- | Enum of 'Text'
data E'Status3
  = E'Status3'ACTIVE -- ^ @"ACTIVE"@
  | E'Status3'REVOKED -- ^ @"REVOKED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status3 where toJSON = A.toJSON . fromE'Status3
instance A.FromJSON E'Status3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status3 where toQueryParam = WH.toQueryParam . fromE'Status3
instance WH.FromHttpApiData E'Status3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status3
instance MimeRender MimeMultipartFormData E'Status3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status3' enum
fromE'Status3 :: E'Status3 -> Text
fromE'Status3 = \case
  E'Status3'ACTIVE -> "ACTIVE"
  E'Status3'REVOKED -> "REVOKED"

-- | parse 'E'Status3' enum
toE'Status3 :: Text -> P.Either String E'Status3
toE'Status3 = \case
  "ACTIVE" -> P.Right E'Status3'ACTIVE
  "REVOKED" -> P.Right E'Status3'REVOKED
  s -> P.Left $ "toE'Status3: enum parse failure: " P.++ P.show s


-- ** E'Status4

-- | Enum of 'Text'
data E'Status4
  = E'Status4'ACTIVE -- ^ @"ACTIVE"@
  | E'Status4'INACTIVE -- ^ @"INACTIVE"@
  | E'Status4'PENDING -- ^ @"PENDING"@
  | E'Status4'DELETED -- ^ @"DELETED"@
  | E'Status4'EXPIRED_PASSWORD -- ^ @"EXPIRED_PASSWORD"@
  | E'Status4'ACTIVATING -- ^ @"ACTIVATING"@
  | E'Status4'SUSPENDED -- ^ @"SUSPENDED"@
  | E'Status4'DELETING -- ^ @"DELETING"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status4 where toJSON = A.toJSON . fromE'Status4
instance A.FromJSON E'Status4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status4 where toQueryParam = WH.toQueryParam . fromE'Status4
instance WH.FromHttpApiData E'Status4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status4
instance MimeRender MimeMultipartFormData E'Status4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status4' enum
fromE'Status4 :: E'Status4 -> Text
fromE'Status4 = \case
  E'Status4'ACTIVE -> "ACTIVE"
  E'Status4'INACTIVE -> "INACTIVE"
  E'Status4'PENDING -> "PENDING"
  E'Status4'DELETED -> "DELETED"
  E'Status4'EXPIRED_PASSWORD -> "EXPIRED_PASSWORD"
  E'Status4'ACTIVATING -> "ACTIVATING"
  E'Status4'SUSPENDED -> "SUSPENDED"
  E'Status4'DELETING -> "DELETING"

-- | parse 'E'Status4' enum
toE'Status4 :: Text -> P.Either String E'Status4
toE'Status4 = \case
  "ACTIVE" -> P.Right E'Status4'ACTIVE
  "INACTIVE" -> P.Right E'Status4'INACTIVE
  "PENDING" -> P.Right E'Status4'PENDING
  "DELETED" -> P.Right E'Status4'DELETED
  "EXPIRED_PASSWORD" -> P.Right E'Status4'EXPIRED_PASSWORD
  "ACTIVATING" -> P.Right E'Status4'ACTIVATING
  "SUSPENDED" -> P.Right E'Status4'SUSPENDED
  "DELETING" -> P.Right E'Status4'DELETING
  s -> P.Left $ "toE'Status4: enum parse failure: " P.++ P.show s


-- ** E'SupportedMdmFrameworks

-- | Enum of 'Text'
data E'SupportedMdmFrameworks
  = E'SupportedMdmFrameworks'AFW -- ^ @"AFW"@
  | E'SupportedMdmFrameworks'SAFE -- ^ @"SAFE"@
  | E'SupportedMdmFrameworks'NATIVE -- ^ @"NATIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SupportedMdmFrameworks where toJSON = A.toJSON . fromE'SupportedMdmFrameworks
instance A.FromJSON E'SupportedMdmFrameworks where parseJSON o = P.either P.fail (pure . P.id) . toE'SupportedMdmFrameworks =<< A.parseJSON o
instance WH.ToHttpApiData E'SupportedMdmFrameworks where toQueryParam = WH.toQueryParam . fromE'SupportedMdmFrameworks
instance WH.FromHttpApiData E'SupportedMdmFrameworks where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SupportedMdmFrameworks
instance MimeRender MimeMultipartFormData E'SupportedMdmFrameworks where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SupportedMdmFrameworks' enum
fromE'SupportedMdmFrameworks :: E'SupportedMdmFrameworks -> Text
fromE'SupportedMdmFrameworks = \case
  E'SupportedMdmFrameworks'AFW -> "AFW"
  E'SupportedMdmFrameworks'SAFE -> "SAFE"
  E'SupportedMdmFrameworks'NATIVE -> "NATIVE"

-- | parse 'E'SupportedMdmFrameworks' enum
toE'SupportedMdmFrameworks :: Text -> P.Either String E'SupportedMdmFrameworks
toE'SupportedMdmFrameworks = \case
  "AFW" -> P.Right E'SupportedMdmFrameworks'AFW
  "SAFE" -> P.Right E'SupportedMdmFrameworks'SAFE
  "NATIVE" -> P.Right E'SupportedMdmFrameworks'NATIVE
  s -> P.Left $ "toE'SupportedMdmFrameworks: enum parse failure: " P.++ P.show s


-- ** E'TrustLevel

-- | Enum of 'Text'
data E'TrustLevel
  = E'TrustLevel'ANY -- ^ @"ANY"@
  | E'TrustLevel'TRUSTED -- ^ @"TRUSTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'TrustLevel where toJSON = A.toJSON . fromE'TrustLevel
instance A.FromJSON E'TrustLevel where parseJSON o = P.either P.fail (pure . P.id) . toE'TrustLevel =<< A.parseJSON o
instance WH.ToHttpApiData E'TrustLevel where toQueryParam = WH.toQueryParam . fromE'TrustLevel
instance WH.FromHttpApiData E'TrustLevel where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'TrustLevel
instance MimeRender MimeMultipartFormData E'TrustLevel where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'TrustLevel' enum
fromE'TrustLevel :: E'TrustLevel -> Text
fromE'TrustLevel = \case
  E'TrustLevel'ANY -> "ANY"
  E'TrustLevel'TRUSTED -> "TRUSTED"

-- | parse 'E'TrustLevel' enum
toE'TrustLevel :: Text -> P.Either String E'TrustLevel
toE'TrustLevel = \case
  "ANY" -> P.Right E'TrustLevel'ANY
  "TRUSTED" -> P.Right E'TrustLevel'TRUSTED
  s -> P.Left $ "toE'TrustLevel: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'APP_TYPE -- ^ @"APP_TYPE"@
  | E'Type'APP -- ^ @"APP"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'APP_TYPE -> "APP_TYPE"
  E'Type'APP -> "APP"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "APP_TYPE" -> P.Right E'Type'APP_TYPE
  "APP" -> P.Right E'Type'APP
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type10

-- | Enum of 'Text'
data E'Type10
  = E'Type10'INSTANCE -- ^ @"INSTANCE"@
  | E'Type10'ORG -- ^ @"ORG"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type10 where toJSON = A.toJSON . fromE'Type10
instance A.FromJSON E'Type10 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type10 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type10 where toQueryParam = WH.toQueryParam . fromE'Type10
instance WH.FromHttpApiData E'Type10 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type10
instance MimeRender MimeMultipartFormData E'Type10 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type10' enum
fromE'Type10 :: E'Type10 -> Text
fromE'Type10 = \case
  E'Type10'INSTANCE -> "INSTANCE"
  E'Type10'ORG -> "ORG"

-- | parse 'E'Type10' enum
toE'Type10 :: Text -> P.Either String E'Type10
toE'Type10 = \case
  "INSTANCE" -> P.Right E'Type10'INSTANCE
  "ORG" -> P.Right E'Type10'ORG
  s -> P.Left $ "toE'Type10: enum parse failure: " P.++ P.show s


-- ** E'Type11

-- | Enum of 'Text'
data E'Type11
  = E'Type11'IDENTIFIER -- ^ @"IDENTIFIER"@
  | E'Type11'ATTRIBUTE -- ^ @"ATTRIBUTE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type11 where toJSON = A.toJSON . fromE'Type11
instance A.FromJSON E'Type11 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type11 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type11 where toQueryParam = WH.toQueryParam . fromE'Type11
instance WH.FromHttpApiData E'Type11 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type11
instance MimeRender MimeMultipartFormData E'Type11 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type11' enum
fromE'Type11 :: E'Type11 -> Text
fromE'Type11 = \case
  E'Type11'IDENTIFIER -> "IDENTIFIER"
  E'Type11'ATTRIBUTE -> "ATTRIBUTE"

-- | parse 'E'Type11' enum
toE'Type11 :: Text -> P.Either String E'Type11
toE'Type11 = \case
  "IDENTIFIER" -> P.Right E'Type11'IDENTIFIER
  "ATTRIBUTE" -> P.Right E'Type11'ATTRIBUTE
  s -> P.Left $ "toE'Type11: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text'
data E'Type2
  = E'Type2'HTTP -- ^ @"HTTP"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'HTTP -> "HTTP"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "HTTP" -> P.Right E'Type2'HTTP
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text'
data E'Type3
  = E'Type3'EVENT_TYPE -- ^ @"EVENT_TYPE"@
  | E'Type3'FLOW_EVENT -- ^ @"FLOW_EVENT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'EVENT_TYPE -> "EVENT_TYPE"
  E'Type3'FLOW_EVENT -> "FLOW_EVENT"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "EVENT_TYPE" -> P.Right E'Type3'EVENT_TYPE
  "FLOW_EVENT" -> P.Right E'Type3'FLOW_EVENT
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text'
data E'Type4
  = E'Type4'SAML2 -- ^ @"SAML2"@
  | E'Type4'GOOGLE -- ^ @"GOOGLE"@
  | E'Type4'FACEBOOK -- ^ @"FACEBOOK"@
  | E'Type4'LINKEDIN -- ^ @"LINKEDIN"@
  | E'Type4'MICROSOFT -- ^ @"MICROSOFT"@
  | E'Type4'OIDC -- ^ @"OIDC"@
  | E'Type4'OKTA -- ^ @"OKTA"@
  | E'Type4'IWA -- ^ @"IWA"@
  | E'Type4'AgentlessDSSO -- ^ @"AgentlessDSSO"@
  | E'Type4'X509 -- ^ @"X509"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'SAML2 -> "SAML2"
  E'Type4'GOOGLE -> "GOOGLE"
  E'Type4'FACEBOOK -> "FACEBOOK"
  E'Type4'LINKEDIN -> "LINKEDIN"
  E'Type4'MICROSOFT -> "MICROSOFT"
  E'Type4'OIDC -> "OIDC"
  E'Type4'OKTA -> "OKTA"
  E'Type4'IWA -> "IWA"
  E'Type4'AgentlessDSSO -> "AgentlessDSSO"
  E'Type4'X509 -> "X509"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "SAML2" -> P.Right E'Type4'SAML2
  "GOOGLE" -> P.Right E'Type4'GOOGLE
  "FACEBOOK" -> P.Right E'Type4'FACEBOOK
  "LINKEDIN" -> P.Right E'Type4'LINKEDIN
  "MICROSOFT" -> P.Right E'Type4'MICROSOFT
  "OIDC" -> P.Right E'Type4'OIDC
  "OKTA" -> P.Right E'Type4'OKTA
  "IWA" -> P.Right E'Type4'IWA
  "AgentlessDSSO" -> P.Right E'Type4'AgentlessDSSO
  "X509" -> P.Right E'Type4'X509
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** E'Type5

-- | Enum of 'Text'
data E'Type5
  = E'Type5'RESOURCE_ACCESS -- ^ @"RESOURCE_ACCESS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type5 where toJSON = A.toJSON . fromE'Type5
instance A.FromJSON E'Type5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type5 where toQueryParam = WH.toQueryParam . fromE'Type5
instance WH.FromHttpApiData E'Type5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type5
instance MimeRender MimeMultipartFormData E'Type5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type5' enum
fromE'Type5 :: E'Type5 -> Text
fromE'Type5 = \case
  E'Type5'RESOURCE_ACCESS -> "RESOURCE_ACCESS"

-- | parse 'E'Type5' enum
toE'Type5 :: Text -> P.Either String E'Type5
toE'Type5 = \case
  "RESOURCE_ACCESS" -> P.Right E'Type5'RESOURCE_ACCESS
  s -> P.Left $ "toE'Type5: enum parse failure: " P.++ P.show s


-- ** E'Type6

-- | Enum of 'Text'
data E'Type6
  = E'Type6'DESKTOP -- ^ @"DESKTOP"@
  | E'Type6'MOBILE -- ^ @"MOBILE"@
  | E'Type6'OTHER -- ^ @"OTHER"@
  | E'Type6'ANY -- ^ @"ANY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type6 where toJSON = A.toJSON . fromE'Type6
instance A.FromJSON E'Type6 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type6 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type6 where toQueryParam = WH.toQueryParam . fromE'Type6
instance WH.FromHttpApiData E'Type6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type6
instance MimeRender MimeMultipartFormData E'Type6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type6' enum
fromE'Type6 :: E'Type6 -> Text
fromE'Type6 = \case
  E'Type6'DESKTOP -> "DESKTOP"
  E'Type6'MOBILE -> "MOBILE"
  E'Type6'OTHER -> "OTHER"
  E'Type6'ANY -> "ANY"

-- | parse 'E'Type6' enum
toE'Type6 :: Text -> P.Either String E'Type6
toE'Type6 = \case
  "DESKTOP" -> P.Right E'Type6'DESKTOP
  "MOBILE" -> P.Right E'Type6'MOBILE
  "OTHER" -> P.Right E'Type6'OTHER
  "ANY" -> P.Right E'Type6'ANY
  s -> P.Left $ "toE'Type6: enum parse failure: " P.++ P.show s


-- ** E'Type7

-- | Enum of 'Text'
data E'Type7
  = E'Type7'ANDROID -- ^ @"ANDROID"@
  | E'Type7'IOS -- ^ @"IOS"@
  | E'Type7'WINDOWS -- ^ @"WINDOWS"@
  | E'Type7'OSX -- ^ @"OSX"@
  | E'Type7'OTHER -- ^ @"OTHER"@
  | E'Type7'ANY -- ^ @"ANY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type7 where toJSON = A.toJSON . fromE'Type7
instance A.FromJSON E'Type7 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type7 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type7 where toQueryParam = WH.toQueryParam . fromE'Type7
instance WH.FromHttpApiData E'Type7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type7
instance MimeRender MimeMultipartFormData E'Type7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type7' enum
fromE'Type7 :: E'Type7 -> Text
fromE'Type7 = \case
  E'Type7'ANDROID -> "ANDROID"
  E'Type7'IOS -> "IOS"
  E'Type7'WINDOWS -> "WINDOWS"
  E'Type7'OSX -> "OSX"
  E'Type7'OTHER -> "OTHER"
  E'Type7'ANY -> "ANY"

-- | parse 'E'Type7' enum
toE'Type7 :: Text -> P.Either String E'Type7
toE'Type7 = \case
  "ANDROID" -> P.Right E'Type7'ANDROID
  "IOS" -> P.Right E'Type7'IOS
  "WINDOWS" -> P.Right E'Type7'WINDOWS
  "OSX" -> P.Right E'Type7'OSX
  "OTHER" -> P.Right E'Type7'OTHER
  "ANY" -> P.Right E'Type7'ANY
  s -> P.Left $ "toE'Type7: enum parse failure: " P.++ P.show s


-- ** E'Type8

-- | Enum of 'Text'
data E'Type8
  = E'Type8'SIGN_ON -- ^ @"SIGN_ON"@
  | E'Type8'PASSWORD -- ^ @"PASSWORD"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type8 where toJSON = A.toJSON . fromE'Type8
instance A.FromJSON E'Type8 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type8 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type8 where toQueryParam = WH.toQueryParam . fromE'Type8
instance WH.FromHttpApiData E'Type8 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type8
instance MimeRender MimeMultipartFormData E'Type8 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type8' enum
fromE'Type8 :: E'Type8 -> Text
fromE'Type8 = \case
  E'Type8'SIGN_ON -> "SIGN_ON"
  E'Type8'PASSWORD -> "PASSWORD"

-- | parse 'E'Type8' enum
toE'Type8 :: Text -> P.Either String E'Type8
toE'Type8 = \case
  "SIGN_ON" -> P.Right E'Type8'SIGN_ON
  "PASSWORD" -> P.Right E'Type8'PASSWORD
  s -> P.Left $ "toE'Type8: enum parse failure: " P.++ P.show s


-- ** E'Type9

-- | Enum of 'Text'
data E'Type9
  = E'Type9'SAML2 -- ^ @"SAML2"@
  | E'Type9'OIDC -- ^ @"OIDC"@
  | E'Type9'OAUTH2 -- ^ @"OAUTH2"@
  | E'Type9'MTLS -- ^ @"MTLS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type9 where toJSON = A.toJSON . fromE'Type9
instance A.FromJSON E'Type9 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type9 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type9 where toQueryParam = WH.toQueryParam . fromE'Type9
instance WH.FromHttpApiData E'Type9 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type9
instance MimeRender MimeMultipartFormData E'Type9 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type9' enum
fromE'Type9 :: E'Type9 -> Text
fromE'Type9 = \case
  E'Type9'SAML2 -> "SAML2"
  E'Type9'OIDC -> "OIDC"
  E'Type9'OAUTH2 -> "OAUTH2"
  E'Type9'MTLS -> "MTLS"

-- | parse 'E'Type9' enum
toE'Type9 :: Text -> P.Either String E'Type9
toE'Type9 = \case
  "SAML2" -> P.Right E'Type9'SAML2
  "OIDC" -> P.Right E'Type9'OIDC
  "OAUTH2" -> P.Right E'Type9'OAUTH2
  "MTLS" -> P.Right E'Type9'MTLS
  s -> P.Left $ "toE'Type9: enum parse failure: " P.++ P.show s


-- ** E'Types

-- | Enum of 'Text'
data E'Types
  = E'Types'IOS -- ^ @"IOS"@
  | E'Types'ANDROID -- ^ @"ANDROID"@
  | E'Types'OSX -- ^ @"OSX"@
  | E'Types'WINDOWS -- ^ @"WINDOWS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Types where toJSON = A.toJSON . fromE'Types
instance A.FromJSON E'Types where parseJSON o = P.either P.fail (pure . P.id) . toE'Types =<< A.parseJSON o
instance WH.ToHttpApiData E'Types where toQueryParam = WH.toQueryParam . fromE'Types
instance WH.FromHttpApiData E'Types where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Types
instance MimeRender MimeMultipartFormData E'Types where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Types' enum
fromE'Types :: E'Types -> Text
fromE'Types = \case
  E'Types'IOS -> "IOS"
  E'Types'ANDROID -> "ANDROID"
  E'Types'OSX -> "OSX"
  E'Types'WINDOWS -> "WINDOWS"

-- | parse 'E'Types' enum
toE'Types :: Text -> P.Either String E'Types
toE'Types = \case
  "IOS" -> P.Right E'Types'IOS
  "ANDROID" -> P.Right E'Types'ANDROID
  "OSX" -> P.Right E'Types'OSX
  "WINDOWS" -> P.Right E'Types'WINDOWS
  s -> P.Left $ "toE'Types: enum parse failure: " P.++ P.show s


-- ** E'Use

-- | Enum of 'Text'
data E'Use
  = E'Use'Sig -- ^ @"sig"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Use where toJSON = A.toJSON . fromE'Use
instance A.FromJSON E'Use where parseJSON o = P.either P.fail (pure . P.id) . toE'Use =<< A.parseJSON o
instance WH.ToHttpApiData E'Use where toQueryParam = WH.toQueryParam . fromE'Use
instance WH.FromHttpApiData E'Use where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Use
instance MimeRender MimeMultipartFormData E'Use where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Use' enum
fromE'Use :: E'Use -> Text
fromE'Use = \case
  E'Use'Sig -> "sig"

-- | parse 'E'Use' enum
toE'Use :: Text -> P.Either String E'Use
toE'Use = \case
  "sig" -> P.Right E'Use'Sig
  s -> P.Left $ "toE'Use: enum parse failure: " P.++ P.show s


-- ** E'UserSchemaAttributeScope

-- | Enum of 'A.Value'
data E'UserSchemaAttributeScope
  = E'UserSchemaAttributeScope'SELF -- ^ @"SELF"@
  | E'UserSchemaAttributeScope'NONE -- ^ @"NONE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UserSchemaAttributeScope where toJSON = A.toJSON . fromE'UserSchemaAttributeScope
instance A.FromJSON E'UserSchemaAttributeScope where parseJSON o = P.either P.fail (pure . P.id) . toE'UserSchemaAttributeScope =<< A.parseJSON o
instance WH.ToHttpApiData E'UserSchemaAttributeScope where toQueryParam = WH.toQueryParam . fromE'UserSchemaAttributeScope
instance WH.FromHttpApiData E'UserSchemaAttributeScope where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UserSchemaAttributeScope
instance MimeRender MimeMultipartFormData E'UserSchemaAttributeScope where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UserSchemaAttributeScope' enum
fromE'UserSchemaAttributeScope :: E'UserSchemaAttributeScope -> Text
fromE'UserSchemaAttributeScope = \case
  E'UserSchemaAttributeScope'SELF -> "SELF"
  E'UserSchemaAttributeScope'NONE -> "NONE"

-- | parse 'E'UserSchemaAttributeScope' enum
toE'UserSchemaAttributeScope :: Text -> P.Either String E'UserSchemaAttributeScope
toE'UserSchemaAttributeScope = \case
  "SELF" -> P.Right E'UserSchemaAttributeScope'SELF
  "NONE" -> P.Right E'UserSchemaAttributeScope'NONE
  s -> P.Left $ "toE'UserSchemaAttributeScope: enum parse failure: " P.++ P.show s


-- ** E'UserSchemaAttributeUnion

-- | Enum of 'A.Value'
data E'UserSchemaAttributeUnion
  = E'UserSchemaAttributeUnion'DISABLE -- ^ @"DISABLE"@
  | E'UserSchemaAttributeUnion'ENABLE -- ^ @"ENABLE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UserSchemaAttributeUnion where toJSON = A.toJSON . fromE'UserSchemaAttributeUnion
instance A.FromJSON E'UserSchemaAttributeUnion where parseJSON o = P.either P.fail (pure . P.id) . toE'UserSchemaAttributeUnion =<< A.parseJSON o
instance WH.ToHttpApiData E'UserSchemaAttributeUnion where toQueryParam = WH.toQueryParam . fromE'UserSchemaAttributeUnion
instance WH.FromHttpApiData E'UserSchemaAttributeUnion where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UserSchemaAttributeUnion
instance MimeRender MimeMultipartFormData E'UserSchemaAttributeUnion where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UserSchemaAttributeUnion' enum
fromE'UserSchemaAttributeUnion :: E'UserSchemaAttributeUnion -> Text
fromE'UserSchemaAttributeUnion = \case
  E'UserSchemaAttributeUnion'DISABLE -> "DISABLE"
  E'UserSchemaAttributeUnion'ENABLE -> "ENABLE"

-- | parse 'E'UserSchemaAttributeUnion' enum
toE'UserSchemaAttributeUnion :: Text -> P.Either String E'UserSchemaAttributeUnion
toE'UserSchemaAttributeUnion = \case
  "DISABLE" -> P.Right E'UserSchemaAttributeUnion'DISABLE
  "ENABLE" -> P.Right E'UserSchemaAttributeUnion'ENABLE
  s -> P.Left $ "toE'UserSchemaAttributeUnion: enum parse failure: " P.++ P.show s


-- ** E'ValueType

-- | Enum of 'Text'
data E'ValueType
  = E'ValueType'EXPRESSION -- ^ @"EXPRESSION"@
  | E'ValueType'GROUPS -- ^ @"GROUPS"@
  | E'ValueType'SYSTEM -- ^ @"SYSTEM"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ValueType where toJSON = A.toJSON . fromE'ValueType
instance A.FromJSON E'ValueType where parseJSON o = P.either P.fail (pure . P.id) . toE'ValueType =<< A.parseJSON o
instance WH.ToHttpApiData E'ValueType where toQueryParam = WH.toQueryParam . fromE'ValueType
instance WH.FromHttpApiData E'ValueType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ValueType
instance MimeRender MimeMultipartFormData E'ValueType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ValueType' enum
fromE'ValueType :: E'ValueType -> Text
fromE'ValueType = \case
  E'ValueType'EXPRESSION -> "EXPRESSION"
  E'ValueType'GROUPS -> "GROUPS"
  E'ValueType'SYSTEM -> "SYSTEM"

-- | parse 'E'ValueType' enum
toE'ValueType :: Text -> P.Either String E'ValueType
toE'ValueType = \case
  "EXPRESSION" -> P.Right E'ValueType'EXPRESSION
  "GROUPS" -> P.Right E'ValueType'GROUPS
  "SYSTEM" -> P.Right E'ValueType'SYSTEM
  s -> P.Left $ "toE'ValueType: enum parse failure: " P.++ P.show s


-- ** E'VerificationStatus

-- | Enum of 'Text'
data E'VerificationStatus
  = E'VerificationStatus'UNVERIFIED -- ^ @"UNVERIFIED"@
  | E'VerificationStatus'VERIFIED -- ^ @"VERIFIED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'VerificationStatus where toJSON = A.toJSON . fromE'VerificationStatus
instance A.FromJSON E'VerificationStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'VerificationStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'VerificationStatus where toQueryParam = WH.toQueryParam . fromE'VerificationStatus
instance WH.FromHttpApiData E'VerificationStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'VerificationStatus
instance MimeRender MimeMultipartFormData E'VerificationStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'VerificationStatus' enum
fromE'VerificationStatus :: E'VerificationStatus -> Text
fromE'VerificationStatus = \case
  E'VerificationStatus'UNVERIFIED -> "UNVERIFIED"
  E'VerificationStatus'VERIFIED -> "VERIFIED"

-- | parse 'E'VerificationStatus' enum
toE'VerificationStatus :: Text -> P.Either String E'VerificationStatus
toE'VerificationStatus = \case
  "UNVERIFIED" -> P.Right E'VerificationStatus'UNVERIFIED
  "VERIFIED" -> P.Right E'VerificationStatus'VERIFIED
  s -> P.Left $ "toE'VerificationStatus: enum parse failure: " P.++ P.show s


-- ** EmailTemplateTouchPointVariant

-- | Enum of 'Text'
data EmailTemplateTouchPointVariant
  = EmailTemplateTouchPointVariant'OKTA_DEFAULT -- ^ @"OKTA_DEFAULT"@
  | EmailTemplateTouchPointVariant'FULL_THEME -- ^ @"FULL_THEME"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EmailTemplateTouchPointVariant where toJSON = A.toJSON . fromEmailTemplateTouchPointVariant
instance A.FromJSON EmailTemplateTouchPointVariant where parseJSON o = P.either P.fail (pure . P.id) . toEmailTemplateTouchPointVariant =<< A.parseJSON o
instance WH.ToHttpApiData EmailTemplateTouchPointVariant where toQueryParam = WH.toQueryParam . fromEmailTemplateTouchPointVariant
instance WH.FromHttpApiData EmailTemplateTouchPointVariant where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEmailTemplateTouchPointVariant
instance MimeRender MimeMultipartFormData EmailTemplateTouchPointVariant where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EmailTemplateTouchPointVariant' enum
fromEmailTemplateTouchPointVariant :: EmailTemplateTouchPointVariant -> Text
fromEmailTemplateTouchPointVariant = \case
  EmailTemplateTouchPointVariant'OKTA_DEFAULT -> "OKTA_DEFAULT"
  EmailTemplateTouchPointVariant'FULL_THEME -> "FULL_THEME"

-- | parse 'EmailTemplateTouchPointVariant' enum
toEmailTemplateTouchPointVariant :: Text -> P.Either String EmailTemplateTouchPointVariant
toEmailTemplateTouchPointVariant = \case
  "OKTA_DEFAULT" -> P.Right EmailTemplateTouchPointVariant'OKTA_DEFAULT
  "FULL_THEME" -> P.Right EmailTemplateTouchPointVariant'FULL_THEME
  s -> P.Left $ "toEmailTemplateTouchPointVariant: enum parse failure: " P.++ P.show s


-- ** EnabledStatus

-- | Enum of 'Text'
data EnabledStatus
  = EnabledStatus'ENABLED -- ^ @"ENABLED"@
  | EnabledStatus'DISABLED -- ^ @"DISABLED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EnabledStatus where toJSON = A.toJSON . fromEnabledStatus
instance A.FromJSON EnabledStatus where parseJSON o = P.either P.fail (pure . P.id) . toEnabledStatus =<< A.parseJSON o
instance WH.ToHttpApiData EnabledStatus where toQueryParam = WH.toQueryParam . fromEnabledStatus
instance WH.FromHttpApiData EnabledStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEnabledStatus
instance MimeRender MimeMultipartFormData EnabledStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EnabledStatus' enum
fromEnabledStatus :: EnabledStatus -> Text
fromEnabledStatus = \case
  EnabledStatus'ENABLED -> "ENABLED"
  EnabledStatus'DISABLED -> "DISABLED"

-- | parse 'EnabledStatus' enum
toEnabledStatus :: Text -> P.Either String EnabledStatus
toEnabledStatus = \case
  "ENABLED" -> P.Right EnabledStatus'ENABLED
  "DISABLED" -> P.Right EnabledStatus'DISABLED
  s -> P.Left $ "toEnabledStatus: enum parse failure: " P.++ P.show s


-- ** EndUserDashboardTouchPointVariant

-- | Enum of 'Text'
data EndUserDashboardTouchPointVariant
  = EndUserDashboardTouchPointVariant'OKTA_DEFAULT -- ^ @"OKTA_DEFAULT"@
  | EndUserDashboardTouchPointVariant'WHITE_LOGO_BACKGROUND -- ^ @"WHITE_LOGO_BACKGROUND"@
  | EndUserDashboardTouchPointVariant'FULL_THEME -- ^ @"FULL_THEME"@
  | EndUserDashboardTouchPointVariant'LOGO_ON_FULL_WHITE_BACKGROUND -- ^ @"LOGO_ON_FULL_WHITE_BACKGROUND"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EndUserDashboardTouchPointVariant where toJSON = A.toJSON . fromEndUserDashboardTouchPointVariant
instance A.FromJSON EndUserDashboardTouchPointVariant where parseJSON o = P.either P.fail (pure . P.id) . toEndUserDashboardTouchPointVariant =<< A.parseJSON o
instance WH.ToHttpApiData EndUserDashboardTouchPointVariant where toQueryParam = WH.toQueryParam . fromEndUserDashboardTouchPointVariant
instance WH.FromHttpApiData EndUserDashboardTouchPointVariant where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEndUserDashboardTouchPointVariant
instance MimeRender MimeMultipartFormData EndUserDashboardTouchPointVariant where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EndUserDashboardTouchPointVariant' enum
fromEndUserDashboardTouchPointVariant :: EndUserDashboardTouchPointVariant -> Text
fromEndUserDashboardTouchPointVariant = \case
  EndUserDashboardTouchPointVariant'OKTA_DEFAULT -> "OKTA_DEFAULT"
  EndUserDashboardTouchPointVariant'WHITE_LOGO_BACKGROUND -> "WHITE_LOGO_BACKGROUND"
  EndUserDashboardTouchPointVariant'FULL_THEME -> "FULL_THEME"
  EndUserDashboardTouchPointVariant'LOGO_ON_FULL_WHITE_BACKGROUND -> "LOGO_ON_FULL_WHITE_BACKGROUND"

-- | parse 'EndUserDashboardTouchPointVariant' enum
toEndUserDashboardTouchPointVariant :: Text -> P.Either String EndUserDashboardTouchPointVariant
toEndUserDashboardTouchPointVariant = \case
  "OKTA_DEFAULT" -> P.Right EndUserDashboardTouchPointVariant'OKTA_DEFAULT
  "WHITE_LOGO_BACKGROUND" -> P.Right EndUserDashboardTouchPointVariant'WHITE_LOGO_BACKGROUND
  "FULL_THEME" -> P.Right EndUserDashboardTouchPointVariant'FULL_THEME
  "LOGO_ON_FULL_WHITE_BACKGROUND" -> P.Right EndUserDashboardTouchPointVariant'LOGO_ON_FULL_WHITE_BACKGROUND
  s -> P.Left $ "toEndUserDashboardTouchPointVariant: enum parse failure: " P.++ P.show s


-- ** ErrorPageTouchPointVariant

-- | Enum of 'Text'
data ErrorPageTouchPointVariant
  = ErrorPageTouchPointVariant'OKTA_DEFAULT -- ^ @"OKTA_DEFAULT"@
  | ErrorPageTouchPointVariant'BACKGROUND_SECONDARY_COLOR -- ^ @"BACKGROUND_SECONDARY_COLOR"@
  | ErrorPageTouchPointVariant'BACKGROUND_IMAGE -- ^ @"BACKGROUND_IMAGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ErrorPageTouchPointVariant where toJSON = A.toJSON . fromErrorPageTouchPointVariant
instance A.FromJSON ErrorPageTouchPointVariant where parseJSON o = P.either P.fail (pure . P.id) . toErrorPageTouchPointVariant =<< A.parseJSON o
instance WH.ToHttpApiData ErrorPageTouchPointVariant where toQueryParam = WH.toQueryParam . fromErrorPageTouchPointVariant
instance WH.FromHttpApiData ErrorPageTouchPointVariant where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toErrorPageTouchPointVariant
instance MimeRender MimeMultipartFormData ErrorPageTouchPointVariant where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ErrorPageTouchPointVariant' enum
fromErrorPageTouchPointVariant :: ErrorPageTouchPointVariant -> Text
fromErrorPageTouchPointVariant = \case
  ErrorPageTouchPointVariant'OKTA_DEFAULT -> "OKTA_DEFAULT"
  ErrorPageTouchPointVariant'BACKGROUND_SECONDARY_COLOR -> "BACKGROUND_SECONDARY_COLOR"
  ErrorPageTouchPointVariant'BACKGROUND_IMAGE -> "BACKGROUND_IMAGE"

-- | parse 'ErrorPageTouchPointVariant' enum
toErrorPageTouchPointVariant :: Text -> P.Either String ErrorPageTouchPointVariant
toErrorPageTouchPointVariant = \case
  "OKTA_DEFAULT" -> P.Right ErrorPageTouchPointVariant'OKTA_DEFAULT
  "BACKGROUND_SECONDARY_COLOR" -> P.Right ErrorPageTouchPointVariant'BACKGROUND_SECONDARY_COLOR
  "BACKGROUND_IMAGE" -> P.Right ErrorPageTouchPointVariant'BACKGROUND_IMAGE
  s -> P.Left $ "toErrorPageTouchPointVariant: enum parse failure: " P.++ P.show s


-- ** EventHookChannelConfigAuthSchemeType

-- | Enum of 'Text'
data EventHookChannelConfigAuthSchemeType
  = EventHookChannelConfigAuthSchemeType'HEADER -- ^ @"HEADER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EventHookChannelConfigAuthSchemeType where toJSON = A.toJSON . fromEventHookChannelConfigAuthSchemeType
instance A.FromJSON EventHookChannelConfigAuthSchemeType where parseJSON o = P.either P.fail (pure . P.id) . toEventHookChannelConfigAuthSchemeType =<< A.parseJSON o
instance WH.ToHttpApiData EventHookChannelConfigAuthSchemeType where toQueryParam = WH.toQueryParam . fromEventHookChannelConfigAuthSchemeType
instance WH.FromHttpApiData EventHookChannelConfigAuthSchemeType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEventHookChannelConfigAuthSchemeType
instance MimeRender MimeMultipartFormData EventHookChannelConfigAuthSchemeType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EventHookChannelConfigAuthSchemeType' enum
fromEventHookChannelConfigAuthSchemeType :: EventHookChannelConfigAuthSchemeType -> Text
fromEventHookChannelConfigAuthSchemeType = \case
  EventHookChannelConfigAuthSchemeType'HEADER -> "HEADER"

-- | parse 'EventHookChannelConfigAuthSchemeType' enum
toEventHookChannelConfigAuthSchemeType :: Text -> P.Either String EventHookChannelConfigAuthSchemeType
toEventHookChannelConfigAuthSchemeType = \case
  "HEADER" -> P.Right EventHookChannelConfigAuthSchemeType'HEADER
  s -> P.Left $ "toEventHookChannelConfigAuthSchemeType: enum parse failure: " P.++ P.show s


-- ** FactorProvider

-- | Enum of 'Text'
data FactorProvider
  = FactorProvider'OKTA -- ^ @"OKTA"@
  | FactorProvider'RSA -- ^ @"RSA"@
  | FactorProvider'FIDO -- ^ @"FIDO"@
  | FactorProvider'GOOGLE -- ^ @"GOOGLE"@
  | FactorProvider'SYMANTEC -- ^ @"SYMANTEC"@
  | FactorProvider'DUO -- ^ @"DUO"@
  | FactorProvider'YUBICO -- ^ @"YUBICO"@
  | FactorProvider'CUSTOM -- ^ @"CUSTOM"@
  | FactorProvider'APPLE -- ^ @"APPLE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorProvider where toJSON = A.toJSON . fromFactorProvider
instance A.FromJSON FactorProvider where parseJSON o = P.either P.fail (pure . P.id) . toFactorProvider =<< A.parseJSON o
instance WH.ToHttpApiData FactorProvider where toQueryParam = WH.toQueryParam . fromFactorProvider
instance WH.FromHttpApiData FactorProvider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorProvider
instance MimeRender MimeMultipartFormData FactorProvider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorProvider' enum
fromFactorProvider :: FactorProvider -> Text
fromFactorProvider = \case
  FactorProvider'OKTA -> "OKTA"
  FactorProvider'RSA -> "RSA"
  FactorProvider'FIDO -> "FIDO"
  FactorProvider'GOOGLE -> "GOOGLE"
  FactorProvider'SYMANTEC -> "SYMANTEC"
  FactorProvider'DUO -> "DUO"
  FactorProvider'YUBICO -> "YUBICO"
  FactorProvider'CUSTOM -> "CUSTOM"
  FactorProvider'APPLE -> "APPLE"

-- | parse 'FactorProvider' enum
toFactorProvider :: Text -> P.Either String FactorProvider
toFactorProvider = \case
  "OKTA" -> P.Right FactorProvider'OKTA
  "RSA" -> P.Right FactorProvider'RSA
  "FIDO" -> P.Right FactorProvider'FIDO
  "GOOGLE" -> P.Right FactorProvider'GOOGLE
  "SYMANTEC" -> P.Right FactorProvider'SYMANTEC
  "DUO" -> P.Right FactorProvider'DUO
  "YUBICO" -> P.Right FactorProvider'YUBICO
  "CUSTOM" -> P.Right FactorProvider'CUSTOM
  "APPLE" -> P.Right FactorProvider'APPLE
  s -> P.Left $ "toFactorProvider: enum parse failure: " P.++ P.show s


-- ** FactorResultType

-- | Enum of 'Text'
data FactorResultType
  = FactorResultType'SUCCESS -- ^ @"SUCCESS"@
  | FactorResultType'CHALLENGE -- ^ @"CHALLENGE"@
  | FactorResultType'WAITING -- ^ @"WAITING"@
  | FactorResultType'FAILED -- ^ @"FAILED"@
  | FactorResultType'REJECTED -- ^ @"REJECTED"@
  | FactorResultType'TIMEOUT -- ^ @"TIMEOUT"@
  | FactorResultType'TIME_WINDOW_EXCEEDED -- ^ @"TIME_WINDOW_EXCEEDED"@
  | FactorResultType'PASSCODE_REPLAYED -- ^ @"PASSCODE_REPLAYED"@
  | FactorResultType'ERROR -- ^ @"ERROR"@
  | FactorResultType'CANCELLED -- ^ @"CANCELLED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorResultType where toJSON = A.toJSON . fromFactorResultType
instance A.FromJSON FactorResultType where parseJSON o = P.either P.fail (pure . P.id) . toFactorResultType =<< A.parseJSON o
instance WH.ToHttpApiData FactorResultType where toQueryParam = WH.toQueryParam . fromFactorResultType
instance WH.FromHttpApiData FactorResultType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorResultType
instance MimeRender MimeMultipartFormData FactorResultType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorResultType' enum
fromFactorResultType :: FactorResultType -> Text
fromFactorResultType = \case
  FactorResultType'SUCCESS -> "SUCCESS"
  FactorResultType'CHALLENGE -> "CHALLENGE"
  FactorResultType'WAITING -> "WAITING"
  FactorResultType'FAILED -> "FAILED"
  FactorResultType'REJECTED -> "REJECTED"
  FactorResultType'TIMEOUT -> "TIMEOUT"
  FactorResultType'TIME_WINDOW_EXCEEDED -> "TIME_WINDOW_EXCEEDED"
  FactorResultType'PASSCODE_REPLAYED -> "PASSCODE_REPLAYED"
  FactorResultType'ERROR -> "ERROR"
  FactorResultType'CANCELLED -> "CANCELLED"

-- | parse 'FactorResultType' enum
toFactorResultType :: Text -> P.Either String FactorResultType
toFactorResultType = \case
  "SUCCESS" -> P.Right FactorResultType'SUCCESS
  "CHALLENGE" -> P.Right FactorResultType'CHALLENGE
  "WAITING" -> P.Right FactorResultType'WAITING
  "FAILED" -> P.Right FactorResultType'FAILED
  "REJECTED" -> P.Right FactorResultType'REJECTED
  "TIMEOUT" -> P.Right FactorResultType'TIMEOUT
  "TIME_WINDOW_EXCEEDED" -> P.Right FactorResultType'TIME_WINDOW_EXCEEDED
  "PASSCODE_REPLAYED" -> P.Right FactorResultType'PASSCODE_REPLAYED
  "ERROR" -> P.Right FactorResultType'ERROR
  "CANCELLED" -> P.Right FactorResultType'CANCELLED
  s -> P.Left $ "toFactorResultType: enum parse failure: " P.++ P.show s


-- ** FactorStatus

-- | Enum of 'Text'
data FactorStatus
  = FactorStatus'PENDING_ACTIVATION -- ^ @"PENDING_ACTIVATION"@
  | FactorStatus'ACTIVE -- ^ @"ACTIVE"@
  | FactorStatus'INACTIVE -- ^ @"INACTIVE"@
  | FactorStatus'NOT_SETUP -- ^ @"NOT_SETUP"@
  | FactorStatus'ENROLLED -- ^ @"ENROLLED"@
  | FactorStatus'DISABLED -- ^ @"DISABLED"@
  | FactorStatus'EXPIRED -- ^ @"EXPIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorStatus where toJSON = A.toJSON . fromFactorStatus
instance A.FromJSON FactorStatus where parseJSON o = P.either P.fail (pure . P.id) . toFactorStatus =<< A.parseJSON o
instance WH.ToHttpApiData FactorStatus where toQueryParam = WH.toQueryParam . fromFactorStatus
instance WH.FromHttpApiData FactorStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorStatus
instance MimeRender MimeMultipartFormData FactorStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorStatus' enum
fromFactorStatus :: FactorStatus -> Text
fromFactorStatus = \case
  FactorStatus'PENDING_ACTIVATION -> "PENDING_ACTIVATION"
  FactorStatus'ACTIVE -> "ACTIVE"
  FactorStatus'INACTIVE -> "INACTIVE"
  FactorStatus'NOT_SETUP -> "NOT_SETUP"
  FactorStatus'ENROLLED -> "ENROLLED"
  FactorStatus'DISABLED -> "DISABLED"
  FactorStatus'EXPIRED -> "EXPIRED"

-- | parse 'FactorStatus' enum
toFactorStatus :: Text -> P.Either String FactorStatus
toFactorStatus = \case
  "PENDING_ACTIVATION" -> P.Right FactorStatus'PENDING_ACTIVATION
  "ACTIVE" -> P.Right FactorStatus'ACTIVE
  "INACTIVE" -> P.Right FactorStatus'INACTIVE
  "NOT_SETUP" -> P.Right FactorStatus'NOT_SETUP
  "ENROLLED" -> P.Right FactorStatus'ENROLLED
  "DISABLED" -> P.Right FactorStatus'DISABLED
  "EXPIRED" -> P.Right FactorStatus'EXPIRED
  s -> P.Left $ "toFactorStatus: enum parse failure: " P.++ P.show s


-- ** FactorType

-- | Enum of 'Text'
data FactorType
  = FactorType'Call -- ^ @"call"@
  | FactorType'Email -- ^ @"email"@
  | FactorType'Hotp -- ^ @"hotp"@
  | FactorType'Push -- ^ @"push"@
  | FactorType'Question -- ^ @"question"@
  | FactorType'Sms -- ^ @"sms"@
  | FactorType'Tokenhardware -- ^ @"token:hardware"@
  | FactorType'Tokenhotp -- ^ @"token:hotp"@
  | FactorType'Tokensoftwaretotp -- ^ @"token:software:totp"@
  | FactorType'Token -- ^ @"token"@
  | FactorType'U2f -- ^ @"u2f"@
  | FactorType'Web -- ^ @"web"@
  | FactorType'Webauthn -- ^ @"webauthn"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorType where toJSON = A.toJSON . fromFactorType
instance A.FromJSON FactorType where parseJSON o = P.either P.fail (pure . P.id) . toFactorType =<< A.parseJSON o
instance WH.ToHttpApiData FactorType where toQueryParam = WH.toQueryParam . fromFactorType
instance WH.FromHttpApiData FactorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorType
instance MimeRender MimeMultipartFormData FactorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorType' enum
fromFactorType :: FactorType -> Text
fromFactorType = \case
  FactorType'Call -> "call"
  FactorType'Email -> "email"
  FactorType'Hotp -> "hotp"
  FactorType'Push -> "push"
  FactorType'Question -> "question"
  FactorType'Sms -> "sms"
  FactorType'Tokenhardware -> "token:hardware"
  FactorType'Tokenhotp -> "token:hotp"
  FactorType'Tokensoftwaretotp -> "token:software:totp"
  FactorType'Token -> "token"
  FactorType'U2f -> "u2f"
  FactorType'Web -> "web"
  FactorType'Webauthn -> "webauthn"

-- | parse 'FactorType' enum
toFactorType :: Text -> P.Either String FactorType
toFactorType = \case
  "call" -> P.Right FactorType'Call
  "email" -> P.Right FactorType'Email
  "hotp" -> P.Right FactorType'Hotp
  "push" -> P.Right FactorType'Push
  "question" -> P.Right FactorType'Question
  "sms" -> P.Right FactorType'Sms
  "token:hardware" -> P.Right FactorType'Tokenhardware
  "token:hotp" -> P.Right FactorType'Tokenhotp
  "token:software:totp" -> P.Right FactorType'Tokensoftwaretotp
  "token" -> P.Right FactorType'Token
  "u2f" -> P.Right FactorType'U2f
  "web" -> P.Right FactorType'Web
  "webauthn" -> P.Right FactorType'Webauthn
  s -> P.Left $ "toFactorType: enum parse failure: " P.++ P.show s


-- ** FeatureStageState

-- | Enum of 'Text'
data FeatureStageState
  = FeatureStageState'OPEN -- ^ @"OPEN"@
  | FeatureStageState'CLOSED -- ^ @"CLOSED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeatureStageState where toJSON = A.toJSON . fromFeatureStageState
instance A.FromJSON FeatureStageState where parseJSON o = P.either P.fail (pure . P.id) . toFeatureStageState =<< A.parseJSON o
instance WH.ToHttpApiData FeatureStageState where toQueryParam = WH.toQueryParam . fromFeatureStageState
instance WH.FromHttpApiData FeatureStageState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeatureStageState
instance MimeRender MimeMultipartFormData FeatureStageState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeatureStageState' enum
fromFeatureStageState :: FeatureStageState -> Text
fromFeatureStageState = \case
  FeatureStageState'OPEN -> "OPEN"
  FeatureStageState'CLOSED -> "CLOSED"

-- | parse 'FeatureStageState' enum
toFeatureStageState :: Text -> P.Either String FeatureStageState
toFeatureStageState = \case
  "OPEN" -> P.Right FeatureStageState'OPEN
  "CLOSED" -> P.Right FeatureStageState'CLOSED
  s -> P.Left $ "toFeatureStageState: enum parse failure: " P.++ P.show s


-- ** FeatureStageValue

-- | Enum of 'Text'
data FeatureStageValue
  = FeatureStageValue'EA -- ^ @"EA"@
  | FeatureStageValue'BETA -- ^ @"BETA"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeatureStageValue where toJSON = A.toJSON . fromFeatureStageValue
instance A.FromJSON FeatureStageValue where parseJSON o = P.either P.fail (pure . P.id) . toFeatureStageValue =<< A.parseJSON o
instance WH.ToHttpApiData FeatureStageValue where toQueryParam = WH.toQueryParam . fromFeatureStageValue
instance WH.FromHttpApiData FeatureStageValue where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeatureStageValue
instance MimeRender MimeMultipartFormData FeatureStageValue where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeatureStageValue' enum
fromFeatureStageValue :: FeatureStageValue -> Text
fromFeatureStageValue = \case
  FeatureStageValue'EA -> "EA"
  FeatureStageValue'BETA -> "BETA"

-- | parse 'FeatureStageValue' enum
toFeatureStageValue :: Text -> P.Either String FeatureStageValue
toFeatureStageValue = \case
  "EA" -> P.Right FeatureStageValue'EA
  "BETA" -> P.Right FeatureStageValue'BETA
  s -> P.Left $ "toFeatureStageValue: enum parse failure: " P.++ P.show s


-- ** FeatureType

-- | Enum of 'Text'
data FeatureType
  = FeatureType'Self_service -- ^ @"self-service"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FeatureType where toJSON = A.toJSON . fromFeatureType
instance A.FromJSON FeatureType where parseJSON o = P.either P.fail (pure . P.id) . toFeatureType =<< A.parseJSON o
instance WH.ToHttpApiData FeatureType where toQueryParam = WH.toQueryParam . fromFeatureType
instance WH.FromHttpApiData FeatureType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFeatureType
instance MimeRender MimeMultipartFormData FeatureType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FeatureType' enum
fromFeatureType :: FeatureType -> Text
fromFeatureType = \case
  FeatureType'Self_service -> "self-service"

-- | parse 'FeatureType' enum
toFeatureType :: Text -> P.Either String FeatureType
toFeatureType = \case
  "self-service" -> P.Right FeatureType'Self_service
  s -> P.Left $ "toFeatureType: enum parse failure: " P.++ P.show s


-- ** FipsEnum

-- | Enum of 'Text'
data FipsEnum
  = FipsEnum'REQUIRED -- ^ @"REQUIRED"@
  | FipsEnum'OPTIONAL -- ^ @"OPTIONAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FipsEnum where toJSON = A.toJSON . fromFipsEnum
instance A.FromJSON FipsEnum where parseJSON o = P.either P.fail (pure . P.id) . toFipsEnum =<< A.parseJSON o
instance WH.ToHttpApiData FipsEnum where toQueryParam = WH.toQueryParam . fromFipsEnum
instance WH.FromHttpApiData FipsEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFipsEnum
instance MimeRender MimeMultipartFormData FipsEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FipsEnum' enum
fromFipsEnum :: FipsEnum -> Text
fromFipsEnum = \case
  FipsEnum'REQUIRED -> "REQUIRED"
  FipsEnum'OPTIONAL -> "OPTIONAL"

-- | parse 'FipsEnum' enum
toFipsEnum :: Text -> P.Either String FipsEnum
toFipsEnum = \case
  "REQUIRED" -> P.Right FipsEnum'REQUIRED
  "OPTIONAL" -> P.Right FipsEnum'OPTIONAL
  s -> P.Left $ "toFipsEnum: enum parse failure: " P.++ P.show s


-- ** GroupRuleStatus

-- | Enum of 'Text'
data GroupRuleStatus
  = GroupRuleStatus'ACTIVE -- ^ @"ACTIVE"@
  | GroupRuleStatus'INACTIVE -- ^ @"INACTIVE"@
  | GroupRuleStatus'INVALID -- ^ @"INVALID"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON GroupRuleStatus where toJSON = A.toJSON . fromGroupRuleStatus
instance A.FromJSON GroupRuleStatus where parseJSON o = P.either P.fail (pure . P.id) . toGroupRuleStatus =<< A.parseJSON o
instance WH.ToHttpApiData GroupRuleStatus where toQueryParam = WH.toQueryParam . fromGroupRuleStatus
instance WH.FromHttpApiData GroupRuleStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toGroupRuleStatus
instance MimeRender MimeMultipartFormData GroupRuleStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'GroupRuleStatus' enum
fromGroupRuleStatus :: GroupRuleStatus -> Text
fromGroupRuleStatus = \case
  GroupRuleStatus'ACTIVE -> "ACTIVE"
  GroupRuleStatus'INACTIVE -> "INACTIVE"
  GroupRuleStatus'INVALID -> "INVALID"

-- | parse 'GroupRuleStatus' enum
toGroupRuleStatus :: Text -> P.Either String GroupRuleStatus
toGroupRuleStatus = \case
  "ACTIVE" -> P.Right GroupRuleStatus'ACTIVE
  "INACTIVE" -> P.Right GroupRuleStatus'INACTIVE
  "INVALID" -> P.Right GroupRuleStatus'INVALID
  s -> P.Left $ "toGroupRuleStatus: enum parse failure: " P.++ P.show s


-- ** GroupType

-- | Enum of 'Text'
data GroupType
  = GroupType'OKTA_GROUP -- ^ @"OKTA_GROUP"@
  | GroupType'APP_GROUP -- ^ @"APP_GROUP"@
  | GroupType'BUILT_IN -- ^ @"BUILT_IN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON GroupType where toJSON = A.toJSON . fromGroupType
instance A.FromJSON GroupType where parseJSON o = P.either P.fail (pure . P.id) . toGroupType =<< A.parseJSON o
instance WH.ToHttpApiData GroupType where toQueryParam = WH.toQueryParam . fromGroupType
instance WH.FromHttpApiData GroupType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toGroupType
instance MimeRender MimeMultipartFormData GroupType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'GroupType' enum
fromGroupType :: GroupType -> Text
fromGroupType = \case
  GroupType'OKTA_GROUP -> "OKTA_GROUP"
  GroupType'APP_GROUP -> "APP_GROUP"
  GroupType'BUILT_IN -> "BUILT_IN"

-- | parse 'GroupType' enum
toGroupType :: Text -> P.Either String GroupType
toGroupType = \case
  "OKTA_GROUP" -> P.Right GroupType'OKTA_GROUP
  "APP_GROUP" -> P.Right GroupType'APP_GROUP
  "BUILT_IN" -> P.Right GroupType'BUILT_IN
  s -> P.Left $ "toGroupType: enum parse failure: " P.++ P.show s


-- ** IframeEmbedScopeAllowedApps

-- | Enum of 'Text'
data IframeEmbedScopeAllowedApps
  = IframeEmbedScopeAllowedApps'OKTA_ENDUSER -- ^ @"OKTA_ENDUSER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON IframeEmbedScopeAllowedApps where toJSON = A.toJSON . fromIframeEmbedScopeAllowedApps
instance A.FromJSON IframeEmbedScopeAllowedApps where parseJSON o = P.either P.fail (pure . P.id) . toIframeEmbedScopeAllowedApps =<< A.parseJSON o
instance WH.ToHttpApiData IframeEmbedScopeAllowedApps where toQueryParam = WH.toQueryParam . fromIframeEmbedScopeAllowedApps
instance WH.FromHttpApiData IframeEmbedScopeAllowedApps where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toIframeEmbedScopeAllowedApps
instance MimeRender MimeMultipartFormData IframeEmbedScopeAllowedApps where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'IframeEmbedScopeAllowedApps' enum
fromIframeEmbedScopeAllowedApps :: IframeEmbedScopeAllowedApps -> Text
fromIframeEmbedScopeAllowedApps = \case
  IframeEmbedScopeAllowedApps'OKTA_ENDUSER -> "OKTA_ENDUSER"

-- | parse 'IframeEmbedScopeAllowedApps' enum
toIframeEmbedScopeAllowedApps :: Text -> P.Either String IframeEmbedScopeAllowedApps
toIframeEmbedScopeAllowedApps = \case
  "OKTA_ENDUSER" -> P.Right IframeEmbedScopeAllowedApps'OKTA_ENDUSER
  s -> P.Left $ "toIframeEmbedScopeAllowedApps: enum parse failure: " P.++ P.show s


-- ** InlineHookStatus

-- | Enum of 'Text'
data InlineHookStatus
  = InlineHookStatus'ACTIVE -- ^ @"ACTIVE"@
  | InlineHookStatus'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON InlineHookStatus where toJSON = A.toJSON . fromInlineHookStatus
instance A.FromJSON InlineHookStatus where parseJSON o = P.either P.fail (pure . P.id) . toInlineHookStatus =<< A.parseJSON o
instance WH.ToHttpApiData InlineHookStatus where toQueryParam = WH.toQueryParam . fromInlineHookStatus
instance WH.FromHttpApiData InlineHookStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toInlineHookStatus
instance MimeRender MimeMultipartFormData InlineHookStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'InlineHookStatus' enum
fromInlineHookStatus :: InlineHookStatus -> Text
fromInlineHookStatus = \case
  InlineHookStatus'ACTIVE -> "ACTIVE"
  InlineHookStatus'INACTIVE -> "INACTIVE"

-- | parse 'InlineHookStatus' enum
toInlineHookStatus :: Text -> P.Either String InlineHookStatus
toInlineHookStatus = \case
  "ACTIVE" -> P.Right InlineHookStatus'ACTIVE
  "INACTIVE" -> P.Right InlineHookStatus'INACTIVE
  s -> P.Left $ "toInlineHookStatus: enum parse failure: " P.++ P.show s


-- ** InlineHookType

-- | Enum of 'Text'
data InlineHookType
  = InlineHookType'Oauth2_tokens_transform -- ^ @"com.okta.oauth2.tokens.transform"@
  | InlineHookType'Import_transform -- ^ @"com.okta.import.transform"@
  | InlineHookType'Saml_tokens_transform -- ^ @"com.okta.saml.tokens.transform"@
  | InlineHookType'User_pre_registration -- ^ @"com.okta.user.pre-registration"@
  | InlineHookType'User_credential_password_import -- ^ @"com.okta.user.credential.password.import"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON InlineHookType where toJSON = A.toJSON . fromInlineHookType
instance A.FromJSON InlineHookType where parseJSON o = P.either P.fail (pure . P.id) . toInlineHookType =<< A.parseJSON o
instance WH.ToHttpApiData InlineHookType where toQueryParam = WH.toQueryParam . fromInlineHookType
instance WH.FromHttpApiData InlineHookType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toInlineHookType
instance MimeRender MimeMultipartFormData InlineHookType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'InlineHookType' enum
fromInlineHookType :: InlineHookType -> Text
fromInlineHookType = \case
  InlineHookType'Oauth2_tokens_transform -> "com.okta.oauth2.tokens.transform"
  InlineHookType'Import_transform -> "com.okta.import.transform"
  InlineHookType'Saml_tokens_transform -> "com.okta.saml.tokens.transform"
  InlineHookType'User_pre_registration -> "com.okta.user.pre-registration"
  InlineHookType'User_credential_password_import -> "com.okta.user.credential.password.import"

-- | parse 'InlineHookType' enum
toInlineHookType :: Text -> P.Either String InlineHookType
toInlineHookType = \case
  "com.okta.oauth2.tokens.transform" -> P.Right InlineHookType'Oauth2_tokens_transform
  "com.okta.import.transform" -> P.Right InlineHookType'Import_transform
  "com.okta.saml.tokens.transform" -> P.Right InlineHookType'Saml_tokens_transform
  "com.okta.user.pre-registration" -> P.Right InlineHookType'User_pre_registration
  "com.okta.user.credential.password.import" -> P.Right InlineHookType'User_credential_password_import
  s -> P.Left $ "toInlineHookType: enum parse failure: " P.++ P.show s


-- ** LinkedObjectDetailsType

-- | Enum of 'Text'
data LinkedObjectDetailsType
  = LinkedObjectDetailsType'USER -- ^ @"USER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LinkedObjectDetailsType where toJSON = A.toJSON . fromLinkedObjectDetailsType
instance A.FromJSON LinkedObjectDetailsType where parseJSON o = P.either P.fail (pure . P.id) . toLinkedObjectDetailsType =<< A.parseJSON o
instance WH.ToHttpApiData LinkedObjectDetailsType where toQueryParam = WH.toQueryParam . fromLinkedObjectDetailsType
instance WH.FromHttpApiData LinkedObjectDetailsType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLinkedObjectDetailsType
instance MimeRender MimeMultipartFormData LinkedObjectDetailsType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LinkedObjectDetailsType' enum
fromLinkedObjectDetailsType :: LinkedObjectDetailsType -> Text
fromLinkedObjectDetailsType = \case
  LinkedObjectDetailsType'USER -> "USER"

-- | parse 'LinkedObjectDetailsType' enum
toLinkedObjectDetailsType :: Text -> P.Either String LinkedObjectDetailsType
toLinkedObjectDetailsType = \case
  "USER" -> P.Right LinkedObjectDetailsType'USER
  s -> P.Left $ "toLinkedObjectDetailsType: enum parse failure: " P.++ P.show s


-- ** LogAuthenticationProvider

-- | Enum of 'Text'
data LogAuthenticationProvider
  = LogAuthenticationProvider'OKTA_AUTHENTICATION_PROVIDER -- ^ @"OKTA_AUTHENTICATION_PROVIDER"@
  | LogAuthenticationProvider'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | LogAuthenticationProvider'LDAP -- ^ @"LDAP"@
  | LogAuthenticationProvider'FEDERATION -- ^ @"FEDERATION"@
  | LogAuthenticationProvider'SOCIAL -- ^ @"SOCIAL"@
  | LogAuthenticationProvider'FACTOR_PROVIDER -- ^ @"FACTOR_PROVIDER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogAuthenticationProvider where toJSON = A.toJSON . fromLogAuthenticationProvider
instance A.FromJSON LogAuthenticationProvider where parseJSON o = P.either P.fail (pure . P.id) . toLogAuthenticationProvider =<< A.parseJSON o
instance WH.ToHttpApiData LogAuthenticationProvider where toQueryParam = WH.toQueryParam . fromLogAuthenticationProvider
instance WH.FromHttpApiData LogAuthenticationProvider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogAuthenticationProvider
instance MimeRender MimeMultipartFormData LogAuthenticationProvider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogAuthenticationProvider' enum
fromLogAuthenticationProvider :: LogAuthenticationProvider -> Text
fromLogAuthenticationProvider = \case
  LogAuthenticationProvider'OKTA_AUTHENTICATION_PROVIDER -> "OKTA_AUTHENTICATION_PROVIDER"
  LogAuthenticationProvider'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  LogAuthenticationProvider'LDAP -> "LDAP"
  LogAuthenticationProvider'FEDERATION -> "FEDERATION"
  LogAuthenticationProvider'SOCIAL -> "SOCIAL"
  LogAuthenticationProvider'FACTOR_PROVIDER -> "FACTOR_PROVIDER"

-- | parse 'LogAuthenticationProvider' enum
toLogAuthenticationProvider :: Text -> P.Either String LogAuthenticationProvider
toLogAuthenticationProvider = \case
  "OKTA_AUTHENTICATION_PROVIDER" -> P.Right LogAuthenticationProvider'OKTA_AUTHENTICATION_PROVIDER
  "ACTIVE_DIRECTORY" -> P.Right LogAuthenticationProvider'ACTIVE_DIRECTORY
  "LDAP" -> P.Right LogAuthenticationProvider'LDAP
  "FEDERATION" -> P.Right LogAuthenticationProvider'FEDERATION
  "SOCIAL" -> P.Right LogAuthenticationProvider'SOCIAL
  "FACTOR_PROVIDER" -> P.Right LogAuthenticationProvider'FACTOR_PROVIDER
  s -> P.Left $ "toLogAuthenticationProvider: enum parse failure: " P.++ P.show s


-- ** LogCredentialProvider

-- | Enum of 'Text'
data LogCredentialProvider
  = LogCredentialProvider'OKTA_AUTHENTICATION_PROVIDER -- ^ @"OKTA_AUTHENTICATION_PROVIDER"@
  | LogCredentialProvider'OKTA_CREDENTIAL_PROVIDER -- ^ @"OKTA_CREDENTIAL_PROVIDER"@
  | LogCredentialProvider'RSA -- ^ @"RSA"@
  | LogCredentialProvider'SYMANTEC -- ^ @"SYMANTEC"@
  | LogCredentialProvider'GOOGLE -- ^ @"GOOGLE"@
  | LogCredentialProvider'DUO -- ^ @"DUO"@
  | LogCredentialProvider'YUBIKEY -- ^ @"YUBIKEY"@
  | LogCredentialProvider'APPLE -- ^ @"APPLE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogCredentialProvider where toJSON = A.toJSON . fromLogCredentialProvider
instance A.FromJSON LogCredentialProvider where parseJSON o = P.either P.fail (pure . P.id) . toLogCredentialProvider =<< A.parseJSON o
instance WH.ToHttpApiData LogCredentialProvider where toQueryParam = WH.toQueryParam . fromLogCredentialProvider
instance WH.FromHttpApiData LogCredentialProvider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogCredentialProvider
instance MimeRender MimeMultipartFormData LogCredentialProvider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogCredentialProvider' enum
fromLogCredentialProvider :: LogCredentialProvider -> Text
fromLogCredentialProvider = \case
  LogCredentialProvider'OKTA_AUTHENTICATION_PROVIDER -> "OKTA_AUTHENTICATION_PROVIDER"
  LogCredentialProvider'OKTA_CREDENTIAL_PROVIDER -> "OKTA_CREDENTIAL_PROVIDER"
  LogCredentialProvider'RSA -> "RSA"
  LogCredentialProvider'SYMANTEC -> "SYMANTEC"
  LogCredentialProvider'GOOGLE -> "GOOGLE"
  LogCredentialProvider'DUO -> "DUO"
  LogCredentialProvider'YUBIKEY -> "YUBIKEY"
  LogCredentialProvider'APPLE -> "APPLE"

-- | parse 'LogCredentialProvider' enum
toLogCredentialProvider :: Text -> P.Either String LogCredentialProvider
toLogCredentialProvider = \case
  "OKTA_AUTHENTICATION_PROVIDER" -> P.Right LogCredentialProvider'OKTA_AUTHENTICATION_PROVIDER
  "OKTA_CREDENTIAL_PROVIDER" -> P.Right LogCredentialProvider'OKTA_CREDENTIAL_PROVIDER
  "RSA" -> P.Right LogCredentialProvider'RSA
  "SYMANTEC" -> P.Right LogCredentialProvider'SYMANTEC
  "GOOGLE" -> P.Right LogCredentialProvider'GOOGLE
  "DUO" -> P.Right LogCredentialProvider'DUO
  "YUBIKEY" -> P.Right LogCredentialProvider'YUBIKEY
  "APPLE" -> P.Right LogCredentialProvider'APPLE
  s -> P.Left $ "toLogCredentialProvider: enum parse failure: " P.++ P.show s


-- ** LogCredentialType

-- | Enum of 'Text'
data LogCredentialType
  = LogCredentialType'OTP -- ^ @"OTP"@
  | LogCredentialType'SMS -- ^ @"SMS"@
  | LogCredentialType'PASSWORD -- ^ @"PASSWORD"@
  | LogCredentialType'ASSERTION -- ^ @"ASSERTION"@
  | LogCredentialType'IWA -- ^ @"IWA"@
  | LogCredentialType'EMAIL -- ^ @"EMAIL"@
  | LogCredentialType'OAUTH2 -- ^ @"OAUTH2"@
  | LogCredentialType'JWT -- ^ @"JWT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogCredentialType where toJSON = A.toJSON . fromLogCredentialType
instance A.FromJSON LogCredentialType where parseJSON o = P.either P.fail (pure . P.id) . toLogCredentialType =<< A.parseJSON o
instance WH.ToHttpApiData LogCredentialType where toQueryParam = WH.toQueryParam . fromLogCredentialType
instance WH.FromHttpApiData LogCredentialType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogCredentialType
instance MimeRender MimeMultipartFormData LogCredentialType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogCredentialType' enum
fromLogCredentialType :: LogCredentialType -> Text
fromLogCredentialType = \case
  LogCredentialType'OTP -> "OTP"
  LogCredentialType'SMS -> "SMS"
  LogCredentialType'PASSWORD -> "PASSWORD"
  LogCredentialType'ASSERTION -> "ASSERTION"
  LogCredentialType'IWA -> "IWA"
  LogCredentialType'EMAIL -> "EMAIL"
  LogCredentialType'OAUTH2 -> "OAUTH2"
  LogCredentialType'JWT -> "JWT"

-- | parse 'LogCredentialType' enum
toLogCredentialType :: Text -> P.Either String LogCredentialType
toLogCredentialType = \case
  "OTP" -> P.Right LogCredentialType'OTP
  "SMS" -> P.Right LogCredentialType'SMS
  "PASSWORD" -> P.Right LogCredentialType'PASSWORD
  "ASSERTION" -> P.Right LogCredentialType'ASSERTION
  "IWA" -> P.Right LogCredentialType'IWA
  "EMAIL" -> P.Right LogCredentialType'EMAIL
  "OAUTH2" -> P.Right LogCredentialType'OAUTH2
  "JWT" -> P.Right LogCredentialType'JWT
  s -> P.Left $ "toLogCredentialType: enum parse failure: " P.++ P.show s


-- ** LogSeverity

-- | Enum of 'Text'
data LogSeverity
  = LogSeverity'DEBUG -- ^ @"DEBUG"@
  | LogSeverity'INFO -- ^ @"INFO"@
  | LogSeverity'WARN -- ^ @"WARN"@
  | LogSeverity'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogSeverity where toJSON = A.toJSON . fromLogSeverity
instance A.FromJSON LogSeverity where parseJSON o = P.either P.fail (pure . P.id) . toLogSeverity =<< A.parseJSON o
instance WH.ToHttpApiData LogSeverity where toQueryParam = WH.toQueryParam . fromLogSeverity
instance WH.FromHttpApiData LogSeverity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogSeverity
instance MimeRender MimeMultipartFormData LogSeverity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogSeverity' enum
fromLogSeverity :: LogSeverity -> Text
fromLogSeverity = \case
  LogSeverity'DEBUG -> "DEBUG"
  LogSeverity'INFO -> "INFO"
  LogSeverity'WARN -> "WARN"
  LogSeverity'ERROR -> "ERROR"

-- | parse 'LogSeverity' enum
toLogSeverity :: Text -> P.Either String LogSeverity
toLogSeverity = \case
  "DEBUG" -> P.Right LogSeverity'DEBUG
  "INFO" -> P.Right LogSeverity'INFO
  "WARN" -> P.Right LogSeverity'WARN
  "ERROR" -> P.Right LogSeverity'ERROR
  s -> P.Left $ "toLogSeverity: enum parse failure: " P.++ P.show s


-- ** NetworkZoneAddressType

-- | Enum of 'Text'
data NetworkZoneAddressType
  = NetworkZoneAddressType'CIDR -- ^ @"CIDR"@
  | NetworkZoneAddressType'RANGE -- ^ @"RANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NetworkZoneAddressType where toJSON = A.toJSON . fromNetworkZoneAddressType
instance A.FromJSON NetworkZoneAddressType where parseJSON o = P.either P.fail (pure . P.id) . toNetworkZoneAddressType =<< A.parseJSON o
instance WH.ToHttpApiData NetworkZoneAddressType where toQueryParam = WH.toQueryParam . fromNetworkZoneAddressType
instance WH.FromHttpApiData NetworkZoneAddressType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNetworkZoneAddressType
instance MimeRender MimeMultipartFormData NetworkZoneAddressType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NetworkZoneAddressType' enum
fromNetworkZoneAddressType :: NetworkZoneAddressType -> Text
fromNetworkZoneAddressType = \case
  NetworkZoneAddressType'CIDR -> "CIDR"
  NetworkZoneAddressType'RANGE -> "RANGE"

-- | parse 'NetworkZoneAddressType' enum
toNetworkZoneAddressType :: Text -> P.Either String NetworkZoneAddressType
toNetworkZoneAddressType = \case
  "CIDR" -> P.Right NetworkZoneAddressType'CIDR
  "RANGE" -> P.Right NetworkZoneAddressType'RANGE
  s -> P.Left $ "toNetworkZoneAddressType: enum parse failure: " P.++ P.show s


-- ** NetworkZoneStatus

-- | Enum of 'Text'
data NetworkZoneStatus
  = NetworkZoneStatus'ACTIVE -- ^ @"ACTIVE"@
  | NetworkZoneStatus'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NetworkZoneStatus where toJSON = A.toJSON . fromNetworkZoneStatus
instance A.FromJSON NetworkZoneStatus where parseJSON o = P.either P.fail (pure . P.id) . toNetworkZoneStatus =<< A.parseJSON o
instance WH.ToHttpApiData NetworkZoneStatus where toQueryParam = WH.toQueryParam . fromNetworkZoneStatus
instance WH.FromHttpApiData NetworkZoneStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNetworkZoneStatus
instance MimeRender MimeMultipartFormData NetworkZoneStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NetworkZoneStatus' enum
fromNetworkZoneStatus :: NetworkZoneStatus -> Text
fromNetworkZoneStatus = \case
  NetworkZoneStatus'ACTIVE -> "ACTIVE"
  NetworkZoneStatus'INACTIVE -> "INACTIVE"

-- | parse 'NetworkZoneStatus' enum
toNetworkZoneStatus :: Text -> P.Either String NetworkZoneStatus
toNetworkZoneStatus = \case
  "ACTIVE" -> P.Right NetworkZoneStatus'ACTIVE
  "INACTIVE" -> P.Right NetworkZoneStatus'INACTIVE
  s -> P.Left $ "toNetworkZoneStatus: enum parse failure: " P.++ P.show s


-- ** NetworkZoneType

-- | Enum of 'Text'
data NetworkZoneType
  = NetworkZoneType'IP -- ^ @"IP"@
  | NetworkZoneType'DYNAMIC -- ^ @"DYNAMIC"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NetworkZoneType where toJSON = A.toJSON . fromNetworkZoneType
instance A.FromJSON NetworkZoneType where parseJSON o = P.either P.fail (pure . P.id) . toNetworkZoneType =<< A.parseJSON o
instance WH.ToHttpApiData NetworkZoneType where toQueryParam = WH.toQueryParam . fromNetworkZoneType
instance WH.FromHttpApiData NetworkZoneType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNetworkZoneType
instance MimeRender MimeMultipartFormData NetworkZoneType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NetworkZoneType' enum
fromNetworkZoneType :: NetworkZoneType -> Text
fromNetworkZoneType = \case
  NetworkZoneType'IP -> "IP"
  NetworkZoneType'DYNAMIC -> "DYNAMIC"

-- | parse 'NetworkZoneType' enum
toNetworkZoneType :: Text -> P.Either String NetworkZoneType
toNetworkZoneType = \case
  "IP" -> P.Right NetworkZoneType'IP
  "DYNAMIC" -> P.Right NetworkZoneType'DYNAMIC
  s -> P.Left $ "toNetworkZoneType: enum parse failure: " P.++ P.show s


-- ** NetworkZoneUsage

-- | Enum of 'Text'
data NetworkZoneUsage
  = NetworkZoneUsage'POLICY -- ^ @"POLICY"@
  | NetworkZoneUsage'BLOCKLIST -- ^ @"BLOCKLIST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NetworkZoneUsage where toJSON = A.toJSON . fromNetworkZoneUsage
instance A.FromJSON NetworkZoneUsage where parseJSON o = P.either P.fail (pure . P.id) . toNetworkZoneUsage =<< A.parseJSON o
instance WH.ToHttpApiData NetworkZoneUsage where toQueryParam = WH.toQueryParam . fromNetworkZoneUsage
instance WH.FromHttpApiData NetworkZoneUsage where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNetworkZoneUsage
instance MimeRender MimeMultipartFormData NetworkZoneUsage where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NetworkZoneUsage' enum
fromNetworkZoneUsage :: NetworkZoneUsage -> Text
fromNetworkZoneUsage = \case
  NetworkZoneUsage'POLICY -> "POLICY"
  NetworkZoneUsage'BLOCKLIST -> "BLOCKLIST"

-- | parse 'NetworkZoneUsage' enum
toNetworkZoneUsage :: Text -> P.Either String NetworkZoneUsage
toNetworkZoneUsage = \case
  "POLICY" -> P.Right NetworkZoneUsage'POLICY
  "BLOCKLIST" -> P.Right NetworkZoneUsage'BLOCKLIST
  s -> P.Left $ "toNetworkZoneUsage: enum parse failure: " P.++ P.show s


-- ** NotificationType

-- | Enum of 'Text'
data NotificationType
  = NotificationType'CONNECTOR_AGENT -- ^ @"CONNECTOR_AGENT"@
  | NotificationType'USER_LOCKED_OUT -- ^ @"USER_LOCKED_OUT"@
  | NotificationType'APP_IMPORT -- ^ @"APP_IMPORT"@
  | NotificationType'LDAP_AGENT -- ^ @"LDAP_AGENT"@
  | NotificationType'AD_AGENT -- ^ @"AD_AGENT"@
  | NotificationType'OKTA_ANNOUNCEMENT -- ^ @"OKTA_ANNOUNCEMENT"@
  | NotificationType'OKTA_ISSUE -- ^ @"OKTA_ISSUE"@
  | NotificationType'OKTA_UPDATE -- ^ @"OKTA_UPDATE"@
  | NotificationType'IWA_AGENT -- ^ @"IWA_AGENT"@
  | NotificationType'USER_DEPROVISION -- ^ @"USER_DEPROVISION"@
  | NotificationType'REPORT_SUSPICIOUS_ACTIVITY -- ^ @"REPORT_SUSPICIOUS_ACTIVITY"@
  | NotificationType'RATELIMIT_NOTIFICATION -- ^ @"RATELIMIT_NOTIFICATION"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NotificationType where toJSON = A.toJSON . fromNotificationType
instance A.FromJSON NotificationType where parseJSON o = P.either P.fail (pure . P.id) . toNotificationType =<< A.parseJSON o
instance WH.ToHttpApiData NotificationType where toQueryParam = WH.toQueryParam . fromNotificationType
instance WH.FromHttpApiData NotificationType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNotificationType
instance MimeRender MimeMultipartFormData NotificationType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NotificationType' enum
fromNotificationType :: NotificationType -> Text
fromNotificationType = \case
  NotificationType'CONNECTOR_AGENT -> "CONNECTOR_AGENT"
  NotificationType'USER_LOCKED_OUT -> "USER_LOCKED_OUT"
  NotificationType'APP_IMPORT -> "APP_IMPORT"
  NotificationType'LDAP_AGENT -> "LDAP_AGENT"
  NotificationType'AD_AGENT -> "AD_AGENT"
  NotificationType'OKTA_ANNOUNCEMENT -> "OKTA_ANNOUNCEMENT"
  NotificationType'OKTA_ISSUE -> "OKTA_ISSUE"
  NotificationType'OKTA_UPDATE -> "OKTA_UPDATE"
  NotificationType'IWA_AGENT -> "IWA_AGENT"
  NotificationType'USER_DEPROVISION -> "USER_DEPROVISION"
  NotificationType'REPORT_SUSPICIOUS_ACTIVITY -> "REPORT_SUSPICIOUS_ACTIVITY"
  NotificationType'RATELIMIT_NOTIFICATION -> "RATELIMIT_NOTIFICATION"

-- | parse 'NotificationType' enum
toNotificationType :: Text -> P.Either String NotificationType
toNotificationType = \case
  "CONNECTOR_AGENT" -> P.Right NotificationType'CONNECTOR_AGENT
  "USER_LOCKED_OUT" -> P.Right NotificationType'USER_LOCKED_OUT
  "APP_IMPORT" -> P.Right NotificationType'APP_IMPORT
  "LDAP_AGENT" -> P.Right NotificationType'LDAP_AGENT
  "AD_AGENT" -> P.Right NotificationType'AD_AGENT
  "OKTA_ANNOUNCEMENT" -> P.Right NotificationType'OKTA_ANNOUNCEMENT
  "OKTA_ISSUE" -> P.Right NotificationType'OKTA_ISSUE
  "OKTA_UPDATE" -> P.Right NotificationType'OKTA_UPDATE
  "IWA_AGENT" -> P.Right NotificationType'IWA_AGENT
  "USER_DEPROVISION" -> P.Right NotificationType'USER_DEPROVISION
  "REPORT_SUSPICIOUS_ACTIVITY" -> P.Right NotificationType'REPORT_SUSPICIOUS_ACTIVITY
  "RATELIMIT_NOTIFICATION" -> P.Right NotificationType'RATELIMIT_NOTIFICATION
  s -> P.Left $ "toNotificationType: enum parse failure: " P.++ P.show s


-- ** OAuth2ScopeConsentGrantSource

-- | Enum of 'Text'
data OAuth2ScopeConsentGrantSource
  = OAuth2ScopeConsentGrantSource'END_USER -- ^ @"END_USER"@
  | OAuth2ScopeConsentGrantSource'ADMIN -- ^ @"ADMIN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuth2ScopeConsentGrantSource where toJSON = A.toJSON . fromOAuth2ScopeConsentGrantSource
instance A.FromJSON OAuth2ScopeConsentGrantSource where parseJSON o = P.either P.fail (pure . P.id) . toOAuth2ScopeConsentGrantSource =<< A.parseJSON o
instance WH.ToHttpApiData OAuth2ScopeConsentGrantSource where toQueryParam = WH.toQueryParam . fromOAuth2ScopeConsentGrantSource
instance WH.FromHttpApiData OAuth2ScopeConsentGrantSource where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuth2ScopeConsentGrantSource
instance MimeRender MimeMultipartFormData OAuth2ScopeConsentGrantSource where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuth2ScopeConsentGrantSource' enum
fromOAuth2ScopeConsentGrantSource :: OAuth2ScopeConsentGrantSource -> Text
fromOAuth2ScopeConsentGrantSource = \case
  OAuth2ScopeConsentGrantSource'END_USER -> "END_USER"
  OAuth2ScopeConsentGrantSource'ADMIN -> "ADMIN"

-- | parse 'OAuth2ScopeConsentGrantSource' enum
toOAuth2ScopeConsentGrantSource :: Text -> P.Either String OAuth2ScopeConsentGrantSource
toOAuth2ScopeConsentGrantSource = \case
  "END_USER" -> P.Right OAuth2ScopeConsentGrantSource'END_USER
  "ADMIN" -> P.Right OAuth2ScopeConsentGrantSource'ADMIN
  s -> P.Left $ "toOAuth2ScopeConsentGrantSource: enum parse failure: " P.++ P.show s


-- ** OAuth2ScopeConsentGrantStatus

-- | Enum of 'Text'
data OAuth2ScopeConsentGrantStatus
  = OAuth2ScopeConsentGrantStatus'ACTIVE -- ^ @"ACTIVE"@
  | OAuth2ScopeConsentGrantStatus'REVOKED -- ^ @"REVOKED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuth2ScopeConsentGrantStatus where toJSON = A.toJSON . fromOAuth2ScopeConsentGrantStatus
instance A.FromJSON OAuth2ScopeConsentGrantStatus where parseJSON o = P.either P.fail (pure . P.id) . toOAuth2ScopeConsentGrantStatus =<< A.parseJSON o
instance WH.ToHttpApiData OAuth2ScopeConsentGrantStatus where toQueryParam = WH.toQueryParam . fromOAuth2ScopeConsentGrantStatus
instance WH.FromHttpApiData OAuth2ScopeConsentGrantStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuth2ScopeConsentGrantStatus
instance MimeRender MimeMultipartFormData OAuth2ScopeConsentGrantStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuth2ScopeConsentGrantStatus' enum
fromOAuth2ScopeConsentGrantStatus :: OAuth2ScopeConsentGrantStatus -> Text
fromOAuth2ScopeConsentGrantStatus = \case
  OAuth2ScopeConsentGrantStatus'ACTIVE -> "ACTIVE"
  OAuth2ScopeConsentGrantStatus'REVOKED -> "REVOKED"

-- | parse 'OAuth2ScopeConsentGrantStatus' enum
toOAuth2ScopeConsentGrantStatus :: Text -> P.Either String OAuth2ScopeConsentGrantStatus
toOAuth2ScopeConsentGrantStatus = \case
  "ACTIVE" -> P.Right OAuth2ScopeConsentGrantStatus'ACTIVE
  "REVOKED" -> P.Right OAuth2ScopeConsentGrantStatus'REVOKED
  s -> P.Left $ "toOAuth2ScopeConsentGrantStatus: enum parse failure: " P.++ P.show s


-- ** OAuthEndpointAuthenticationMethod

-- | Enum of 'Text'
data OAuthEndpointAuthenticationMethod
  = OAuthEndpointAuthenticationMethod'None -- ^ @"none"@
  | OAuthEndpointAuthenticationMethod'Client_secret_post -- ^ @"client_secret_post"@
  | OAuthEndpointAuthenticationMethod'Client_secret_basic -- ^ @"client_secret_basic"@
  | OAuthEndpointAuthenticationMethod'Client_secret_jwt -- ^ @"client_secret_jwt"@
  | OAuthEndpointAuthenticationMethod'Private_key_jwt -- ^ @"private_key_jwt"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuthEndpointAuthenticationMethod where toJSON = A.toJSON . fromOAuthEndpointAuthenticationMethod
instance A.FromJSON OAuthEndpointAuthenticationMethod where parseJSON o = P.either P.fail (pure . P.id) . toOAuthEndpointAuthenticationMethod =<< A.parseJSON o
instance WH.ToHttpApiData OAuthEndpointAuthenticationMethod where toQueryParam = WH.toQueryParam . fromOAuthEndpointAuthenticationMethod
instance WH.FromHttpApiData OAuthEndpointAuthenticationMethod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuthEndpointAuthenticationMethod
instance MimeRender MimeMultipartFormData OAuthEndpointAuthenticationMethod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuthEndpointAuthenticationMethod' enum
fromOAuthEndpointAuthenticationMethod :: OAuthEndpointAuthenticationMethod -> Text
fromOAuthEndpointAuthenticationMethod = \case
  OAuthEndpointAuthenticationMethod'None -> "none"
  OAuthEndpointAuthenticationMethod'Client_secret_post -> "client_secret_post"
  OAuthEndpointAuthenticationMethod'Client_secret_basic -> "client_secret_basic"
  OAuthEndpointAuthenticationMethod'Client_secret_jwt -> "client_secret_jwt"
  OAuthEndpointAuthenticationMethod'Private_key_jwt -> "private_key_jwt"

-- | parse 'OAuthEndpointAuthenticationMethod' enum
toOAuthEndpointAuthenticationMethod :: Text -> P.Either String OAuthEndpointAuthenticationMethod
toOAuthEndpointAuthenticationMethod = \case
  "none" -> P.Right OAuthEndpointAuthenticationMethod'None
  "client_secret_post" -> P.Right OAuthEndpointAuthenticationMethod'Client_secret_post
  "client_secret_basic" -> P.Right OAuthEndpointAuthenticationMethod'Client_secret_basic
  "client_secret_jwt" -> P.Right OAuthEndpointAuthenticationMethod'Client_secret_jwt
  "private_key_jwt" -> P.Right OAuthEndpointAuthenticationMethod'Private_key_jwt
  s -> P.Left $ "toOAuthEndpointAuthenticationMethod: enum parse failure: " P.++ P.show s


-- ** OAuthGrantType

-- | Enum of 'Text'
data OAuthGrantType
  = OAuthGrantType'Authorization_code -- ^ @"authorization_code"@
  | OAuthGrantType'Implicit -- ^ @"implicit"@
  | OAuthGrantType'Password -- ^ @"password"@
  | OAuthGrantType'Refresh_token -- ^ @"refresh_token"@
  | OAuthGrantType'Client_credentials -- ^ @"client_credentials"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuthGrantType where toJSON = A.toJSON . fromOAuthGrantType
instance A.FromJSON OAuthGrantType where parseJSON o = P.either P.fail (pure . P.id) . toOAuthGrantType =<< A.parseJSON o
instance WH.ToHttpApiData OAuthGrantType where toQueryParam = WH.toQueryParam . fromOAuthGrantType
instance WH.FromHttpApiData OAuthGrantType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuthGrantType
instance MimeRender MimeMultipartFormData OAuthGrantType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuthGrantType' enum
fromOAuthGrantType :: OAuthGrantType -> Text
fromOAuthGrantType = \case
  OAuthGrantType'Authorization_code -> "authorization_code"
  OAuthGrantType'Implicit -> "implicit"
  OAuthGrantType'Password -> "password"
  OAuthGrantType'Refresh_token -> "refresh_token"
  OAuthGrantType'Client_credentials -> "client_credentials"

-- | parse 'OAuthGrantType' enum
toOAuthGrantType :: Text -> P.Either String OAuthGrantType
toOAuthGrantType = \case
  "authorization_code" -> P.Right OAuthGrantType'Authorization_code
  "implicit" -> P.Right OAuthGrantType'Implicit
  "password" -> P.Right OAuthGrantType'Password
  "refresh_token" -> P.Right OAuthGrantType'Refresh_token
  "client_credentials" -> P.Right OAuthGrantType'Client_credentials
  s -> P.Left $ "toOAuthGrantType: enum parse failure: " P.++ P.show s


-- ** OAuthResponseType

-- | Enum of 'Text'
data OAuthResponseType
  = OAuthResponseType'Code -- ^ @"code"@
  | OAuthResponseType'Token -- ^ @"token"@
  | OAuthResponseType'Id_token -- ^ @"id_token"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuthResponseType where toJSON = A.toJSON . fromOAuthResponseType
instance A.FromJSON OAuthResponseType where parseJSON o = P.either P.fail (pure . P.id) . toOAuthResponseType =<< A.parseJSON o
instance WH.ToHttpApiData OAuthResponseType where toQueryParam = WH.toQueryParam . fromOAuthResponseType
instance WH.FromHttpApiData OAuthResponseType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuthResponseType
instance MimeRender MimeMultipartFormData OAuthResponseType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuthResponseType' enum
fromOAuthResponseType :: OAuthResponseType -> Text
fromOAuthResponseType = \case
  OAuthResponseType'Code -> "code"
  OAuthResponseType'Token -> "token"
  OAuthResponseType'Id_token -> "id_token"

-- | parse 'OAuthResponseType' enum
toOAuthResponseType :: Text -> P.Either String OAuthResponseType
toOAuthResponseType = \case
  "code" -> P.Right OAuthResponseType'Code
  "token" -> P.Right OAuthResponseType'Token
  "id_token" -> P.Right OAuthResponseType'Id_token
  s -> P.Left $ "toOAuthResponseType: enum parse failure: " P.++ P.show s


-- ** OpenIdConnectApplicationConsentMethod

-- | Enum of 'Text'
data OpenIdConnectApplicationConsentMethod
  = OpenIdConnectApplicationConsentMethod'REQUIRED -- ^ @"REQUIRED"@
  | OpenIdConnectApplicationConsentMethod'TRUSTED -- ^ @"TRUSTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OpenIdConnectApplicationConsentMethod where toJSON = A.toJSON . fromOpenIdConnectApplicationConsentMethod
instance A.FromJSON OpenIdConnectApplicationConsentMethod where parseJSON o = P.either P.fail (pure . P.id) . toOpenIdConnectApplicationConsentMethod =<< A.parseJSON o
instance WH.ToHttpApiData OpenIdConnectApplicationConsentMethod where toQueryParam = WH.toQueryParam . fromOpenIdConnectApplicationConsentMethod
instance WH.FromHttpApiData OpenIdConnectApplicationConsentMethod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOpenIdConnectApplicationConsentMethod
instance MimeRender MimeMultipartFormData OpenIdConnectApplicationConsentMethod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OpenIdConnectApplicationConsentMethod' enum
fromOpenIdConnectApplicationConsentMethod :: OpenIdConnectApplicationConsentMethod -> Text
fromOpenIdConnectApplicationConsentMethod = \case
  OpenIdConnectApplicationConsentMethod'REQUIRED -> "REQUIRED"
  OpenIdConnectApplicationConsentMethod'TRUSTED -> "TRUSTED"

-- | parse 'OpenIdConnectApplicationConsentMethod' enum
toOpenIdConnectApplicationConsentMethod :: Text -> P.Either String OpenIdConnectApplicationConsentMethod
toOpenIdConnectApplicationConsentMethod = \case
  "REQUIRED" -> P.Right OpenIdConnectApplicationConsentMethod'REQUIRED
  "TRUSTED" -> P.Right OpenIdConnectApplicationConsentMethod'TRUSTED
  s -> P.Left $ "toOpenIdConnectApplicationConsentMethod: enum parse failure: " P.++ P.show s


-- ** OpenIdConnectApplicationIssuerMode

-- | Enum of 'Text'
data OpenIdConnectApplicationIssuerMode
  = OpenIdConnectApplicationIssuerMode'CUSTOM_URL -- ^ @"CUSTOM_URL"@
  | OpenIdConnectApplicationIssuerMode'ORG_URL -- ^ @"ORG_URL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OpenIdConnectApplicationIssuerMode where toJSON = A.toJSON . fromOpenIdConnectApplicationIssuerMode
instance A.FromJSON OpenIdConnectApplicationIssuerMode where parseJSON o = P.either P.fail (pure . P.id) . toOpenIdConnectApplicationIssuerMode =<< A.parseJSON o
instance WH.ToHttpApiData OpenIdConnectApplicationIssuerMode where toQueryParam = WH.toQueryParam . fromOpenIdConnectApplicationIssuerMode
instance WH.FromHttpApiData OpenIdConnectApplicationIssuerMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOpenIdConnectApplicationIssuerMode
instance MimeRender MimeMultipartFormData OpenIdConnectApplicationIssuerMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OpenIdConnectApplicationIssuerMode' enum
fromOpenIdConnectApplicationIssuerMode :: OpenIdConnectApplicationIssuerMode -> Text
fromOpenIdConnectApplicationIssuerMode = \case
  OpenIdConnectApplicationIssuerMode'CUSTOM_URL -> "CUSTOM_URL"
  OpenIdConnectApplicationIssuerMode'ORG_URL -> "ORG_URL"

-- | parse 'OpenIdConnectApplicationIssuerMode' enum
toOpenIdConnectApplicationIssuerMode :: Text -> P.Either String OpenIdConnectApplicationIssuerMode
toOpenIdConnectApplicationIssuerMode = \case
  "CUSTOM_URL" -> P.Right OpenIdConnectApplicationIssuerMode'CUSTOM_URL
  "ORG_URL" -> P.Right OpenIdConnectApplicationIssuerMode'ORG_URL
  s -> P.Left $ "toOpenIdConnectApplicationIssuerMode: enum parse failure: " P.++ P.show s


-- ** OpenIdConnectApplicationType

-- | Enum of 'Text'
data OpenIdConnectApplicationType
  = OpenIdConnectApplicationType'Web -- ^ @"web"@
  | OpenIdConnectApplicationType'Native -- ^ @"native"@
  | OpenIdConnectApplicationType'Browser -- ^ @"browser"@
  | OpenIdConnectApplicationType'Service -- ^ @"service"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OpenIdConnectApplicationType where toJSON = A.toJSON . fromOpenIdConnectApplicationType
instance A.FromJSON OpenIdConnectApplicationType where parseJSON o = P.either P.fail (pure . P.id) . toOpenIdConnectApplicationType =<< A.parseJSON o
instance WH.ToHttpApiData OpenIdConnectApplicationType where toQueryParam = WH.toQueryParam . fromOpenIdConnectApplicationType
instance WH.FromHttpApiData OpenIdConnectApplicationType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOpenIdConnectApplicationType
instance MimeRender MimeMultipartFormData OpenIdConnectApplicationType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OpenIdConnectApplicationType' enum
fromOpenIdConnectApplicationType :: OpenIdConnectApplicationType -> Text
fromOpenIdConnectApplicationType = \case
  OpenIdConnectApplicationType'Web -> "web"
  OpenIdConnectApplicationType'Native -> "native"
  OpenIdConnectApplicationType'Browser -> "browser"
  OpenIdConnectApplicationType'Service -> "service"

-- | parse 'OpenIdConnectApplicationType' enum
toOpenIdConnectApplicationType :: Text -> P.Either String OpenIdConnectApplicationType
toOpenIdConnectApplicationType = \case
  "web" -> P.Right OpenIdConnectApplicationType'Web
  "native" -> P.Right OpenIdConnectApplicationType'Native
  "browser" -> P.Right OpenIdConnectApplicationType'Browser
  "service" -> P.Right OpenIdConnectApplicationType'Service
  s -> P.Left $ "toOpenIdConnectApplicationType: enum parse failure: " P.++ P.show s


-- ** OpenIdConnectRefreshTokenRotationType

-- | Enum of 'Text'
data OpenIdConnectRefreshTokenRotationType
  = OpenIdConnectRefreshTokenRotationType'Rotate -- ^ @"rotate"@
  | OpenIdConnectRefreshTokenRotationType'Static -- ^ @"static"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OpenIdConnectRefreshTokenRotationType where toJSON = A.toJSON . fromOpenIdConnectRefreshTokenRotationType
instance A.FromJSON OpenIdConnectRefreshTokenRotationType where parseJSON o = P.either P.fail (pure . P.id) . toOpenIdConnectRefreshTokenRotationType =<< A.parseJSON o
instance WH.ToHttpApiData OpenIdConnectRefreshTokenRotationType where toQueryParam = WH.toQueryParam . fromOpenIdConnectRefreshTokenRotationType
instance WH.FromHttpApiData OpenIdConnectRefreshTokenRotationType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOpenIdConnectRefreshTokenRotationType
instance MimeRender MimeMultipartFormData OpenIdConnectRefreshTokenRotationType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OpenIdConnectRefreshTokenRotationType' enum
fromOpenIdConnectRefreshTokenRotationType :: OpenIdConnectRefreshTokenRotationType -> Text
fromOpenIdConnectRefreshTokenRotationType = \case
  OpenIdConnectRefreshTokenRotationType'Rotate -> "rotate"
  OpenIdConnectRefreshTokenRotationType'Static -> "static"

-- | parse 'OpenIdConnectRefreshTokenRotationType' enum
toOpenIdConnectRefreshTokenRotationType :: Text -> P.Either String OpenIdConnectRefreshTokenRotationType
toOpenIdConnectRefreshTokenRotationType = \case
  "rotate" -> P.Right OpenIdConnectRefreshTokenRotationType'Rotate
  "static" -> P.Right OpenIdConnectRefreshTokenRotationType'Static
  s -> P.Left $ "toOpenIdConnectRefreshTokenRotationType: enum parse failure: " P.++ P.show s


-- ** OrgContactType

-- | Enum of 'Text'
data OrgContactType
  = OrgContactType'BILLING -- ^ @"BILLING"@
  | OrgContactType'TECHNICAL -- ^ @"TECHNICAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrgContactType where toJSON = A.toJSON . fromOrgContactType
instance A.FromJSON OrgContactType where parseJSON o = P.either P.fail (pure . P.id) . toOrgContactType =<< A.parseJSON o
instance WH.ToHttpApiData OrgContactType where toQueryParam = WH.toQueryParam . fromOrgContactType
instance WH.FromHttpApiData OrgContactType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrgContactType
instance MimeRender MimeMultipartFormData OrgContactType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrgContactType' enum
fromOrgContactType :: OrgContactType -> Text
fromOrgContactType = \case
  OrgContactType'BILLING -> "BILLING"
  OrgContactType'TECHNICAL -> "TECHNICAL"

-- | parse 'OrgContactType' enum
toOrgContactType :: Text -> P.Either String OrgContactType
toOrgContactType = \case
  "BILLING" -> P.Right OrgContactType'BILLING
  "TECHNICAL" -> P.Right OrgContactType'TECHNICAL
  s -> P.Left $ "toOrgContactType: enum parse failure: " P.++ P.show s


-- ** OrgOktaSupportSetting

-- | Enum of 'Text'
data OrgOktaSupportSetting
  = OrgOktaSupportSetting'DISABLED -- ^ @"DISABLED"@
  | OrgOktaSupportSetting'ENABLED -- ^ @"ENABLED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrgOktaSupportSetting where toJSON = A.toJSON . fromOrgOktaSupportSetting
instance A.FromJSON OrgOktaSupportSetting where parseJSON o = P.either P.fail (pure . P.id) . toOrgOktaSupportSetting =<< A.parseJSON o
instance WH.ToHttpApiData OrgOktaSupportSetting where toQueryParam = WH.toQueryParam . fromOrgOktaSupportSetting
instance WH.FromHttpApiData OrgOktaSupportSetting where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrgOktaSupportSetting
instance MimeRender MimeMultipartFormData OrgOktaSupportSetting where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrgOktaSupportSetting' enum
fromOrgOktaSupportSetting :: OrgOktaSupportSetting -> Text
fromOrgOktaSupportSetting = \case
  OrgOktaSupportSetting'DISABLED -> "DISABLED"
  OrgOktaSupportSetting'ENABLED -> "ENABLED"

-- | parse 'OrgOktaSupportSetting' enum
toOrgOktaSupportSetting :: Text -> P.Either String OrgOktaSupportSetting
toOrgOktaSupportSetting = \case
  "DISABLED" -> P.Right OrgOktaSupportSetting'DISABLED
  "ENABLED" -> P.Right OrgOktaSupportSetting'ENABLED
  s -> P.Left $ "toOrgOktaSupportSetting: enum parse failure: " P.++ P.show s


-- ** PasswordCredentialHashAlgorithm

-- | Enum of 'Text'
data PasswordCredentialHashAlgorithm
  = PasswordCredentialHashAlgorithm'BCRYPT -- ^ @"BCRYPT"@
  | PasswordCredentialHashAlgorithm'SHA_512 -- ^ @"SHA-512"@
  | PasswordCredentialHashAlgorithm'SHA_256 -- ^ @"SHA-256"@
  | PasswordCredentialHashAlgorithm'SHA_1 -- ^ @"SHA-1"@
  | PasswordCredentialHashAlgorithm'MD5 -- ^ @"MD5"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PasswordCredentialHashAlgorithm where toJSON = A.toJSON . fromPasswordCredentialHashAlgorithm
instance A.FromJSON PasswordCredentialHashAlgorithm where parseJSON o = P.either P.fail (pure . P.id) . toPasswordCredentialHashAlgorithm =<< A.parseJSON o
instance WH.ToHttpApiData PasswordCredentialHashAlgorithm where toQueryParam = WH.toQueryParam . fromPasswordCredentialHashAlgorithm
instance WH.FromHttpApiData PasswordCredentialHashAlgorithm where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPasswordCredentialHashAlgorithm
instance MimeRender MimeMultipartFormData PasswordCredentialHashAlgorithm where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PasswordCredentialHashAlgorithm' enum
fromPasswordCredentialHashAlgorithm :: PasswordCredentialHashAlgorithm -> Text
fromPasswordCredentialHashAlgorithm = \case
  PasswordCredentialHashAlgorithm'BCRYPT -> "BCRYPT"
  PasswordCredentialHashAlgorithm'SHA_512 -> "SHA-512"
  PasswordCredentialHashAlgorithm'SHA_256 -> "SHA-256"
  PasswordCredentialHashAlgorithm'SHA_1 -> "SHA-1"
  PasswordCredentialHashAlgorithm'MD5 -> "MD5"

-- | parse 'PasswordCredentialHashAlgorithm' enum
toPasswordCredentialHashAlgorithm :: Text -> P.Either String PasswordCredentialHashAlgorithm
toPasswordCredentialHashAlgorithm = \case
  "BCRYPT" -> P.Right PasswordCredentialHashAlgorithm'BCRYPT
  "SHA-512" -> P.Right PasswordCredentialHashAlgorithm'SHA_512
  "SHA-256" -> P.Right PasswordCredentialHashAlgorithm'SHA_256
  "SHA-1" -> P.Right PasswordCredentialHashAlgorithm'SHA_1
  "MD5" -> P.Right PasswordCredentialHashAlgorithm'MD5
  s -> P.Left $ "toPasswordCredentialHashAlgorithm: enum parse failure: " P.++ P.show s


-- ** PolicyRuleActionsEnrollSelf

-- | Enum of 'Text'
data PolicyRuleActionsEnrollSelf
  = PolicyRuleActionsEnrollSelf'CHALLENGE -- ^ @"CHALLENGE"@
  | PolicyRuleActionsEnrollSelf'LOGIN -- ^ @"LOGIN"@
  | PolicyRuleActionsEnrollSelf'NEVER -- ^ @"NEVER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PolicyRuleActionsEnrollSelf where toJSON = A.toJSON . fromPolicyRuleActionsEnrollSelf
instance A.FromJSON PolicyRuleActionsEnrollSelf where parseJSON o = P.either P.fail (pure . P.id) . toPolicyRuleActionsEnrollSelf =<< A.parseJSON o
instance WH.ToHttpApiData PolicyRuleActionsEnrollSelf where toQueryParam = WH.toQueryParam . fromPolicyRuleActionsEnrollSelf
instance WH.FromHttpApiData PolicyRuleActionsEnrollSelf where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPolicyRuleActionsEnrollSelf
instance MimeRender MimeMultipartFormData PolicyRuleActionsEnrollSelf where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PolicyRuleActionsEnrollSelf' enum
fromPolicyRuleActionsEnrollSelf :: PolicyRuleActionsEnrollSelf -> Text
fromPolicyRuleActionsEnrollSelf = \case
  PolicyRuleActionsEnrollSelf'CHALLENGE -> "CHALLENGE"
  PolicyRuleActionsEnrollSelf'LOGIN -> "LOGIN"
  PolicyRuleActionsEnrollSelf'NEVER -> "NEVER"

-- | parse 'PolicyRuleActionsEnrollSelf' enum
toPolicyRuleActionsEnrollSelf :: Text -> P.Either String PolicyRuleActionsEnrollSelf
toPolicyRuleActionsEnrollSelf = \case
  "CHALLENGE" -> P.Right PolicyRuleActionsEnrollSelf'CHALLENGE
  "LOGIN" -> P.Right PolicyRuleActionsEnrollSelf'LOGIN
  "NEVER" -> P.Right PolicyRuleActionsEnrollSelf'NEVER
  s -> P.Left $ "toPolicyRuleActionsEnrollSelf: enum parse failure: " P.++ P.show s


-- ** PolicySubjectMatchType

-- | Enum of 'Text'
data PolicySubjectMatchType
  = PolicySubjectMatchType'USERNAME -- ^ @"USERNAME"@
  | PolicySubjectMatchType'EMAIL -- ^ @"EMAIL"@
  | PolicySubjectMatchType'USERNAME_OR_EMAIL -- ^ @"USERNAME_OR_EMAIL"@
  | PolicySubjectMatchType'CUSTOM_ATTRIBUTE -- ^ @"CUSTOM_ATTRIBUTE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PolicySubjectMatchType where toJSON = A.toJSON . fromPolicySubjectMatchType
instance A.FromJSON PolicySubjectMatchType where parseJSON o = P.either P.fail (pure . P.id) . toPolicySubjectMatchType =<< A.parseJSON o
instance WH.ToHttpApiData PolicySubjectMatchType where toQueryParam = WH.toQueryParam . fromPolicySubjectMatchType
instance WH.FromHttpApiData PolicySubjectMatchType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPolicySubjectMatchType
instance MimeRender MimeMultipartFormData PolicySubjectMatchType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PolicySubjectMatchType' enum
fromPolicySubjectMatchType :: PolicySubjectMatchType -> Text
fromPolicySubjectMatchType = \case
  PolicySubjectMatchType'USERNAME -> "USERNAME"
  PolicySubjectMatchType'EMAIL -> "EMAIL"
  PolicySubjectMatchType'USERNAME_OR_EMAIL -> "USERNAME_OR_EMAIL"
  PolicySubjectMatchType'CUSTOM_ATTRIBUTE -> "CUSTOM_ATTRIBUTE"

-- | parse 'PolicySubjectMatchType' enum
toPolicySubjectMatchType :: Text -> P.Either String PolicySubjectMatchType
toPolicySubjectMatchType = \case
  "USERNAME" -> P.Right PolicySubjectMatchType'USERNAME
  "EMAIL" -> P.Right PolicySubjectMatchType'EMAIL
  "USERNAME_OR_EMAIL" -> P.Right PolicySubjectMatchType'USERNAME_OR_EMAIL
  "CUSTOM_ATTRIBUTE" -> P.Right PolicySubjectMatchType'CUSTOM_ATTRIBUTE
  s -> P.Left $ "toPolicySubjectMatchType: enum parse failure: " P.++ P.show s


-- ** PolicyType

-- | Enum of 'Text'
data PolicyType
  = PolicyType'OAUTH_AUTHORIZATION_POLICY -- ^ @"OAUTH_AUTHORIZATION_POLICY"@
  | PolicyType'OKTA_SIGN_ON -- ^ @"OKTA_SIGN_ON"@
  | PolicyType'PASSWORD -- ^ @"PASSWORD"@
  | PolicyType'IDP_DISCOVERY -- ^ @"IDP_DISCOVERY"@
  | PolicyType'PROFILE_ENROLLMENT -- ^ @"PROFILE_ENROLLMENT"@
  | PolicyType'ACCESS_POLICY -- ^ @"ACCESS_POLICY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON PolicyType where toJSON = A.toJSON . fromPolicyType
instance A.FromJSON PolicyType where parseJSON o = P.either P.fail (pure . P.id) . toPolicyType =<< A.parseJSON o
instance WH.ToHttpApiData PolicyType where toQueryParam = WH.toQueryParam . fromPolicyType
instance WH.FromHttpApiData PolicyType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toPolicyType
instance MimeRender MimeMultipartFormData PolicyType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'PolicyType' enum
fromPolicyType :: PolicyType -> Text
fromPolicyType = \case
  PolicyType'OAUTH_AUTHORIZATION_POLICY -> "OAUTH_AUTHORIZATION_POLICY"
  PolicyType'OKTA_SIGN_ON -> "OKTA_SIGN_ON"
  PolicyType'PASSWORD -> "PASSWORD"
  PolicyType'IDP_DISCOVERY -> "IDP_DISCOVERY"
  PolicyType'PROFILE_ENROLLMENT -> "PROFILE_ENROLLMENT"
  PolicyType'ACCESS_POLICY -> "ACCESS_POLICY"

-- | parse 'PolicyType' enum
toPolicyType :: Text -> P.Either String PolicyType
toPolicyType = \case
  "OAUTH_AUTHORIZATION_POLICY" -> P.Right PolicyType'OAUTH_AUTHORIZATION_POLICY
  "OKTA_SIGN_ON" -> P.Right PolicyType'OKTA_SIGN_ON
  "PASSWORD" -> P.Right PolicyType'PASSWORD
  "IDP_DISCOVERY" -> P.Right PolicyType'IDP_DISCOVERY
  "PROFILE_ENROLLMENT" -> P.Right PolicyType'PROFILE_ENROLLMENT
  "ACCESS_POLICY" -> P.Right PolicyType'ACCESS_POLICY
  s -> P.Left $ "toPolicyType: enum parse failure: " P.++ P.show s


-- ** ProtocolRelayStateFormat

-- | Enum of 'Text'
data ProtocolRelayStateFormat
  = ProtocolRelayStateFormat'OPAQUE -- ^ @"OPAQUE"@
  | ProtocolRelayStateFormat'FROM_URL -- ^ @"FROM_URL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ProtocolRelayStateFormat where toJSON = A.toJSON . fromProtocolRelayStateFormat
instance A.FromJSON ProtocolRelayStateFormat where parseJSON o = P.either P.fail (pure . P.id) . toProtocolRelayStateFormat =<< A.parseJSON o
instance WH.ToHttpApiData ProtocolRelayStateFormat where toQueryParam = WH.toQueryParam . fromProtocolRelayStateFormat
instance WH.FromHttpApiData ProtocolRelayStateFormat where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProtocolRelayStateFormat
instance MimeRender MimeMultipartFormData ProtocolRelayStateFormat where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ProtocolRelayStateFormat' enum
fromProtocolRelayStateFormat :: ProtocolRelayStateFormat -> Text
fromProtocolRelayStateFormat = \case
  ProtocolRelayStateFormat'OPAQUE -> "OPAQUE"
  ProtocolRelayStateFormat'FROM_URL -> "FROM_URL"

-- | parse 'ProtocolRelayStateFormat' enum
toProtocolRelayStateFormat :: Text -> P.Either String ProtocolRelayStateFormat
toProtocolRelayStateFormat = \case
  "OPAQUE" -> P.Right ProtocolRelayStateFormat'OPAQUE
  "FROM_URL" -> P.Right ProtocolRelayStateFormat'FROM_URL
  s -> P.Left $ "toProtocolRelayStateFormat: enum parse failure: " P.++ P.show s


-- ** ProvisioningConnectionAuthScheme

-- | Enum of 'Text'
data ProvisioningConnectionAuthScheme
  = ProvisioningConnectionAuthScheme'TOKEN -- ^ @"TOKEN"@
  | ProvisioningConnectionAuthScheme'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ProvisioningConnectionAuthScheme where toJSON = A.toJSON . fromProvisioningConnectionAuthScheme
instance A.FromJSON ProvisioningConnectionAuthScheme where parseJSON o = P.either P.fail (pure . P.id) . toProvisioningConnectionAuthScheme =<< A.parseJSON o
instance WH.ToHttpApiData ProvisioningConnectionAuthScheme where toQueryParam = WH.toQueryParam . fromProvisioningConnectionAuthScheme
instance WH.FromHttpApiData ProvisioningConnectionAuthScheme where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProvisioningConnectionAuthScheme
instance MimeRender MimeMultipartFormData ProvisioningConnectionAuthScheme where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ProvisioningConnectionAuthScheme' enum
fromProvisioningConnectionAuthScheme :: ProvisioningConnectionAuthScheme -> Text
fromProvisioningConnectionAuthScheme = \case
  ProvisioningConnectionAuthScheme'TOKEN -> "TOKEN"
  ProvisioningConnectionAuthScheme'UNKNOWN -> "UNKNOWN"

-- | parse 'ProvisioningConnectionAuthScheme' enum
toProvisioningConnectionAuthScheme :: Text -> P.Either String ProvisioningConnectionAuthScheme
toProvisioningConnectionAuthScheme = \case
  "TOKEN" -> P.Right ProvisioningConnectionAuthScheme'TOKEN
  "UNKNOWN" -> P.Right ProvisioningConnectionAuthScheme'UNKNOWN
  s -> P.Left $ "toProvisioningConnectionAuthScheme: enum parse failure: " P.++ P.show s


-- ** ProvisioningConnectionStatus

-- | Enum of 'Text'
data ProvisioningConnectionStatus
  = ProvisioningConnectionStatus'DISABLED -- ^ @"DISABLED"@
  | ProvisioningConnectionStatus'ENABLED -- ^ @"ENABLED"@
  | ProvisioningConnectionStatus'UNKNOWN -- ^ @"UNKNOWN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ProvisioningConnectionStatus where toJSON = A.toJSON . fromProvisioningConnectionStatus
instance A.FromJSON ProvisioningConnectionStatus where parseJSON o = P.either P.fail (pure . P.id) . toProvisioningConnectionStatus =<< A.parseJSON o
instance WH.ToHttpApiData ProvisioningConnectionStatus where toQueryParam = WH.toQueryParam . fromProvisioningConnectionStatus
instance WH.FromHttpApiData ProvisioningConnectionStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toProvisioningConnectionStatus
instance MimeRender MimeMultipartFormData ProvisioningConnectionStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ProvisioningConnectionStatus' enum
fromProvisioningConnectionStatus :: ProvisioningConnectionStatus -> Text
fromProvisioningConnectionStatus = \case
  ProvisioningConnectionStatus'DISABLED -> "DISABLED"
  ProvisioningConnectionStatus'ENABLED -> "ENABLED"
  ProvisioningConnectionStatus'UNKNOWN -> "UNKNOWN"

-- | parse 'ProvisioningConnectionStatus' enum
toProvisioningConnectionStatus :: Text -> P.Either String ProvisioningConnectionStatus
toProvisioningConnectionStatus = \case
  "DISABLED" -> P.Right ProvisioningConnectionStatus'DISABLED
  "ENABLED" -> P.Right ProvisioningConnectionStatus'ENABLED
  "UNKNOWN" -> P.Right ProvisioningConnectionStatus'UNKNOWN
  s -> P.Left $ "toProvisioningConnectionStatus: enum parse failure: " P.++ P.show s


-- ** RequiredEnum

-- | Enum of 'Text'
data RequiredEnum
  = RequiredEnum'ALWAYS -- ^ @"ALWAYS"@
  | RequiredEnum'HIGH_RISK_ONLY -- ^ @"HIGH_RISK_ONLY"@
  | RequiredEnum'NEVER -- ^ @"NEVER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequiredEnum where toJSON = A.toJSON . fromRequiredEnum
instance A.FromJSON RequiredEnum where parseJSON o = P.either P.fail (pure . P.id) . toRequiredEnum =<< A.parseJSON o
instance WH.ToHttpApiData RequiredEnum where toQueryParam = WH.toQueryParam . fromRequiredEnum
instance WH.FromHttpApiData RequiredEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequiredEnum
instance MimeRender MimeMultipartFormData RequiredEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequiredEnum' enum
fromRequiredEnum :: RequiredEnum -> Text
fromRequiredEnum = \case
  RequiredEnum'ALWAYS -> "ALWAYS"
  RequiredEnum'HIGH_RISK_ONLY -> "HIGH_RISK_ONLY"
  RequiredEnum'NEVER -> "NEVER"

-- | parse 'RequiredEnum' enum
toRequiredEnum :: Text -> P.Either String RequiredEnum
toRequiredEnum = \case
  "ALWAYS" -> P.Right RequiredEnum'ALWAYS
  "HIGH_RISK_ONLY" -> P.Right RequiredEnum'HIGH_RISK_ONLY
  "NEVER" -> P.Right RequiredEnum'NEVER
  s -> P.Left $ "toRequiredEnum: enum parse failure: " P.++ P.show s


-- ** RoleAssignmentType

-- | Enum of 'Text'
data RoleAssignmentType
  = RoleAssignmentType'GROUP -- ^ @"GROUP"@
  | RoleAssignmentType'USER -- ^ @"USER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RoleAssignmentType where toJSON = A.toJSON . fromRoleAssignmentType
instance A.FromJSON RoleAssignmentType where parseJSON o = P.either P.fail (pure . P.id) . toRoleAssignmentType =<< A.parseJSON o
instance WH.ToHttpApiData RoleAssignmentType where toQueryParam = WH.toQueryParam . fromRoleAssignmentType
instance WH.FromHttpApiData RoleAssignmentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRoleAssignmentType
instance MimeRender MimeMultipartFormData RoleAssignmentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RoleAssignmentType' enum
fromRoleAssignmentType :: RoleAssignmentType -> Text
fromRoleAssignmentType = \case
  RoleAssignmentType'GROUP -> "GROUP"
  RoleAssignmentType'USER -> "USER"

-- | parse 'RoleAssignmentType' enum
toRoleAssignmentType :: Text -> P.Either String RoleAssignmentType
toRoleAssignmentType = \case
  "GROUP" -> P.Right RoleAssignmentType'GROUP
  "USER" -> P.Right RoleAssignmentType'USER
  s -> P.Left $ "toRoleAssignmentType: enum parse failure: " P.++ P.show s


-- ** RoleStatus

-- | Enum of 'Text'
data RoleStatus
  = RoleStatus'ACTIVE -- ^ @"ACTIVE"@
  | RoleStatus'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RoleStatus where toJSON = A.toJSON . fromRoleStatus
instance A.FromJSON RoleStatus where parseJSON o = P.either P.fail (pure . P.id) . toRoleStatus =<< A.parseJSON o
instance WH.ToHttpApiData RoleStatus where toQueryParam = WH.toQueryParam . fromRoleStatus
instance WH.FromHttpApiData RoleStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRoleStatus
instance MimeRender MimeMultipartFormData RoleStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RoleStatus' enum
fromRoleStatus :: RoleStatus -> Text
fromRoleStatus = \case
  RoleStatus'ACTIVE -> "ACTIVE"
  RoleStatus'INACTIVE -> "INACTIVE"

-- | parse 'RoleStatus' enum
toRoleStatus :: Text -> P.Either String RoleStatus
toRoleStatus = \case
  "ACTIVE" -> P.Right RoleStatus'ACTIVE
  "INACTIVE" -> P.Right RoleStatus'INACTIVE
  s -> P.Left $ "toRoleStatus: enum parse failure: " P.++ P.show s


-- ** RoleType

-- | Enum of 'Text'
data RoleType
  = RoleType'SUPER_ADMIN -- ^ @"SUPER_ADMIN"@
  | RoleType'ORG_ADMIN -- ^ @"ORG_ADMIN"@
  | RoleType'APP_ADMIN -- ^ @"APP_ADMIN"@
  | RoleType'USER_ADMIN -- ^ @"USER_ADMIN"@
  | RoleType'HELP_DESK_ADMIN -- ^ @"HELP_DESK_ADMIN"@
  | RoleType'READ_ONLY_ADMIN -- ^ @"READ_ONLY_ADMIN"@
  | RoleType'MOBILE_ADMIN -- ^ @"MOBILE_ADMIN"@
  | RoleType'API_ACCESS_MANAGEMENT_ADMIN -- ^ @"API_ACCESS_MANAGEMENT_ADMIN"@
  | RoleType'REPORT_ADMIN -- ^ @"REPORT_ADMIN"@
  | RoleType'GROUP_MEMBERSHIP_ADMIN -- ^ @"GROUP_MEMBERSHIP_ADMIN"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RoleType where toJSON = A.toJSON . fromRoleType
instance A.FromJSON RoleType where parseJSON o = P.either P.fail (pure . P.id) . toRoleType =<< A.parseJSON o
instance WH.ToHttpApiData RoleType where toQueryParam = WH.toQueryParam . fromRoleType
instance WH.FromHttpApiData RoleType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRoleType
instance MimeRender MimeMultipartFormData RoleType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RoleType' enum
fromRoleType :: RoleType -> Text
fromRoleType = \case
  RoleType'SUPER_ADMIN -> "SUPER_ADMIN"
  RoleType'ORG_ADMIN -> "ORG_ADMIN"
  RoleType'APP_ADMIN -> "APP_ADMIN"
  RoleType'USER_ADMIN -> "USER_ADMIN"
  RoleType'HELP_DESK_ADMIN -> "HELP_DESK_ADMIN"
  RoleType'READ_ONLY_ADMIN -> "READ_ONLY_ADMIN"
  RoleType'MOBILE_ADMIN -> "MOBILE_ADMIN"
  RoleType'API_ACCESS_MANAGEMENT_ADMIN -> "API_ACCESS_MANAGEMENT_ADMIN"
  RoleType'REPORT_ADMIN -> "REPORT_ADMIN"
  RoleType'GROUP_MEMBERSHIP_ADMIN -> "GROUP_MEMBERSHIP_ADMIN"

-- | parse 'RoleType' enum
toRoleType :: Text -> P.Either String RoleType
toRoleType = \case
  "SUPER_ADMIN" -> P.Right RoleType'SUPER_ADMIN
  "ORG_ADMIN" -> P.Right RoleType'ORG_ADMIN
  "APP_ADMIN" -> P.Right RoleType'APP_ADMIN
  "USER_ADMIN" -> P.Right RoleType'USER_ADMIN
  "HELP_DESK_ADMIN" -> P.Right RoleType'HELP_DESK_ADMIN
  "READ_ONLY_ADMIN" -> P.Right RoleType'READ_ONLY_ADMIN
  "MOBILE_ADMIN" -> P.Right RoleType'MOBILE_ADMIN
  "API_ACCESS_MANAGEMENT_ADMIN" -> P.Right RoleType'API_ACCESS_MANAGEMENT_ADMIN
  "REPORT_ADMIN" -> P.Right RoleType'REPORT_ADMIN
  "GROUP_MEMBERSHIP_ADMIN" -> P.Right RoleType'GROUP_MEMBERSHIP_ADMIN
  s -> P.Left $ "toRoleType: enum parse failure: " P.++ P.show s


-- ** ScopeType

-- | Enum of 'Text'
data ScopeType
  = ScopeType'CORS -- ^ @"CORS"@
  | ScopeType'REDIRECT -- ^ @"REDIRECT"@
  | ScopeType'IFRAME_EMBED -- ^ @"IFRAME_EMBED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ScopeType where toJSON = A.toJSON . fromScopeType
instance A.FromJSON ScopeType where parseJSON o = P.either P.fail (pure . P.id) . toScopeType =<< A.parseJSON o
instance WH.ToHttpApiData ScopeType where toQueryParam = WH.toQueryParam . fromScopeType
instance WH.FromHttpApiData ScopeType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toScopeType
instance MimeRender MimeMultipartFormData ScopeType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ScopeType' enum
fromScopeType :: ScopeType -> Text
fromScopeType = \case
  ScopeType'CORS -> "CORS"
  ScopeType'REDIRECT -> "REDIRECT"
  ScopeType'IFRAME_EMBED -> "IFRAME_EMBED"

-- | parse 'ScopeType' enum
toScopeType :: Text -> P.Either String ScopeType
toScopeType = \case
  "CORS" -> P.Right ScopeType'CORS
  "REDIRECT" -> P.Right ScopeType'REDIRECT
  "IFRAME_EMBED" -> P.Right ScopeType'IFRAME_EMBED
  s -> P.Left $ "toScopeType: enum parse failure: " P.++ P.show s


-- ** SeedEnum

-- | Enum of 'Text'
data SeedEnum
  = SeedEnum'OKTA -- ^ @"OKTA"@
  | SeedEnum'RANDOM -- ^ @"RANDOM"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SeedEnum where toJSON = A.toJSON . fromSeedEnum
instance A.FromJSON SeedEnum where parseJSON o = P.either P.fail (pure . P.id) . toSeedEnum =<< A.parseJSON o
instance WH.ToHttpApiData SeedEnum where toQueryParam = WH.toQueryParam . fromSeedEnum
instance WH.FromHttpApiData SeedEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSeedEnum
instance MimeRender MimeMultipartFormData SeedEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SeedEnum' enum
fromSeedEnum :: SeedEnum -> Text
fromSeedEnum = \case
  SeedEnum'OKTA -> "OKTA"
  SeedEnum'RANDOM -> "RANDOM"

-- | parse 'SeedEnum' enum
toSeedEnum :: Text -> P.Either String SeedEnum
toSeedEnum = \case
  "OKTA" -> P.Right SeedEnum'OKTA
  "RANDOM" -> P.Right SeedEnum'RANDOM
  s -> P.Left $ "toSeedEnum: enum parse failure: " P.++ P.show s


-- ** SessionAuthenticationMethod

-- | Enum of 'Text'
data SessionAuthenticationMethod
  = SessionAuthenticationMethod'Pwd -- ^ @"pwd"@
  | SessionAuthenticationMethod'Swk -- ^ @"swk"@
  | SessionAuthenticationMethod'Hwk -- ^ @"hwk"@
  | SessionAuthenticationMethod'Otp -- ^ @"otp"@
  | SessionAuthenticationMethod'Sms -- ^ @"sms"@
  | SessionAuthenticationMethod'Tel -- ^ @"tel"@
  | SessionAuthenticationMethod'Geo -- ^ @"geo"@
  | SessionAuthenticationMethod'Fpt -- ^ @"fpt"@
  | SessionAuthenticationMethod'Kba -- ^ @"kba"@
  | SessionAuthenticationMethod'Mfa -- ^ @"mfa"@
  | SessionAuthenticationMethod'Mca -- ^ @"mca"@
  | SessionAuthenticationMethod'Sc -- ^ @"sc"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SessionAuthenticationMethod where toJSON = A.toJSON . fromSessionAuthenticationMethod
instance A.FromJSON SessionAuthenticationMethod where parseJSON o = P.either P.fail (pure . P.id) . toSessionAuthenticationMethod =<< A.parseJSON o
instance WH.ToHttpApiData SessionAuthenticationMethod where toQueryParam = WH.toQueryParam . fromSessionAuthenticationMethod
instance WH.FromHttpApiData SessionAuthenticationMethod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSessionAuthenticationMethod
instance MimeRender MimeMultipartFormData SessionAuthenticationMethod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SessionAuthenticationMethod' enum
fromSessionAuthenticationMethod :: SessionAuthenticationMethod -> Text
fromSessionAuthenticationMethod = \case
  SessionAuthenticationMethod'Pwd -> "pwd"
  SessionAuthenticationMethod'Swk -> "swk"
  SessionAuthenticationMethod'Hwk -> "hwk"
  SessionAuthenticationMethod'Otp -> "otp"
  SessionAuthenticationMethod'Sms -> "sms"
  SessionAuthenticationMethod'Tel -> "tel"
  SessionAuthenticationMethod'Geo -> "geo"
  SessionAuthenticationMethod'Fpt -> "fpt"
  SessionAuthenticationMethod'Kba -> "kba"
  SessionAuthenticationMethod'Mfa -> "mfa"
  SessionAuthenticationMethod'Mca -> "mca"
  SessionAuthenticationMethod'Sc -> "sc"

-- | parse 'SessionAuthenticationMethod' enum
toSessionAuthenticationMethod :: Text -> P.Either String SessionAuthenticationMethod
toSessionAuthenticationMethod = \case
  "pwd" -> P.Right SessionAuthenticationMethod'Pwd
  "swk" -> P.Right SessionAuthenticationMethod'Swk
  "hwk" -> P.Right SessionAuthenticationMethod'Hwk
  "otp" -> P.Right SessionAuthenticationMethod'Otp
  "sms" -> P.Right SessionAuthenticationMethod'Sms
  "tel" -> P.Right SessionAuthenticationMethod'Tel
  "geo" -> P.Right SessionAuthenticationMethod'Geo
  "fpt" -> P.Right SessionAuthenticationMethod'Fpt
  "kba" -> P.Right SessionAuthenticationMethod'Kba
  "mfa" -> P.Right SessionAuthenticationMethod'Mfa
  "mca" -> P.Right SessionAuthenticationMethod'Mca
  "sc" -> P.Right SessionAuthenticationMethod'Sc
  s -> P.Left $ "toSessionAuthenticationMethod: enum parse failure: " P.++ P.show s


-- ** SessionIdentityProviderType

-- | Enum of 'Text'
data SessionIdentityProviderType
  = SessionIdentityProviderType'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | SessionIdentityProviderType'LDAP -- ^ @"LDAP"@
  | SessionIdentityProviderType'OKTA -- ^ @"OKTA"@
  | SessionIdentityProviderType'FEDERATION -- ^ @"FEDERATION"@
  | SessionIdentityProviderType'SOCIAL -- ^ @"SOCIAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SessionIdentityProviderType where toJSON = A.toJSON . fromSessionIdentityProviderType
instance A.FromJSON SessionIdentityProviderType where parseJSON o = P.either P.fail (pure . P.id) . toSessionIdentityProviderType =<< A.parseJSON o
instance WH.ToHttpApiData SessionIdentityProviderType where toQueryParam = WH.toQueryParam . fromSessionIdentityProviderType
instance WH.FromHttpApiData SessionIdentityProviderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSessionIdentityProviderType
instance MimeRender MimeMultipartFormData SessionIdentityProviderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SessionIdentityProviderType' enum
fromSessionIdentityProviderType :: SessionIdentityProviderType -> Text
fromSessionIdentityProviderType = \case
  SessionIdentityProviderType'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  SessionIdentityProviderType'LDAP -> "LDAP"
  SessionIdentityProviderType'OKTA -> "OKTA"
  SessionIdentityProviderType'FEDERATION -> "FEDERATION"
  SessionIdentityProviderType'SOCIAL -> "SOCIAL"

-- | parse 'SessionIdentityProviderType' enum
toSessionIdentityProviderType :: Text -> P.Either String SessionIdentityProviderType
toSessionIdentityProviderType = \case
  "ACTIVE_DIRECTORY" -> P.Right SessionIdentityProviderType'ACTIVE_DIRECTORY
  "LDAP" -> P.Right SessionIdentityProviderType'LDAP
  "OKTA" -> P.Right SessionIdentityProviderType'OKTA
  "FEDERATION" -> P.Right SessionIdentityProviderType'FEDERATION
  "SOCIAL" -> P.Right SessionIdentityProviderType'SOCIAL
  s -> P.Left $ "toSessionIdentityProviderType: enum parse failure: " P.++ P.show s


-- ** SessionStatus

-- | Enum of 'Text'
data SessionStatus
  = SessionStatus'ACTIVE -- ^ @"ACTIVE"@
  | SessionStatus'MFA_ENROLL -- ^ @"MFA_ENROLL"@
  | SessionStatus'MFA_REQUIRED -- ^ @"MFA_REQUIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SessionStatus where toJSON = A.toJSON . fromSessionStatus
instance A.FromJSON SessionStatus where parseJSON o = P.either P.fail (pure . P.id) . toSessionStatus =<< A.parseJSON o
instance WH.ToHttpApiData SessionStatus where toQueryParam = WH.toQueryParam . fromSessionStatus
instance WH.FromHttpApiData SessionStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSessionStatus
instance MimeRender MimeMultipartFormData SessionStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SessionStatus' enum
fromSessionStatus :: SessionStatus -> Text
fromSessionStatus = \case
  SessionStatus'ACTIVE -> "ACTIVE"
  SessionStatus'MFA_ENROLL -> "MFA_ENROLL"
  SessionStatus'MFA_REQUIRED -> "MFA_REQUIRED"

-- | parse 'SessionStatus' enum
toSessionStatus :: Text -> P.Either String SessionStatus
toSessionStatus = \case
  "ACTIVE" -> P.Right SessionStatus'ACTIVE
  "MFA_ENROLL" -> P.Right SessionStatus'MFA_ENROLL
  "MFA_REQUIRED" -> P.Right SessionStatus'MFA_REQUIRED
  s -> P.Left $ "toSessionStatus: enum parse failure: " P.++ P.show s


-- ** SignInPageTouchPointVariant

-- | Enum of 'Text'
data SignInPageTouchPointVariant
  = SignInPageTouchPointVariant'OKTA_DEFAULT -- ^ @"OKTA_DEFAULT"@
  | SignInPageTouchPointVariant'BACKGROUND_SECONDARY_COLOR -- ^ @"BACKGROUND_SECONDARY_COLOR"@
  | SignInPageTouchPointVariant'BACKGROUND_IMAGE -- ^ @"BACKGROUND_IMAGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SignInPageTouchPointVariant where toJSON = A.toJSON . fromSignInPageTouchPointVariant
instance A.FromJSON SignInPageTouchPointVariant where parseJSON o = P.either P.fail (pure . P.id) . toSignInPageTouchPointVariant =<< A.parseJSON o
instance WH.ToHttpApiData SignInPageTouchPointVariant where toQueryParam = WH.toQueryParam . fromSignInPageTouchPointVariant
instance WH.FromHttpApiData SignInPageTouchPointVariant where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSignInPageTouchPointVariant
instance MimeRender MimeMultipartFormData SignInPageTouchPointVariant where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SignInPageTouchPointVariant' enum
fromSignInPageTouchPointVariant :: SignInPageTouchPointVariant -> Text
fromSignInPageTouchPointVariant = \case
  SignInPageTouchPointVariant'OKTA_DEFAULT -> "OKTA_DEFAULT"
  SignInPageTouchPointVariant'BACKGROUND_SECONDARY_COLOR -> "BACKGROUND_SECONDARY_COLOR"
  SignInPageTouchPointVariant'BACKGROUND_IMAGE -> "BACKGROUND_IMAGE"

-- | parse 'SignInPageTouchPointVariant' enum
toSignInPageTouchPointVariant :: Text -> P.Either String SignInPageTouchPointVariant
toSignInPageTouchPointVariant = \case
  "OKTA_DEFAULT" -> P.Right SignInPageTouchPointVariant'OKTA_DEFAULT
  "BACKGROUND_SECONDARY_COLOR" -> P.Right SignInPageTouchPointVariant'BACKGROUND_SECONDARY_COLOR
  "BACKGROUND_IMAGE" -> P.Right SignInPageTouchPointVariant'BACKGROUND_IMAGE
  s -> P.Left $ "toSignInPageTouchPointVariant: enum parse failure: " P.++ P.show s


-- ** SmsTemplateType

-- | Enum of 'Text'
data SmsTemplateType
  = SmsTemplateType'SMS_VERIFY_CODE -- ^ @"SMS_VERIFY_CODE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SmsTemplateType where toJSON = A.toJSON . fromSmsTemplateType
instance A.FromJSON SmsTemplateType where parseJSON o = P.either P.fail (pure . P.id) . toSmsTemplateType =<< A.parseJSON o
instance WH.ToHttpApiData SmsTemplateType where toQueryParam = WH.toQueryParam . fromSmsTemplateType
instance WH.FromHttpApiData SmsTemplateType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSmsTemplateType
instance MimeRender MimeMultipartFormData SmsTemplateType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SmsTemplateType' enum
fromSmsTemplateType :: SmsTemplateType -> Text
fromSmsTemplateType = \case
  SmsTemplateType'SMS_VERIFY_CODE -> "SMS_VERIFY_CODE"

-- | parse 'SmsTemplateType' enum
toSmsTemplateType :: Text -> P.Either String SmsTemplateType
toSmsTemplateType = \case
  "SMS_VERIFY_CODE" -> P.Right SmsTemplateType'SMS_VERIFY_CODE
  s -> P.Left $ "toSmsTemplateType: enum parse failure: " P.++ P.show s


-- ** SubscriptionStatus

-- | Enum of 'Text'
data SubscriptionStatus
  = SubscriptionStatus'Subscribed -- ^ @"subscribed"@
  | SubscriptionStatus'Unsubscribed -- ^ @"unsubscribed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SubscriptionStatus where toJSON = A.toJSON . fromSubscriptionStatus
instance A.FromJSON SubscriptionStatus where parseJSON o = P.either P.fail (pure . P.id) . toSubscriptionStatus =<< A.parseJSON o
instance WH.ToHttpApiData SubscriptionStatus where toQueryParam = WH.toQueryParam . fromSubscriptionStatus
instance WH.FromHttpApiData SubscriptionStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSubscriptionStatus
instance MimeRender MimeMultipartFormData SubscriptionStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SubscriptionStatus' enum
fromSubscriptionStatus :: SubscriptionStatus -> Text
fromSubscriptionStatus = \case
  SubscriptionStatus'Subscribed -> "subscribed"
  SubscriptionStatus'Unsubscribed -> "unsubscribed"

-- | parse 'SubscriptionStatus' enum
toSubscriptionStatus :: Text -> P.Either String SubscriptionStatus
toSubscriptionStatus = \case
  "subscribed" -> P.Right SubscriptionStatus'Subscribed
  "unsubscribed" -> P.Right SubscriptionStatus'Unsubscribed
  s -> P.Left $ "toSubscriptionStatus: enum parse failure: " P.++ P.show s


-- ** UserNextLogin

-- | Enum of 'Text'
data UserNextLogin
  = UserNextLogin'ChangePassword -- ^ @"changePassword"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserNextLogin where toJSON = A.toJSON . fromUserNextLogin
instance A.FromJSON UserNextLogin where parseJSON o = P.either P.fail (pure . P.id) . toUserNextLogin =<< A.parseJSON o
instance WH.ToHttpApiData UserNextLogin where toQueryParam = WH.toQueryParam . fromUserNextLogin
instance WH.FromHttpApiData UserNextLogin where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserNextLogin
instance MimeRender MimeMultipartFormData UserNextLogin where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserNextLogin' enum
fromUserNextLogin :: UserNextLogin -> Text
fromUserNextLogin = \case
  UserNextLogin'ChangePassword -> "changePassword"

-- | parse 'UserNextLogin' enum
toUserNextLogin :: Text -> P.Either String UserNextLogin
toUserNextLogin = \case
  "changePassword" -> P.Right UserNextLogin'ChangePassword
  s -> P.Left $ "toUserNextLogin: enum parse failure: " P.++ P.show s


-- ** UserSchemaAttributeMasterType

-- | Enum of 'Text'
data UserSchemaAttributeMasterType
  = UserSchemaAttributeMasterType'PROFILE_MASTER -- ^ @"PROFILE_MASTER"@
  | UserSchemaAttributeMasterType'OKTA -- ^ @"OKTA"@
  | UserSchemaAttributeMasterType'OVERRIDE -- ^ @"OVERRIDE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserSchemaAttributeMasterType where toJSON = A.toJSON . fromUserSchemaAttributeMasterType
instance A.FromJSON UserSchemaAttributeMasterType where parseJSON o = P.either P.fail (pure . P.id) . toUserSchemaAttributeMasterType =<< A.parseJSON o
instance WH.ToHttpApiData UserSchemaAttributeMasterType where toQueryParam = WH.toQueryParam . fromUserSchemaAttributeMasterType
instance WH.FromHttpApiData UserSchemaAttributeMasterType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserSchemaAttributeMasterType
instance MimeRender MimeMultipartFormData UserSchemaAttributeMasterType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserSchemaAttributeMasterType' enum
fromUserSchemaAttributeMasterType :: UserSchemaAttributeMasterType -> Text
fromUserSchemaAttributeMasterType = \case
  UserSchemaAttributeMasterType'PROFILE_MASTER -> "PROFILE_MASTER"
  UserSchemaAttributeMasterType'OKTA -> "OKTA"
  UserSchemaAttributeMasterType'OVERRIDE -> "OVERRIDE"

-- | parse 'UserSchemaAttributeMasterType' enum
toUserSchemaAttributeMasterType :: Text -> P.Either String UserSchemaAttributeMasterType
toUserSchemaAttributeMasterType = \case
  "PROFILE_MASTER" -> P.Right UserSchemaAttributeMasterType'PROFILE_MASTER
  "OKTA" -> P.Right UserSchemaAttributeMasterType'OKTA
  "OVERRIDE" -> P.Right UserSchemaAttributeMasterType'OVERRIDE
  s -> P.Left $ "toUserSchemaAttributeMasterType: enum parse failure: " P.++ P.show s


-- ** UserSchemaAttributeType

-- | Enum of 'Text'
data UserSchemaAttributeType
  = UserSchemaAttributeType'String -- ^ @"string"@
  | UserSchemaAttributeType'Boolean -- ^ @"boolean"@
  | UserSchemaAttributeType'Number -- ^ @"number"@
  | UserSchemaAttributeType'Integer -- ^ @"integer"@
  | UserSchemaAttributeType'Array -- ^ @"array"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserSchemaAttributeType where toJSON = A.toJSON . fromUserSchemaAttributeType
instance A.FromJSON UserSchemaAttributeType where parseJSON o = P.either P.fail (pure . P.id) . toUserSchemaAttributeType =<< A.parseJSON o
instance WH.ToHttpApiData UserSchemaAttributeType where toQueryParam = WH.toQueryParam . fromUserSchemaAttributeType
instance WH.FromHttpApiData UserSchemaAttributeType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserSchemaAttributeType
instance MimeRender MimeMultipartFormData UserSchemaAttributeType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserSchemaAttributeType' enum
fromUserSchemaAttributeType :: UserSchemaAttributeType -> Text
fromUserSchemaAttributeType = \case
  UserSchemaAttributeType'String -> "string"
  UserSchemaAttributeType'Boolean -> "boolean"
  UserSchemaAttributeType'Number -> "number"
  UserSchemaAttributeType'Integer -> "integer"
  UserSchemaAttributeType'Array -> "array"

-- | parse 'UserSchemaAttributeType' enum
toUserSchemaAttributeType :: Text -> P.Either String UserSchemaAttributeType
toUserSchemaAttributeType = \case
  "string" -> P.Right UserSchemaAttributeType'String
  "boolean" -> P.Right UserSchemaAttributeType'Boolean
  "number" -> P.Right UserSchemaAttributeType'Number
  "integer" -> P.Right UserSchemaAttributeType'Integer
  "array" -> P.Right UserSchemaAttributeType'Array
  s -> P.Left $ "toUserSchemaAttributeType: enum parse failure: " P.++ P.show s


-- ** UserStatus

-- | Enum of 'Text'
data UserStatus
  = UserStatus'ACTIVE -- ^ @"ACTIVE"@
  | UserStatus'DEPROVISIONED -- ^ @"DEPROVISIONED"@
  | UserStatus'LOCKED_OUT -- ^ @"LOCKED_OUT"@
  | UserStatus'PASSWORD_EXPIRED -- ^ @"PASSWORD_EXPIRED"@
  | UserStatus'PROVISIONED -- ^ @"PROVISIONED"@
  | UserStatus'RECOVERY -- ^ @"RECOVERY"@
  | UserStatus'STAGED -- ^ @"STAGED"@
  | UserStatus'SUSPENDED -- ^ @"SUSPENDED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserStatus where toJSON = A.toJSON . fromUserStatus
instance A.FromJSON UserStatus where parseJSON o = P.either P.fail (pure . P.id) . toUserStatus =<< A.parseJSON o
instance WH.ToHttpApiData UserStatus where toQueryParam = WH.toQueryParam . fromUserStatus
instance WH.FromHttpApiData UserStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserStatus
instance MimeRender MimeMultipartFormData UserStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserStatus' enum
fromUserStatus :: UserStatus -> Text
fromUserStatus = \case
  UserStatus'ACTIVE -> "ACTIVE"
  UserStatus'DEPROVISIONED -> "DEPROVISIONED"
  UserStatus'LOCKED_OUT -> "LOCKED_OUT"
  UserStatus'PASSWORD_EXPIRED -> "PASSWORD_EXPIRED"
  UserStatus'PROVISIONED -> "PROVISIONED"
  UserStatus'RECOVERY -> "RECOVERY"
  UserStatus'STAGED -> "STAGED"
  UserStatus'SUSPENDED -> "SUSPENDED"

-- | parse 'UserStatus' enum
toUserStatus :: Text -> P.Either String UserStatus
toUserStatus = \case
  "ACTIVE" -> P.Right UserStatus'ACTIVE
  "DEPROVISIONED" -> P.Right UserStatus'DEPROVISIONED
  "LOCKED_OUT" -> P.Right UserStatus'LOCKED_OUT
  "PASSWORD_EXPIRED" -> P.Right UserStatus'PASSWORD_EXPIRED
  "PROVISIONED" -> P.Right UserStatus'PROVISIONED
  "RECOVERY" -> P.Right UserStatus'RECOVERY
  "STAGED" -> P.Right UserStatus'STAGED
  "SUSPENDED" -> P.Right UserStatus'SUSPENDED
  s -> P.Left $ "toUserStatus: enum parse failure: " P.++ P.show s


-- ** UserVerificationEnum

-- | Enum of 'Text'
data UserVerificationEnum
  = UserVerificationEnum'REQUIRED -- ^ @"REQUIRED"@
  | UserVerificationEnum'PREFERRED -- ^ @"PREFERRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserVerificationEnum where toJSON = A.toJSON . fromUserVerificationEnum
instance A.FromJSON UserVerificationEnum where parseJSON o = P.either P.fail (pure . P.id) . toUserVerificationEnum =<< A.parseJSON o
instance WH.ToHttpApiData UserVerificationEnum where toQueryParam = WH.toQueryParam . fromUserVerificationEnum
instance WH.FromHttpApiData UserVerificationEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserVerificationEnum
instance MimeRender MimeMultipartFormData UserVerificationEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserVerificationEnum' enum
fromUserVerificationEnum :: UserVerificationEnum -> Text
fromUserVerificationEnum = \case
  UserVerificationEnum'REQUIRED -> "REQUIRED"
  UserVerificationEnum'PREFERRED -> "PREFERRED"

-- | parse 'UserVerificationEnum' enum
toUserVerificationEnum :: Text -> P.Either String UserVerificationEnum
toUserVerificationEnum = \case
  "REQUIRED" -> P.Right UserVerificationEnum'REQUIRED
  "PREFERRED" -> P.Right UserVerificationEnum'PREFERRED
  s -> P.Left $ "toUserVerificationEnum: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiToken
data AuthApiKeyApiToken =
  AuthApiKeyApiToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiToken where
  applyAuthMethod _ a@(AuthApiKeyApiToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


