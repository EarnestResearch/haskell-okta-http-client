{-
   Okta API

   Allows customers to easily access the Okta API

   OpenAPI Version: 3.0.1
   Okta API API version: 1.3.0
   Contact: devex-public@okta.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Okta.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Okta.Model where

import Okta.Core
import Okta.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Activate
newtype Activate = Activate { unActivate :: Bool } deriving (P.Eq, P.Show)

-- ** After
newtype After = After { unAfter :: Text } deriving (P.Eq, P.Show)

-- ** AppId
newtype AppId = AppId { unAppId :: Text } deriving (P.Eq, P.Show)

-- ** Expand
newtype Expand = Expand { unExpand :: Text } deriving (P.Eq, P.Show)

-- ** FactorId
newtype FactorId = FactorId { unFactorId :: Text } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** Format
newtype Format = Format { unFormat :: Text } deriving (P.Eq, P.Show)

-- ** GroupId
newtype GroupId = GroupId { unGroupId :: Text } deriving (P.Eq, P.Show)

-- ** IncludeNonDeleted
newtype IncludeNonDeleted = IncludeNonDeleted { unIncludeNonDeleted :: Bool } deriving (P.Eq, P.Show)

-- ** KeyId
newtype KeyId = KeyId { unKeyId :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** ManagedBy
newtype ManagedBy = ManagedBy { unManagedBy :: Text } deriving (P.Eq, P.Show)

-- ** NextLogin
newtype NextLogin = NextLogin { unNextLogin :: Text } deriving (P.Eq, P.Show)

-- ** OauthTokens
newtype OauthTokens = OauthTokens { unOauthTokens :: Bool } deriving (P.Eq, P.Show)

-- ** Provider
newtype Provider = Provider { unProvider :: Bool } deriving (P.Eq, P.Show)

-- ** ProviderText
newtype ProviderText = ProviderText { unProviderText :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** QueryScope
newtype QueryScope = QueryScope { unQueryScope :: Text } deriving (P.Eq, P.Show)

-- ** RemoveUsers
newtype RemoveUsers = RemoveUsers { unRemoveUsers :: Bool } deriving (P.Eq, P.Show)

-- ** RoleId
newtype RoleId = RoleId { unRoleId :: Text } deriving (P.Eq, P.Show)

-- ** RuleId
newtype RuleId = RuleId { unRuleId :: Text } deriving (P.Eq, P.Show)

-- ** Search
newtype Search = Search { unSearch :: Text } deriving (P.Eq, P.Show)

-- ** SendEmail
newtype SendEmail = SendEmail { unSendEmail :: Bool } deriving (P.Eq, P.Show)

-- ** SessionId
newtype SessionId = SessionId { unSessionId :: Text } deriving (P.Eq, P.Show)

-- ** ShowAll
newtype ShowAll = ShowAll { unShowAll :: Bool } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: Text } deriving (P.Eq, P.Show)

-- ** SortOrder
newtype SortOrder = SortOrder { unSortOrder :: Text } deriving (P.Eq, P.Show)

-- ** TargetAid
newtype TargetAid = TargetAid { unTargetAid :: Text } deriving (P.Eq, P.Show)

-- ** TempPassword2
newtype TempPassword2 = TempPassword2 { unTempPassword2 :: Bool } deriving (P.Eq, P.Show)

-- ** TemplateId
newtype TemplateId = TemplateId { unTemplateId :: Text } deriving (P.Eq, P.Show)

-- ** TokenLifetimeSeconds
newtype TokenLifetimeSeconds = TokenLifetimeSeconds { unTokenLifetimeSeconds :: Int } deriving (P.Eq, P.Show)

-- ** Until
newtype Until = Until { unUntil :: Text } deriving (P.Eq, P.Show)

-- ** UpdatePhone
newtype UpdatePhone = UpdatePhone { unUpdatePhone :: Bool } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AppLink
-- | AppLink
data AppLink = AppLink
  { appLinkAppAssignmentId :: !(Maybe Text) -- ^ "appAssignmentId"
  , appLinkAppInstanceId :: !(Maybe Text) -- ^ "appInstanceId"
  , appLinkAppName :: !(Maybe Text) -- ^ "appName"
  , appLinkCredentialsSetup :: !(Maybe Bool) -- ^ "credentialsSetup"
  , appLinkHidden :: !(Maybe Bool) -- ^ "hidden"
  , appLinkId :: !(Maybe Text) -- ^ "id"
  , appLinkLabel :: !(Maybe Text) -- ^ "label"
  , appLinkLinkUrl :: !(Maybe Text) -- ^ "linkUrl"
  , appLinkLogoUrl :: !(Maybe Text) -- ^ "logoUrl"
  , appLinkSortOrder :: !(Maybe Int) -- ^ "sortOrder"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppLink
instance A.FromJSON AppLink where
  parseJSON = A.withObject "AppLink" $ \o ->
    AppLink
      <$> (o .:? "appAssignmentId")
      <*> (o .:? "appInstanceId")
      <*> (o .:? "appName")
      <*> (o .:? "credentialsSetup")
      <*> (o .:? "hidden")
      <*> (o .:? "id")
      <*> (o .:? "label")
      <*> (o .:? "linkUrl")
      <*> (o .:? "logoUrl")
      <*> (o .:? "sortOrder")

-- | ToJSON AppLink
instance A.ToJSON AppLink where
  toJSON AppLink {..} =
   _omitNulls
      [ "appAssignmentId" .= appLinkAppAssignmentId
      , "appInstanceId" .= appLinkAppInstanceId
      , "appName" .= appLinkAppName
      , "credentialsSetup" .= appLinkCredentialsSetup
      , "hidden" .= appLinkHidden
      , "id" .= appLinkId
      , "label" .= appLinkLabel
      , "linkUrl" .= appLinkLinkUrl
      , "logoUrl" .= appLinkLogoUrl
      , "sortOrder" .= appLinkSortOrder
      ]


-- | Construct a value of type 'AppLink' (by applying it's required fields, if any)
mkAppLink
  :: AppLink
mkAppLink =
  AppLink
  { appLinkAppAssignmentId = Nothing
  , appLinkAppInstanceId = Nothing
  , appLinkAppName = Nothing
  , appLinkCredentialsSetup = Nothing
  , appLinkHidden = Nothing
  , appLinkId = Nothing
  , appLinkLabel = Nothing
  , appLinkLinkUrl = Nothing
  , appLinkLogoUrl = Nothing
  , appLinkSortOrder = Nothing
  }

-- ** AppUser
-- | AppUser
data AppUser = AppUser
  { appUserEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , appUserLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , appUserCreated :: !(Maybe DateTime) -- ^ "created"
  , appUserCredentials :: !(Maybe AppUserCredentials) -- ^ "credentials"
  , appUserExternalId :: !(Maybe Text) -- ^ "externalId"
  , appUserId :: !(Maybe Text) -- ^ "id"
  , appUserLastSync :: !(Maybe DateTime) -- ^ "lastSync"
  , appUserLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , appUserPasswordChanged :: !(Maybe DateTime) -- ^ "passwordChanged"
  , appUserProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  , appUserScope :: !(Maybe Text) -- ^ "scope"
  , appUserStatus :: !(Maybe Text) -- ^ "status"
  , appUserStatusChanged :: !(Maybe DateTime) -- ^ "statusChanged"
  , appUserSyncState :: !(Maybe Text) -- ^ "syncState"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppUser
instance A.FromJSON AppUser where
  parseJSON = A.withObject "AppUser" $ \o ->
    AppUser
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "externalId")
      <*> (o .:? "id")
      <*> (o .:? "lastSync")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "passwordChanged")
      <*> (o .:? "profile")
      <*> (o .:? "scope")
      <*> (o .:? "status")
      <*> (o .:? "statusChanged")
      <*> (o .:? "syncState")

-- | ToJSON AppUser
instance A.ToJSON AppUser where
  toJSON AppUser {..} =
   _omitNulls
      [ "_embedded" .= appUserEmbedded
      , "_links" .= appUserLinks
      , "created" .= appUserCreated
      , "credentials" .= appUserCredentials
      , "externalId" .= appUserExternalId
      , "id" .= appUserId
      , "lastSync" .= appUserLastSync
      , "lastUpdated" .= appUserLastUpdated
      , "passwordChanged" .= appUserPasswordChanged
      , "profile" .= appUserProfile
      , "scope" .= appUserScope
      , "status" .= appUserStatus
      , "statusChanged" .= appUserStatusChanged
      , "syncState" .= appUserSyncState
      ]


-- | Construct a value of type 'AppUser' (by applying it's required fields, if any)
mkAppUser
  :: AppUser
mkAppUser =
  AppUser
  { appUserEmbedded = Nothing
  , appUserLinks = Nothing
  , appUserCreated = Nothing
  , appUserCredentials = Nothing
  , appUserExternalId = Nothing
  , appUserId = Nothing
  , appUserLastSync = Nothing
  , appUserLastUpdated = Nothing
  , appUserPasswordChanged = Nothing
  , appUserProfile = Nothing
  , appUserScope = Nothing
  , appUserStatus = Nothing
  , appUserStatusChanged = Nothing
  , appUserSyncState = Nothing
  }

-- ** AppUserCredentials
-- | AppUserCredentials
data AppUserCredentials = AppUserCredentials
  { appUserCredentialsPassword :: !(Maybe AppUserPasswordCredential) -- ^ "password"
  , appUserCredentialsUserName :: !(Maybe Text) -- ^ "userName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppUserCredentials
instance A.FromJSON AppUserCredentials where
  parseJSON = A.withObject "AppUserCredentials" $ \o ->
    AppUserCredentials
      <$> (o .:? "password")
      <*> (o .:? "userName")

-- | ToJSON AppUserCredentials
instance A.ToJSON AppUserCredentials where
  toJSON AppUserCredentials {..} =
   _omitNulls
      [ "password" .= appUserCredentialsPassword
      , "userName" .= appUserCredentialsUserName
      ]


-- | Construct a value of type 'AppUserCredentials' (by applying it's required fields, if any)
mkAppUserCredentials
  :: AppUserCredentials
mkAppUserCredentials =
  AppUserCredentials
  { appUserCredentialsPassword = Nothing
  , appUserCredentialsUserName = Nothing
  }

-- ** AppUserPasswordCredential
-- | AppUserPasswordCredential
data AppUserPasswordCredential = AppUserPasswordCredential
  { appUserPasswordCredentialValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AppUserPasswordCredential
instance A.FromJSON AppUserPasswordCredential where
  parseJSON = A.withObject "AppUserPasswordCredential" $ \o ->
    AppUserPasswordCredential
      <$> (o .:? "value")

-- | ToJSON AppUserPasswordCredential
instance A.ToJSON AppUserPasswordCredential where
  toJSON AppUserPasswordCredential {..} =
   _omitNulls
      [ "value" .= appUserPasswordCredentialValue
      ]


-- | Construct a value of type 'AppUserPasswordCredential' (by applying it's required fields, if any)
mkAppUserPasswordCredential
  :: AppUserPasswordCredential
mkAppUserPasswordCredential =
  AppUserPasswordCredential
  { appUserPasswordCredentialValue = Nothing
  }

-- ** Application
-- | Application
data Application = Application
  { applicationEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , applicationLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , applicationAccessibility :: !(Maybe ApplicationAccessibility) -- ^ "accessibility"
  , applicationCreated :: !(Maybe DateTime) -- ^ "created"
  , applicationCredentials :: !(Maybe ApplicationCredentials) -- ^ "credentials"
  , applicationFeatures :: !(Maybe [Text]) -- ^ "features"
  , applicationId :: !(Maybe Text) -- ^ "id"
  , applicationLabel :: !(Maybe Text) -- ^ "label"
  , applicationLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , applicationLicensing :: !(Maybe ApplicationLicensing) -- ^ "licensing"
  , applicationName :: !(Maybe Text) -- ^ "name"
  , applicationProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  , applicationSettings :: !(Maybe ApplicationSettings) -- ^ "settings"
  , applicationSignOnMode :: !(Maybe ApplicationSignOnMode) -- ^ "signOnMode"
  , applicationStatus :: !(Maybe E'Status) -- ^ "status"
  , applicationVisibility :: !(Maybe ApplicationVisibility) -- ^ "visibility"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Application
instance A.FromJSON Application where
  parseJSON = A.withObject "Application" $ \o ->
    Application
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "accessibility")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "features")
      <*> (o .:? "id")
      <*> (o .:? "label")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "licensing")
      <*> (o .:? "name")
      <*> (o .:? "profile")
      <*> (o .:? "settings")
      <*> (o .:? "signOnMode")
      <*> (o .:? "status")
      <*> (o .:? "visibility")

-- | ToJSON Application
instance A.ToJSON Application where
  toJSON Application {..} =
   _omitNulls
      [ "_embedded" .= applicationEmbedded
      , "_links" .= applicationLinks
      , "accessibility" .= applicationAccessibility
      , "created" .= applicationCreated
      , "credentials" .= applicationCredentials
      , "features" .= applicationFeatures
      , "id" .= applicationId
      , "label" .= applicationLabel
      , "lastUpdated" .= applicationLastUpdated
      , "licensing" .= applicationLicensing
      , "name" .= applicationName
      , "profile" .= applicationProfile
      , "settings" .= applicationSettings
      , "signOnMode" .= applicationSignOnMode
      , "status" .= applicationStatus
      , "visibility" .= applicationVisibility
      ]


-- | Construct a value of type 'Application' (by applying it's required fields, if any)
mkApplication
  :: Application
mkApplication =
  Application
  { applicationEmbedded = Nothing
  , applicationLinks = Nothing
  , applicationAccessibility = Nothing
  , applicationCreated = Nothing
  , applicationCredentials = Nothing
  , applicationFeatures = Nothing
  , applicationId = Nothing
  , applicationLabel = Nothing
  , applicationLastUpdated = Nothing
  , applicationLicensing = Nothing
  , applicationName = Nothing
  , applicationProfile = Nothing
  , applicationSettings = Nothing
  , applicationSignOnMode = Nothing
  , applicationStatus = Nothing
  , applicationVisibility = Nothing
  }

-- ** ApplicationAccessibility
-- | ApplicationAccessibility
data ApplicationAccessibility = ApplicationAccessibility
  { applicationAccessibilityErrorRedirectUrl :: !(Maybe Text) -- ^ "errorRedirectUrl"
  , applicationAccessibilityLoginRedirectUrl :: !(Maybe Text) -- ^ "loginRedirectUrl"
  , applicationAccessibilitySelfService :: !(Maybe Bool) -- ^ "selfService"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationAccessibility
instance A.FromJSON ApplicationAccessibility where
  parseJSON = A.withObject "ApplicationAccessibility" $ \o ->
    ApplicationAccessibility
      <$> (o .:? "errorRedirectUrl")
      <*> (o .:? "loginRedirectUrl")
      <*> (o .:? "selfService")

-- | ToJSON ApplicationAccessibility
instance A.ToJSON ApplicationAccessibility where
  toJSON ApplicationAccessibility {..} =
   _omitNulls
      [ "errorRedirectUrl" .= applicationAccessibilityErrorRedirectUrl
      , "loginRedirectUrl" .= applicationAccessibilityLoginRedirectUrl
      , "selfService" .= applicationAccessibilitySelfService
      ]


-- | Construct a value of type 'ApplicationAccessibility' (by applying it's required fields, if any)
mkApplicationAccessibility
  :: ApplicationAccessibility
mkApplicationAccessibility =
  ApplicationAccessibility
  { applicationAccessibilityErrorRedirectUrl = Nothing
  , applicationAccessibilityLoginRedirectUrl = Nothing
  , applicationAccessibilitySelfService = Nothing
  }

-- ** ApplicationCredentials
-- | ApplicationCredentials
data ApplicationCredentials = ApplicationCredentials
  { applicationCredentialsSigning :: !(Maybe ApplicationCredentialsSigning) -- ^ "signing"
  , applicationCredentialsUserNameTemplate :: !(Maybe ApplicationCredentialsUsernameTemplate) -- ^ "userNameTemplate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentials
instance A.FromJSON ApplicationCredentials where
  parseJSON = A.withObject "ApplicationCredentials" $ \o ->
    ApplicationCredentials
      <$> (o .:? "signing")
      <*> (o .:? "userNameTemplate")

-- | ToJSON ApplicationCredentials
instance A.ToJSON ApplicationCredentials where
  toJSON ApplicationCredentials {..} =
   _omitNulls
      [ "signing" .= applicationCredentialsSigning
      , "userNameTemplate" .= applicationCredentialsUserNameTemplate
      ]


-- | Construct a value of type 'ApplicationCredentials' (by applying it's required fields, if any)
mkApplicationCredentials
  :: ApplicationCredentials
mkApplicationCredentials =
  ApplicationCredentials
  { applicationCredentialsSigning = Nothing
  , applicationCredentialsUserNameTemplate = Nothing
  }

-- ** ApplicationCredentialsOAuthClient
-- | ApplicationCredentialsOAuthClient
data ApplicationCredentialsOAuthClient = ApplicationCredentialsOAuthClient
  { applicationCredentialsOAuthClientAutoKeyRotation :: !(Maybe Bool) -- ^ "autoKeyRotation"
  , applicationCredentialsOAuthClientClientId :: !(Maybe Text) -- ^ "client_id"
  , applicationCredentialsOAuthClientClientSecret :: !(Maybe Text) -- ^ "client_secret"
  , applicationCredentialsOAuthClientTokenEndpointAuthMethod :: !(Maybe OAuthEndpointAuthenticationMethod) -- ^ "token_endpoint_auth_method"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentialsOAuthClient
instance A.FromJSON ApplicationCredentialsOAuthClient where
  parseJSON = A.withObject "ApplicationCredentialsOAuthClient" $ \o ->
    ApplicationCredentialsOAuthClient
      <$> (o .:? "autoKeyRotation")
      <*> (o .:? "client_id")
      <*> (o .:? "client_secret")
      <*> (o .:? "token_endpoint_auth_method")

-- | ToJSON ApplicationCredentialsOAuthClient
instance A.ToJSON ApplicationCredentialsOAuthClient where
  toJSON ApplicationCredentialsOAuthClient {..} =
   _omitNulls
      [ "autoKeyRotation" .= applicationCredentialsOAuthClientAutoKeyRotation
      , "client_id" .= applicationCredentialsOAuthClientClientId
      , "client_secret" .= applicationCredentialsOAuthClientClientSecret
      , "token_endpoint_auth_method" .= applicationCredentialsOAuthClientTokenEndpointAuthMethod
      ]


-- | Construct a value of type 'ApplicationCredentialsOAuthClient' (by applying it's required fields, if any)
mkApplicationCredentialsOAuthClient
  :: ApplicationCredentialsOAuthClient
mkApplicationCredentialsOAuthClient =
  ApplicationCredentialsOAuthClient
  { applicationCredentialsOAuthClientAutoKeyRotation = Nothing
  , applicationCredentialsOAuthClientClientId = Nothing
  , applicationCredentialsOAuthClientClientSecret = Nothing
  , applicationCredentialsOAuthClientTokenEndpointAuthMethod = Nothing
  }

-- ** ApplicationCredentialsSigning
-- | ApplicationCredentialsSigning
data ApplicationCredentialsSigning = ApplicationCredentialsSigning
  { applicationCredentialsSigningKid :: !(Maybe Text) -- ^ "kid"
  , applicationCredentialsSigningLastRotated :: !(Maybe DateTime) -- ^ "lastRotated"
  , applicationCredentialsSigningNextRotation :: !(Maybe DateTime) -- ^ "nextRotation"
  , applicationCredentialsSigningRotationMode :: !(Maybe Text) -- ^ "rotationMode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentialsSigning
instance A.FromJSON ApplicationCredentialsSigning where
  parseJSON = A.withObject "ApplicationCredentialsSigning" $ \o ->
    ApplicationCredentialsSigning
      <$> (o .:? "kid")
      <*> (o .:? "lastRotated")
      <*> (o .:? "nextRotation")
      <*> (o .:? "rotationMode")

-- | ToJSON ApplicationCredentialsSigning
instance A.ToJSON ApplicationCredentialsSigning where
  toJSON ApplicationCredentialsSigning {..} =
   _omitNulls
      [ "kid" .= applicationCredentialsSigningKid
      , "lastRotated" .= applicationCredentialsSigningLastRotated
      , "nextRotation" .= applicationCredentialsSigningNextRotation
      , "rotationMode" .= applicationCredentialsSigningRotationMode
      ]


-- | Construct a value of type 'ApplicationCredentialsSigning' (by applying it's required fields, if any)
mkApplicationCredentialsSigning
  :: ApplicationCredentialsSigning
mkApplicationCredentialsSigning =
  ApplicationCredentialsSigning
  { applicationCredentialsSigningKid = Nothing
  , applicationCredentialsSigningLastRotated = Nothing
  , applicationCredentialsSigningNextRotation = Nothing
  , applicationCredentialsSigningRotationMode = Nothing
  }

-- ** ApplicationCredentialsUsernameTemplate
-- | ApplicationCredentialsUsernameTemplate
data ApplicationCredentialsUsernameTemplate = ApplicationCredentialsUsernameTemplate
  { applicationCredentialsUsernameTemplateSuffix :: !(Maybe Text) -- ^ "suffix"
  , applicationCredentialsUsernameTemplateTemplate :: !(Maybe Text) -- ^ "template"
  , applicationCredentialsUsernameTemplateType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationCredentialsUsernameTemplate
instance A.FromJSON ApplicationCredentialsUsernameTemplate where
  parseJSON = A.withObject "ApplicationCredentialsUsernameTemplate" $ \o ->
    ApplicationCredentialsUsernameTemplate
      <$> (o .:? "suffix")
      <*> (o .:? "template")
      <*> (o .:? "type")

-- | ToJSON ApplicationCredentialsUsernameTemplate
instance A.ToJSON ApplicationCredentialsUsernameTemplate where
  toJSON ApplicationCredentialsUsernameTemplate {..} =
   _omitNulls
      [ "suffix" .= applicationCredentialsUsernameTemplateSuffix
      , "template" .= applicationCredentialsUsernameTemplateTemplate
      , "type" .= applicationCredentialsUsernameTemplateType
      ]


-- | Construct a value of type 'ApplicationCredentialsUsernameTemplate' (by applying it's required fields, if any)
mkApplicationCredentialsUsernameTemplate
  :: ApplicationCredentialsUsernameTemplate
mkApplicationCredentialsUsernameTemplate =
  ApplicationCredentialsUsernameTemplate
  { applicationCredentialsUsernameTemplateSuffix = Nothing
  , applicationCredentialsUsernameTemplateTemplate = Nothing
  , applicationCredentialsUsernameTemplateType = Nothing
  }

-- ** ApplicationGroupAssignment
-- | ApplicationGroupAssignment
data ApplicationGroupAssignment = ApplicationGroupAssignment
  { applicationGroupAssignmentEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , applicationGroupAssignmentLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , applicationGroupAssignmentId :: !(Maybe Text) -- ^ "id"
  , applicationGroupAssignmentLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , applicationGroupAssignmentPriority :: !(Maybe Int) -- ^ "priority"
  , applicationGroupAssignmentProfile :: !(Maybe (Map.Map String A.Value)) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationGroupAssignment
instance A.FromJSON ApplicationGroupAssignment where
  parseJSON = A.withObject "ApplicationGroupAssignment" $ \o ->
    ApplicationGroupAssignment
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "priority")
      <*> (o .:? "profile")

-- | ToJSON ApplicationGroupAssignment
instance A.ToJSON ApplicationGroupAssignment where
  toJSON ApplicationGroupAssignment {..} =
   _omitNulls
      [ "_embedded" .= applicationGroupAssignmentEmbedded
      , "_links" .= applicationGroupAssignmentLinks
      , "id" .= applicationGroupAssignmentId
      , "lastUpdated" .= applicationGroupAssignmentLastUpdated
      , "priority" .= applicationGroupAssignmentPriority
      , "profile" .= applicationGroupAssignmentProfile
      ]


-- | Construct a value of type 'ApplicationGroupAssignment' (by applying it's required fields, if any)
mkApplicationGroupAssignment
  :: ApplicationGroupAssignment
mkApplicationGroupAssignment =
  ApplicationGroupAssignment
  { applicationGroupAssignmentEmbedded = Nothing
  , applicationGroupAssignmentLinks = Nothing
  , applicationGroupAssignmentId = Nothing
  , applicationGroupAssignmentLastUpdated = Nothing
  , applicationGroupAssignmentPriority = Nothing
  , applicationGroupAssignmentProfile = Nothing
  }

-- ** ApplicationLicensing
-- | ApplicationLicensing
data ApplicationLicensing = ApplicationLicensing
  { applicationLicensingSeatCount :: !(Maybe Int) -- ^ "seatCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationLicensing
instance A.FromJSON ApplicationLicensing where
  parseJSON = A.withObject "ApplicationLicensing" $ \o ->
    ApplicationLicensing
      <$> (o .:? "seatCount")

-- | ToJSON ApplicationLicensing
instance A.ToJSON ApplicationLicensing where
  toJSON ApplicationLicensing {..} =
   _omitNulls
      [ "seatCount" .= applicationLicensingSeatCount
      ]


-- | Construct a value of type 'ApplicationLicensing' (by applying it's required fields, if any)
mkApplicationLicensing
  :: ApplicationLicensing
mkApplicationLicensing =
  ApplicationLicensing
  { applicationLicensingSeatCount = Nothing
  }

-- ** ApplicationSettings
-- | ApplicationSettings
data ApplicationSettings = ApplicationSettings
  { applicationSettingsApp :: !(Maybe A.Value) -- ^ "app"
  , applicationSettingsImplicitAssignment :: !(Maybe Bool) -- ^ "implicitAssignment"
  , applicationSettingsNotifications :: !(Maybe ApplicationSettingsNotifications) -- ^ "notifications"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettings
instance A.FromJSON ApplicationSettings where
  parseJSON = A.withObject "ApplicationSettings" $ \o ->
    ApplicationSettings
      <$> (o .:? "app")
      <*> (o .:? "implicitAssignment")
      <*> (o .:? "notifications")

-- | ToJSON ApplicationSettings
instance A.ToJSON ApplicationSettings where
  toJSON ApplicationSettings {..} =
   _omitNulls
      [ "app" .= applicationSettingsApp
      , "implicitAssignment" .= applicationSettingsImplicitAssignment
      , "notifications" .= applicationSettingsNotifications
      ]


-- | Construct a value of type 'ApplicationSettings' (by applying it's required fields, if any)
mkApplicationSettings
  :: ApplicationSettings
mkApplicationSettings =
  ApplicationSettings
  { applicationSettingsApp = Nothing
  , applicationSettingsImplicitAssignment = Nothing
  , applicationSettingsNotifications = Nothing
  }

-- ** ApplicationSettingsNotifications
-- | ApplicationSettingsNotifications
data ApplicationSettingsNotifications = ApplicationSettingsNotifications
  { applicationSettingsNotificationsVpn :: !(Maybe ApplicationSettingsNotificationsVpn) -- ^ "vpn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotifications
instance A.FromJSON ApplicationSettingsNotifications where
  parseJSON = A.withObject "ApplicationSettingsNotifications" $ \o ->
    ApplicationSettingsNotifications
      <$> (o .:? "vpn")

-- | ToJSON ApplicationSettingsNotifications
instance A.ToJSON ApplicationSettingsNotifications where
  toJSON ApplicationSettingsNotifications {..} =
   _omitNulls
      [ "vpn" .= applicationSettingsNotificationsVpn
      ]


-- | Construct a value of type 'ApplicationSettingsNotifications' (by applying it's required fields, if any)
mkApplicationSettingsNotifications
  :: ApplicationSettingsNotifications
mkApplicationSettingsNotifications =
  ApplicationSettingsNotifications
  { applicationSettingsNotificationsVpn = Nothing
  }

-- ** ApplicationSettingsNotificationsVpn
-- | ApplicationSettingsNotificationsVpn
data ApplicationSettingsNotificationsVpn = ApplicationSettingsNotificationsVpn
  { applicationSettingsNotificationsVpnHelpUrl :: !(Maybe Text) -- ^ "helpUrl"
  , applicationSettingsNotificationsVpnMessage :: !(Maybe Text) -- ^ "message"
  , applicationSettingsNotificationsVpnNetwork :: !(Maybe ApplicationSettingsNotificationsVpnNetwork) -- ^ "network"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotificationsVpn
instance A.FromJSON ApplicationSettingsNotificationsVpn where
  parseJSON = A.withObject "ApplicationSettingsNotificationsVpn" $ \o ->
    ApplicationSettingsNotificationsVpn
      <$> (o .:? "helpUrl")
      <*> (o .:? "message")
      <*> (o .:? "network")

-- | ToJSON ApplicationSettingsNotificationsVpn
instance A.ToJSON ApplicationSettingsNotificationsVpn where
  toJSON ApplicationSettingsNotificationsVpn {..} =
   _omitNulls
      [ "helpUrl" .= applicationSettingsNotificationsVpnHelpUrl
      , "message" .= applicationSettingsNotificationsVpnMessage
      , "network" .= applicationSettingsNotificationsVpnNetwork
      ]


-- | Construct a value of type 'ApplicationSettingsNotificationsVpn' (by applying it's required fields, if any)
mkApplicationSettingsNotificationsVpn
  :: ApplicationSettingsNotificationsVpn
mkApplicationSettingsNotificationsVpn =
  ApplicationSettingsNotificationsVpn
  { applicationSettingsNotificationsVpnHelpUrl = Nothing
  , applicationSettingsNotificationsVpnMessage = Nothing
  , applicationSettingsNotificationsVpnNetwork = Nothing
  }

-- ** ApplicationSettingsNotificationsVpnNetwork
-- | ApplicationSettingsNotificationsVpnNetwork
data ApplicationSettingsNotificationsVpnNetwork = ApplicationSettingsNotificationsVpnNetwork
  { applicationSettingsNotificationsVpnNetworkConnection :: !(Maybe Text) -- ^ "connection"
  , applicationSettingsNotificationsVpnNetworkExclude :: !(Maybe [Text]) -- ^ "exclude"
  , applicationSettingsNotificationsVpnNetworkInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationSettingsNotificationsVpnNetwork
instance A.FromJSON ApplicationSettingsNotificationsVpnNetwork where
  parseJSON = A.withObject "ApplicationSettingsNotificationsVpnNetwork" $ \o ->
    ApplicationSettingsNotificationsVpnNetwork
      <$> (o .:? "connection")
      <*> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON ApplicationSettingsNotificationsVpnNetwork
instance A.ToJSON ApplicationSettingsNotificationsVpnNetwork where
  toJSON ApplicationSettingsNotificationsVpnNetwork {..} =
   _omitNulls
      [ "connection" .= applicationSettingsNotificationsVpnNetworkConnection
      , "exclude" .= applicationSettingsNotificationsVpnNetworkExclude
      , "include" .= applicationSettingsNotificationsVpnNetworkInclude
      ]


-- | Construct a value of type 'ApplicationSettingsNotificationsVpnNetwork' (by applying it's required fields, if any)
mkApplicationSettingsNotificationsVpnNetwork
  :: ApplicationSettingsNotificationsVpnNetwork
mkApplicationSettingsNotificationsVpnNetwork =
  ApplicationSettingsNotificationsVpnNetwork
  { applicationSettingsNotificationsVpnNetworkConnection = Nothing
  , applicationSettingsNotificationsVpnNetworkExclude = Nothing
  , applicationSettingsNotificationsVpnNetworkInclude = Nothing
  }

-- ** ApplicationVisibility
-- | ApplicationVisibility
data ApplicationVisibility = ApplicationVisibility
  { applicationVisibilityAppLinks :: !(Maybe (Map.Map String Bool)) -- ^ "appLinks"
  , applicationVisibilityAutoSubmitToolbar :: !(Maybe Bool) -- ^ "autoSubmitToolbar"
  , applicationVisibilityHide :: !(Maybe ApplicationVisibilityHide) -- ^ "hide"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationVisibility
instance A.FromJSON ApplicationVisibility where
  parseJSON = A.withObject "ApplicationVisibility" $ \o ->
    ApplicationVisibility
      <$> (o .:? "appLinks")
      <*> (o .:? "autoSubmitToolbar")
      <*> (o .:? "hide")

-- | ToJSON ApplicationVisibility
instance A.ToJSON ApplicationVisibility where
  toJSON ApplicationVisibility {..} =
   _omitNulls
      [ "appLinks" .= applicationVisibilityAppLinks
      , "autoSubmitToolbar" .= applicationVisibilityAutoSubmitToolbar
      , "hide" .= applicationVisibilityHide
      ]


-- | Construct a value of type 'ApplicationVisibility' (by applying it's required fields, if any)
mkApplicationVisibility
  :: ApplicationVisibility
mkApplicationVisibility =
  ApplicationVisibility
  { applicationVisibilityAppLinks = Nothing
  , applicationVisibilityAutoSubmitToolbar = Nothing
  , applicationVisibilityHide = Nothing
  }

-- ** ApplicationVisibilityHide
-- | ApplicationVisibilityHide
data ApplicationVisibilityHide = ApplicationVisibilityHide
  { applicationVisibilityHideIOs :: !(Maybe Bool) -- ^ "iOS"
  , applicationVisibilityHideWeb :: !(Maybe Bool) -- ^ "web"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApplicationVisibilityHide
instance A.FromJSON ApplicationVisibilityHide where
  parseJSON = A.withObject "ApplicationVisibilityHide" $ \o ->
    ApplicationVisibilityHide
      <$> (o .:? "iOS")
      <*> (o .:? "web")

-- | ToJSON ApplicationVisibilityHide
instance A.ToJSON ApplicationVisibilityHide where
  toJSON ApplicationVisibilityHide {..} =
   _omitNulls
      [ "iOS" .= applicationVisibilityHideIOs
      , "web" .= applicationVisibilityHideWeb
      ]


-- | Construct a value of type 'ApplicationVisibilityHide' (by applying it's required fields, if any)
mkApplicationVisibilityHide
  :: ApplicationVisibilityHide
mkApplicationVisibilityHide =
  ApplicationVisibilityHide
  { applicationVisibilityHideIOs = Nothing
  , applicationVisibilityHideWeb = Nothing
  }

-- ** AuthenticationProvider
-- | AuthenticationProvider
data AuthenticationProvider = AuthenticationProvider
  { authenticationProviderName :: !(Maybe Text) -- ^ "name"
  , authenticationProviderType :: !(Maybe AuthenticationProviderType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthenticationProvider
instance A.FromJSON AuthenticationProvider where
  parseJSON = A.withObject "AuthenticationProvider" $ \o ->
    AuthenticationProvider
      <$> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON AuthenticationProvider
instance A.ToJSON AuthenticationProvider where
  toJSON AuthenticationProvider {..} =
   _omitNulls
      [ "name" .= authenticationProviderName
      , "type" .= authenticationProviderType
      ]


-- | Construct a value of type 'AuthenticationProvider' (by applying it's required fields, if any)
mkAuthenticationProvider
  :: AuthenticationProvider
mkAuthenticationProvider =
  AuthenticationProvider
  { authenticationProviderName = Nothing
  , authenticationProviderType = Nothing
  }

-- ** AutoLoginApplication
-- | AutoLoginApplication
data AutoLoginApplication = AutoLoginApplication
  { autoLoginApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  , autoLoginApplicationSettings :: !(Maybe AutoLoginApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoLoginApplication
instance A.FromJSON AutoLoginApplication where
  parseJSON = A.withObject "AutoLoginApplication" $ \o ->
    AutoLoginApplication
      <$> (o .:? "credentials")
      <*> (o .:? "settings")

-- | ToJSON AutoLoginApplication
instance A.ToJSON AutoLoginApplication where
  toJSON AutoLoginApplication {..} =
   _omitNulls
      [ "credentials" .= autoLoginApplicationCredentials
      , "settings" .= autoLoginApplicationSettings
      ]


-- | Construct a value of type 'AutoLoginApplication' (by applying it's required fields, if any)
mkAutoLoginApplication
  :: AutoLoginApplication
mkAutoLoginApplication =
  AutoLoginApplication
  { autoLoginApplicationCredentials = Nothing
  , autoLoginApplicationSettings = Nothing
  }

-- ** AutoLoginApplicationSettings
-- | AutoLoginApplicationSettings
data AutoLoginApplicationSettings = AutoLoginApplicationSettings
  { autoLoginApplicationSettingsSignOn :: !(Maybe AutoLoginApplicationSettingsSignOn) -- ^ "signOn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoLoginApplicationSettings
instance A.FromJSON AutoLoginApplicationSettings where
  parseJSON = A.withObject "AutoLoginApplicationSettings" $ \o ->
    AutoLoginApplicationSettings
      <$> (o .:? "signOn")

-- | ToJSON AutoLoginApplicationSettings
instance A.ToJSON AutoLoginApplicationSettings where
  toJSON AutoLoginApplicationSettings {..} =
   _omitNulls
      [ "signOn" .= autoLoginApplicationSettingsSignOn
      ]


-- | Construct a value of type 'AutoLoginApplicationSettings' (by applying it's required fields, if any)
mkAutoLoginApplicationSettings
  :: AutoLoginApplicationSettings
mkAutoLoginApplicationSettings =
  AutoLoginApplicationSettings
  { autoLoginApplicationSettingsSignOn = Nothing
  }

-- ** AutoLoginApplicationSettingsSignOn
-- | AutoLoginApplicationSettingsSignOn
data AutoLoginApplicationSettingsSignOn = AutoLoginApplicationSettingsSignOn
  { autoLoginApplicationSettingsSignOnLoginUrl :: !(Maybe Text) -- ^ "loginUrl"
  , autoLoginApplicationSettingsSignOnRedirectUrl :: !(Maybe Text) -- ^ "redirectUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoLoginApplicationSettingsSignOn
instance A.FromJSON AutoLoginApplicationSettingsSignOn where
  parseJSON = A.withObject "AutoLoginApplicationSettingsSignOn" $ \o ->
    AutoLoginApplicationSettingsSignOn
      <$> (o .:? "loginUrl")
      <*> (o .:? "redirectUrl")

-- | ToJSON AutoLoginApplicationSettingsSignOn
instance A.ToJSON AutoLoginApplicationSettingsSignOn where
  toJSON AutoLoginApplicationSettingsSignOn {..} =
   _omitNulls
      [ "loginUrl" .= autoLoginApplicationSettingsSignOnLoginUrl
      , "redirectUrl" .= autoLoginApplicationSettingsSignOnRedirectUrl
      ]


-- | Construct a value of type 'AutoLoginApplicationSettingsSignOn' (by applying it's required fields, if any)
mkAutoLoginApplicationSettingsSignOn
  :: AutoLoginApplicationSettingsSignOn
mkAutoLoginApplicationSettingsSignOn =
  AutoLoginApplicationSettingsSignOn
  { autoLoginApplicationSettingsSignOnLoginUrl = Nothing
  , autoLoginApplicationSettingsSignOnRedirectUrl = Nothing
  }

-- ** BasicApplicationSettings
-- | BasicApplicationSettings
data BasicApplicationSettings = BasicApplicationSettings
  { basicApplicationSettingsApp :: !(Maybe BasicApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicApplicationSettings
instance A.FromJSON BasicApplicationSettings where
  parseJSON = A.withObject "BasicApplicationSettings" $ \o ->
    BasicApplicationSettings
      <$> (o .:? "app")

-- | ToJSON BasicApplicationSettings
instance A.ToJSON BasicApplicationSettings where
  toJSON BasicApplicationSettings {..} =
   _omitNulls
      [ "app" .= basicApplicationSettingsApp
      ]


-- | Construct a value of type 'BasicApplicationSettings' (by applying it's required fields, if any)
mkBasicApplicationSettings
  :: BasicApplicationSettings
mkBasicApplicationSettings =
  BasicApplicationSettings
  { basicApplicationSettingsApp = Nothing
  }

-- ** BasicApplicationSettingsApplication
-- | BasicApplicationSettingsApplication
data BasicApplicationSettingsApplication = BasicApplicationSettingsApplication
  { basicApplicationSettingsApplicationAuthUrl :: !(Maybe Text) -- ^ "authURL"
  , basicApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicApplicationSettingsApplication
instance A.FromJSON BasicApplicationSettingsApplication where
  parseJSON = A.withObject "BasicApplicationSettingsApplication" $ \o ->
    BasicApplicationSettingsApplication
      <$> (o .:? "authURL")
      <*> (o .:? "url")

-- | ToJSON BasicApplicationSettingsApplication
instance A.ToJSON BasicApplicationSettingsApplication where
  toJSON BasicApplicationSettingsApplication {..} =
   _omitNulls
      [ "authURL" .= basicApplicationSettingsApplicationAuthUrl
      , "url" .= basicApplicationSettingsApplicationUrl
      ]


-- | Construct a value of type 'BasicApplicationSettingsApplication' (by applying it's required fields, if any)
mkBasicApplicationSettingsApplication
  :: BasicApplicationSettingsApplication
mkBasicApplicationSettingsApplication =
  BasicApplicationSettingsApplication
  { basicApplicationSettingsApplicationAuthUrl = Nothing
  , basicApplicationSettingsApplicationUrl = Nothing
  }

-- ** BasicAuthApplication
-- | BasicAuthApplication
data BasicAuthApplication = BasicAuthApplication
  { basicAuthApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  , basicAuthApplicationName :: !(Maybe A.Value) -- ^ "name"
  , basicAuthApplicationSettings :: !(Maybe BasicApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicAuthApplication
instance A.FromJSON BasicAuthApplication where
  parseJSON = A.withObject "BasicAuthApplication" $ \o ->
    BasicAuthApplication
      <$> (o .:? "credentials")
      <*> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON BasicAuthApplication
instance A.ToJSON BasicAuthApplication where
  toJSON BasicAuthApplication {..} =
   _omitNulls
      [ "credentials" .= basicAuthApplicationCredentials
      , "name" .= basicAuthApplicationName
      , "settings" .= basicAuthApplicationSettings
      ]


-- | Construct a value of type 'BasicAuthApplication' (by applying it's required fields, if any)
mkBasicAuthApplication
  :: BasicAuthApplication
mkBasicAuthApplication =
  BasicAuthApplication
  { basicAuthApplicationCredentials = Nothing
  , basicAuthApplicationName = Nothing
  , basicAuthApplicationSettings = Nothing
  }

-- ** BookmarkApplication
-- | BookmarkApplication
data BookmarkApplication = BookmarkApplication
  { bookmarkApplicationName :: !(Maybe A.Value) -- ^ "name"
  , bookmarkApplicationSettings :: !(Maybe BookmarkApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BookmarkApplication
instance A.FromJSON BookmarkApplication where
  parseJSON = A.withObject "BookmarkApplication" $ \o ->
    BookmarkApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON BookmarkApplication
instance A.ToJSON BookmarkApplication where
  toJSON BookmarkApplication {..} =
   _omitNulls
      [ "name" .= bookmarkApplicationName
      , "settings" .= bookmarkApplicationSettings
      ]


-- | Construct a value of type 'BookmarkApplication' (by applying it's required fields, if any)
mkBookmarkApplication
  :: BookmarkApplication
mkBookmarkApplication =
  BookmarkApplication
  { bookmarkApplicationName = Nothing
  , bookmarkApplicationSettings = Nothing
  }

-- ** BookmarkApplicationSettings
-- | BookmarkApplicationSettings
data BookmarkApplicationSettings = BookmarkApplicationSettings
  { bookmarkApplicationSettingsApp :: !(Maybe BookmarkApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BookmarkApplicationSettings
instance A.FromJSON BookmarkApplicationSettings where
  parseJSON = A.withObject "BookmarkApplicationSettings" $ \o ->
    BookmarkApplicationSettings
      <$> (o .:? "app")

-- | ToJSON BookmarkApplicationSettings
instance A.ToJSON BookmarkApplicationSettings where
  toJSON BookmarkApplicationSettings {..} =
   _omitNulls
      [ "app" .= bookmarkApplicationSettingsApp
      ]


-- | Construct a value of type 'BookmarkApplicationSettings' (by applying it's required fields, if any)
mkBookmarkApplicationSettings
  :: BookmarkApplicationSettings
mkBookmarkApplicationSettings =
  BookmarkApplicationSettings
  { bookmarkApplicationSettingsApp = Nothing
  }

-- ** BookmarkApplicationSettingsApplication
-- | BookmarkApplicationSettingsApplication
data BookmarkApplicationSettingsApplication = BookmarkApplicationSettingsApplication
  { bookmarkApplicationSettingsApplicationRequestIntegration :: !(Maybe Bool) -- ^ "requestIntegration"
  , bookmarkApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BookmarkApplicationSettingsApplication
instance A.FromJSON BookmarkApplicationSettingsApplication where
  parseJSON = A.withObject "BookmarkApplicationSettingsApplication" $ \o ->
    BookmarkApplicationSettingsApplication
      <$> (o .:? "requestIntegration")
      <*> (o .:? "url")

-- | ToJSON BookmarkApplicationSettingsApplication
instance A.ToJSON BookmarkApplicationSettingsApplication where
  toJSON BookmarkApplicationSettingsApplication {..} =
   _omitNulls
      [ "requestIntegration" .= bookmarkApplicationSettingsApplicationRequestIntegration
      , "url" .= bookmarkApplicationSettingsApplicationUrl
      ]


-- | Construct a value of type 'BookmarkApplicationSettingsApplication' (by applying it's required fields, if any)
mkBookmarkApplicationSettingsApplication
  :: BookmarkApplicationSettingsApplication
mkBookmarkApplicationSettingsApplication =
  BookmarkApplicationSettingsApplication
  { bookmarkApplicationSettingsApplicationRequestIntegration = Nothing
  , bookmarkApplicationSettingsApplicationUrl = Nothing
  }

-- ** BrowserPluginApplication
-- | BrowserPluginApplication
data BrowserPluginApplication = BrowserPluginApplication
  { browserPluginApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BrowserPluginApplication
instance A.FromJSON BrowserPluginApplication where
  parseJSON = A.withObject "BrowserPluginApplication" $ \o ->
    BrowserPluginApplication
      <$> (o .:? "credentials")

-- | ToJSON BrowserPluginApplication
instance A.ToJSON BrowserPluginApplication where
  toJSON BrowserPluginApplication {..} =
   _omitNulls
      [ "credentials" .= browserPluginApplicationCredentials
      ]


-- | Construct a value of type 'BrowserPluginApplication' (by applying it's required fields, if any)
mkBrowserPluginApplication
  :: BrowserPluginApplication
mkBrowserPluginApplication =
  BrowserPluginApplication
  { browserPluginApplicationCredentials = Nothing
  }

-- ** CallFactor
-- | CallFactor
data CallFactor = CallFactor
  { callFactorProfile :: !(Maybe CallFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CallFactor
instance A.FromJSON CallFactor where
  parseJSON = A.withObject "CallFactor" $ \o ->
    CallFactor
      <$> (o .:? "profile")

-- | ToJSON CallFactor
instance A.ToJSON CallFactor where
  toJSON CallFactor {..} =
   _omitNulls
      [ "profile" .= callFactorProfile
      ]


-- | Construct a value of type 'CallFactor' (by applying it's required fields, if any)
mkCallFactor
  :: CallFactor
mkCallFactor =
  CallFactor
  { callFactorProfile = Nothing
  }

-- ** CallFactorProfile
-- | CallFactorProfile
data CallFactorProfile = CallFactorProfile
  { callFactorProfilePhoneExtension :: !(Maybe Text) -- ^ "phoneExtension"
  , callFactorProfilePhoneNumber :: !(Maybe Text) -- ^ "phoneNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CallFactorProfile
instance A.FromJSON CallFactorProfile where
  parseJSON = A.withObject "CallFactorProfile" $ \o ->
    CallFactorProfile
      <$> (o .:? "phoneExtension")
      <*> (o .:? "phoneNumber")

-- | ToJSON CallFactorProfile
instance A.ToJSON CallFactorProfile where
  toJSON CallFactorProfile {..} =
   _omitNulls
      [ "phoneExtension" .= callFactorProfilePhoneExtension
      , "phoneNumber" .= callFactorProfilePhoneNumber
      ]


-- | Construct a value of type 'CallFactorProfile' (by applying it's required fields, if any)
mkCallFactorProfile
  :: CallFactorProfile
mkCallFactorProfile =
  CallFactorProfile
  { callFactorProfilePhoneExtension = Nothing
  , callFactorProfilePhoneNumber = Nothing
  }

-- ** ChangePasswordRequest
-- | ChangePasswordRequest
data ChangePasswordRequest = ChangePasswordRequest
  { changePasswordRequestNewPassword :: !(Maybe PasswordCredential) -- ^ "newPassword"
  , changePasswordRequestOldPassword :: !(Maybe PasswordCredential) -- ^ "oldPassword"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChangePasswordRequest
instance A.FromJSON ChangePasswordRequest where
  parseJSON = A.withObject "ChangePasswordRequest" $ \o ->
    ChangePasswordRequest
      <$> (o .:? "newPassword")
      <*> (o .:? "oldPassword")

-- | ToJSON ChangePasswordRequest
instance A.ToJSON ChangePasswordRequest where
  toJSON ChangePasswordRequest {..} =
   _omitNulls
      [ "newPassword" .= changePasswordRequestNewPassword
      , "oldPassword" .= changePasswordRequestOldPassword
      ]


-- | Construct a value of type 'ChangePasswordRequest' (by applying it's required fields, if any)
mkChangePasswordRequest
  :: ChangePasswordRequest
mkChangePasswordRequest =
  ChangePasswordRequest
  { changePasswordRequestNewPassword = Nothing
  , changePasswordRequestOldPassword = Nothing
  }

-- ** CreateSessionRequest
-- | CreateSessionRequest
data CreateSessionRequest = CreateSessionRequest
  { createSessionRequestSessionToken :: !(Maybe Text) -- ^ "sessionToken"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSessionRequest
instance A.FromJSON CreateSessionRequest where
  parseJSON = A.withObject "CreateSessionRequest" $ \o ->
    CreateSessionRequest
      <$> (o .:? "sessionToken")

-- | ToJSON CreateSessionRequest
instance A.ToJSON CreateSessionRequest where
  toJSON CreateSessionRequest {..} =
   _omitNulls
      [ "sessionToken" .= createSessionRequestSessionToken
      ]


-- | Construct a value of type 'CreateSessionRequest' (by applying it's required fields, if any)
mkCreateSessionRequest
  :: CreateSessionRequest
mkCreateSessionRequest =
  CreateSessionRequest
  { createSessionRequestSessionToken = Nothing
  }

-- ** EmailAddress
-- | EmailAddress
data EmailAddress = EmailAddress
  { emailAddressStatus :: !(Maybe EmailStatus) -- ^ "status"
  , emailAddressType :: !(Maybe EmailType) -- ^ "type"
  , emailAddressValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailAddress
instance A.FromJSON EmailAddress where
  parseJSON = A.withObject "EmailAddress" $ \o ->
    EmailAddress
      <$> (o .:? "status")
      <*> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON EmailAddress
instance A.ToJSON EmailAddress where
  toJSON EmailAddress {..} =
   _omitNulls
      [ "status" .= emailAddressStatus
      , "type" .= emailAddressType
      , "value" .= emailAddressValue
      ]


-- | Construct a value of type 'EmailAddress' (by applying it's required fields, if any)
mkEmailAddress
  :: EmailAddress
mkEmailAddress =
  EmailAddress
  { emailAddressStatus = Nothing
  , emailAddressType = Nothing
  , emailAddressValue = Nothing
  }

-- ** EmailFactor
-- | EmailFactor
data EmailFactor = EmailFactor
  { emailFactorProfile :: !(Maybe EmailFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailFactor
instance A.FromJSON EmailFactor where
  parseJSON = A.withObject "EmailFactor" $ \o ->
    EmailFactor
      <$> (o .:? "profile")

-- | ToJSON EmailFactor
instance A.ToJSON EmailFactor where
  toJSON EmailFactor {..} =
   _omitNulls
      [ "profile" .= emailFactorProfile
      ]


-- | Construct a value of type 'EmailFactor' (by applying it's required fields, if any)
mkEmailFactor
  :: EmailFactor
mkEmailFactor =
  EmailFactor
  { emailFactorProfile = Nothing
  }

-- ** EmailFactorProfile
-- | EmailFactorProfile
data EmailFactorProfile = EmailFactorProfile
  { emailFactorProfileEmail :: !(Maybe Text) -- ^ "email"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmailFactorProfile
instance A.FromJSON EmailFactorProfile where
  parseJSON = A.withObject "EmailFactorProfile" $ \o ->
    EmailFactorProfile
      <$> (o .:? "email")

-- | ToJSON EmailFactorProfile
instance A.ToJSON EmailFactorProfile where
  toJSON EmailFactorProfile {..} =
   _omitNulls
      [ "email" .= emailFactorProfileEmail
      ]


-- | Construct a value of type 'EmailFactorProfile' (by applying it's required fields, if any)
mkEmailFactorProfile
  :: EmailFactorProfile
mkEmailFactorProfile =
  EmailFactorProfile
  { emailFactorProfileEmail = Nothing
  }

-- ** Factor
-- | Factor
data Factor = Factor
  { factorEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , factorLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , factorDevice :: !(Maybe Text) -- ^ "device"
  , factorDeviceType :: !(Maybe Text) -- ^ "deviceType"
  , factorFactorType :: !(Maybe FactorType) -- ^ "factorType"
  , factorId :: !(Maybe Text) -- ^ "id"
  , factorMfaStateTokenId :: !(Maybe Text) -- ^ "mfaStateTokenId"
  , factorProfile :: !(Maybe A.Value) -- ^ "profile"
  , factorProvider :: !(Maybe FactorProvider) -- ^ "provider"
  , factorRechallengeExistingFactor :: !(Maybe Bool) -- ^ "rechallengeExistingFactor"
  , factorSessionId :: !(Maybe Text) -- ^ "sessionId"
  , factorStatus :: !(Maybe FactorStatus) -- ^ "status"
  , factorTokenLifetimeSeconds :: !(Maybe Int) -- ^ "tokenLifetimeSeconds"
  , factorUserId :: !(Maybe Text) -- ^ "userId"
  , factorVerify :: !(Maybe VerifyFactorRequest) -- ^ "verify"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Factor
instance A.FromJSON Factor where
  parseJSON = A.withObject "Factor" $ \o ->
    Factor
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "device")
      <*> (o .:? "deviceType")
      <*> (o .:? "factorType")
      <*> (o .:? "id")
      <*> (o .:? "mfaStateTokenId")
      <*> (o .:? "profile")
      <*> (o .:? "provider")
      <*> (o .:? "rechallengeExistingFactor")
      <*> (o .:? "sessionId")
      <*> (o .:? "status")
      <*> (o .:? "tokenLifetimeSeconds")
      <*> (o .:? "userId")
      <*> (o .:? "verify")

-- | ToJSON Factor
instance A.ToJSON Factor where
  toJSON Factor {..} =
   _omitNulls
      [ "_embedded" .= factorEmbedded
      , "_links" .= factorLinks
      , "device" .= factorDevice
      , "deviceType" .= factorDeviceType
      , "factorType" .= factorFactorType
      , "id" .= factorId
      , "mfaStateTokenId" .= factorMfaStateTokenId
      , "profile" .= factorProfile
      , "provider" .= factorProvider
      , "rechallengeExistingFactor" .= factorRechallengeExistingFactor
      , "sessionId" .= factorSessionId
      , "status" .= factorStatus
      , "tokenLifetimeSeconds" .= factorTokenLifetimeSeconds
      , "userId" .= factorUserId
      , "verify" .= factorVerify
      ]


-- | Construct a value of type 'Factor' (by applying it's required fields, if any)
mkFactor
  :: Factor
mkFactor =
  Factor
  { factorEmbedded = Nothing
  , factorLinks = Nothing
  , factorDevice = Nothing
  , factorDeviceType = Nothing
  , factorFactorType = Nothing
  , factorId = Nothing
  , factorMfaStateTokenId = Nothing
  , factorProfile = Nothing
  , factorProvider = Nothing
  , factorRechallengeExistingFactor = Nothing
  , factorSessionId = Nothing
  , factorStatus = Nothing
  , factorTokenLifetimeSeconds = Nothing
  , factorUserId = Nothing
  , factorVerify = Nothing
  }

-- ** ForgotPasswordResponse
-- | ForgotPasswordResponse
data ForgotPasswordResponse = ForgotPasswordResponse
  { forgotPasswordResponseResetPasswordUrl :: !(Maybe Text) -- ^ "resetPasswordUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ForgotPasswordResponse
instance A.FromJSON ForgotPasswordResponse where
  parseJSON = A.withObject "ForgotPasswordResponse" $ \o ->
    ForgotPasswordResponse
      <$> (o .:? "resetPasswordUrl")

-- | ToJSON ForgotPasswordResponse
instance A.ToJSON ForgotPasswordResponse where
  toJSON ForgotPasswordResponse {..} =
   _omitNulls
      [ "resetPasswordUrl" .= forgotPasswordResponseResetPasswordUrl
      ]


-- | Construct a value of type 'ForgotPasswordResponse' (by applying it's required fields, if any)
mkForgotPasswordResponse
  :: ForgotPasswordResponse
mkForgotPasswordResponse =
  ForgotPasswordResponse
  { forgotPasswordResponseResetPasswordUrl = Nothing
  }

-- ** Group
-- | Group
data Group = Group
  { groupEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , groupLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , groupCreated :: !(Maybe DateTime) -- ^ "created"
  , groupId :: !(Maybe Text) -- ^ "id"
  , groupLastMembershipUpdated :: !(Maybe DateTime) -- ^ "lastMembershipUpdated"
  , groupLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , groupObjectClass :: !(Maybe [Text]) -- ^ "objectClass"
  , groupProfile :: !(Maybe GroupProfile) -- ^ "profile"
  , groupType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Group
instance A.FromJSON Group where
  parseJSON = A.withObject "Group" $ \o ->
    Group
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastMembershipUpdated")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "objectClass")
      <*> (o .:? "profile")
      <*> (o .:? "type")

-- | ToJSON Group
instance A.ToJSON Group where
  toJSON Group {..} =
   _omitNulls
      [ "_embedded" .= groupEmbedded
      , "_links" .= groupLinks
      , "created" .= groupCreated
      , "id" .= groupId
      , "lastMembershipUpdated" .= groupLastMembershipUpdated
      , "lastUpdated" .= groupLastUpdated
      , "objectClass" .= groupObjectClass
      , "profile" .= groupProfile
      , "type" .= groupType
      ]


-- | Construct a value of type 'Group' (by applying it's required fields, if any)
mkGroup
  :: Group
mkGroup =
  Group
  { groupEmbedded = Nothing
  , groupLinks = Nothing
  , groupCreated = Nothing
  , groupId = Nothing
  , groupLastMembershipUpdated = Nothing
  , groupLastUpdated = Nothing
  , groupObjectClass = Nothing
  , groupProfile = Nothing
  , groupType = Nothing
  }

-- ** GroupProfile
-- | GroupProfile
data GroupProfile = GroupProfile
  { groupProfileDescription :: !(Maybe Text) -- ^ "description"
  , groupProfileName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupProfile
instance A.FromJSON GroupProfile where
  parseJSON = A.withObject "GroupProfile" $ \o ->
    GroupProfile
      <$> (o .:? "description")
      <*> (o .:? "name")

-- | ToJSON GroupProfile
instance A.ToJSON GroupProfile where
  toJSON GroupProfile {..} =
   _omitNulls
      [ "description" .= groupProfileDescription
      , "name" .= groupProfileName
      ]


-- | Construct a value of type 'GroupProfile' (by applying it's required fields, if any)
mkGroupProfile
  :: GroupProfile
mkGroupProfile =
  GroupProfile
  { groupProfileDescription = Nothing
  , groupProfileName = Nothing
  }

-- ** GroupRule
-- | GroupRule
data GroupRule = GroupRule
  { groupRuleEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , groupRuleActions :: !(Maybe GroupRuleAction) -- ^ "actions"
  , groupRuleAllGroupsValid :: !(Maybe Bool) -- ^ "allGroupsValid"
  , groupRuleConditions :: !(Maybe GroupRuleConditions) -- ^ "conditions"
  , groupRuleCreated :: !(Maybe DateTime) -- ^ "created"
  , groupRuleId :: !(Maybe Text) -- ^ "id"
  , groupRuleLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , groupRuleName :: !(Maybe Text) -- ^ "name"
  , groupRuleStatus :: !(Maybe GroupRuleStatus) -- ^ "status"
  , groupRuleType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRule
instance A.FromJSON GroupRule where
  parseJSON = A.withObject "GroupRule" $ \o ->
    GroupRule
      <$> (o .:? "_embedded")
      <*> (o .:? "actions")
      <*> (o .:? "allGroupsValid")
      <*> (o .:? "conditions")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "name")
      <*> (o .:? "status")
      <*> (o .:? "type")

-- | ToJSON GroupRule
instance A.ToJSON GroupRule where
  toJSON GroupRule {..} =
   _omitNulls
      [ "_embedded" .= groupRuleEmbedded
      , "actions" .= groupRuleActions
      , "allGroupsValid" .= groupRuleAllGroupsValid
      , "conditions" .= groupRuleConditions
      , "created" .= groupRuleCreated
      , "id" .= groupRuleId
      , "lastUpdated" .= groupRuleLastUpdated
      , "name" .= groupRuleName
      , "status" .= groupRuleStatus
      , "type" .= groupRuleType
      ]


-- | Construct a value of type 'GroupRule' (by applying it's required fields, if any)
mkGroupRule
  :: GroupRule
mkGroupRule =
  GroupRule
  { groupRuleEmbedded = Nothing
  , groupRuleActions = Nothing
  , groupRuleAllGroupsValid = Nothing
  , groupRuleConditions = Nothing
  , groupRuleCreated = Nothing
  , groupRuleId = Nothing
  , groupRuleLastUpdated = Nothing
  , groupRuleName = Nothing
  , groupRuleStatus = Nothing
  , groupRuleType = Nothing
  }

-- ** GroupRuleAction
-- | GroupRuleAction
data GroupRuleAction = GroupRuleAction
  { groupRuleActionAssignUserToGroups :: !(Maybe GroupRuleGroupAssignment) -- ^ "assignUserToGroups"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleAction
instance A.FromJSON GroupRuleAction where
  parseJSON = A.withObject "GroupRuleAction" $ \o ->
    GroupRuleAction
      <$> (o .:? "assignUserToGroups")

-- | ToJSON GroupRuleAction
instance A.ToJSON GroupRuleAction where
  toJSON GroupRuleAction {..} =
   _omitNulls
      [ "assignUserToGroups" .= groupRuleActionAssignUserToGroups
      ]


-- | Construct a value of type 'GroupRuleAction' (by applying it's required fields, if any)
mkGroupRuleAction
  :: GroupRuleAction
mkGroupRuleAction =
  GroupRuleAction
  { groupRuleActionAssignUserToGroups = Nothing
  }

-- ** GroupRuleConditions
-- | GroupRuleConditions
data GroupRuleConditions = GroupRuleConditions
  { groupRuleConditionsExpression :: !(Maybe GroupRuleExpression) -- ^ "expression"
  , groupRuleConditionsPeople :: !(Maybe GroupRulePeopleCondition) -- ^ "people"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleConditions
instance A.FromJSON GroupRuleConditions where
  parseJSON = A.withObject "GroupRuleConditions" $ \o ->
    GroupRuleConditions
      <$> (o .:? "expression")
      <*> (o .:? "people")

-- | ToJSON GroupRuleConditions
instance A.ToJSON GroupRuleConditions where
  toJSON GroupRuleConditions {..} =
   _omitNulls
      [ "expression" .= groupRuleConditionsExpression
      , "people" .= groupRuleConditionsPeople
      ]


-- | Construct a value of type 'GroupRuleConditions' (by applying it's required fields, if any)
mkGroupRuleConditions
  :: GroupRuleConditions
mkGroupRuleConditions =
  GroupRuleConditions
  { groupRuleConditionsExpression = Nothing
  , groupRuleConditionsPeople = Nothing
  }

-- ** GroupRuleExpression
-- | GroupRuleExpression
data GroupRuleExpression = GroupRuleExpression
  { groupRuleExpressionType :: !(Maybe Text) -- ^ "type"
  , groupRuleExpressionValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleExpression
instance A.FromJSON GroupRuleExpression where
  parseJSON = A.withObject "GroupRuleExpression" $ \o ->
    GroupRuleExpression
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON GroupRuleExpression
instance A.ToJSON GroupRuleExpression where
  toJSON GroupRuleExpression {..} =
   _omitNulls
      [ "type" .= groupRuleExpressionType
      , "value" .= groupRuleExpressionValue
      ]


-- | Construct a value of type 'GroupRuleExpression' (by applying it's required fields, if any)
mkGroupRuleExpression
  :: GroupRuleExpression
mkGroupRuleExpression =
  GroupRuleExpression
  { groupRuleExpressionType = Nothing
  , groupRuleExpressionValue = Nothing
  }

-- ** GroupRuleGroupAssignment
-- | GroupRuleGroupAssignment
data GroupRuleGroupAssignment = GroupRuleGroupAssignment
  { groupRuleGroupAssignmentGroupIds :: !(Maybe [Text]) -- ^ "groupIds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleGroupAssignment
instance A.FromJSON GroupRuleGroupAssignment where
  parseJSON = A.withObject "GroupRuleGroupAssignment" $ \o ->
    GroupRuleGroupAssignment
      <$> (o .:? "groupIds")

-- | ToJSON GroupRuleGroupAssignment
instance A.ToJSON GroupRuleGroupAssignment where
  toJSON GroupRuleGroupAssignment {..} =
   _omitNulls
      [ "groupIds" .= groupRuleGroupAssignmentGroupIds
      ]


-- | Construct a value of type 'GroupRuleGroupAssignment' (by applying it's required fields, if any)
mkGroupRuleGroupAssignment
  :: GroupRuleGroupAssignment
mkGroupRuleGroupAssignment =
  GroupRuleGroupAssignment
  { groupRuleGroupAssignmentGroupIds = Nothing
  }

-- ** GroupRuleGroupCondition
-- | GroupRuleGroupCondition
data GroupRuleGroupCondition = GroupRuleGroupCondition
  { groupRuleGroupConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , groupRuleGroupConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleGroupCondition
instance A.FromJSON GroupRuleGroupCondition where
  parseJSON = A.withObject "GroupRuleGroupCondition" $ \o ->
    GroupRuleGroupCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON GroupRuleGroupCondition
instance A.ToJSON GroupRuleGroupCondition where
  toJSON GroupRuleGroupCondition {..} =
   _omitNulls
      [ "exclude" .= groupRuleGroupConditionExclude
      , "include" .= groupRuleGroupConditionInclude
      ]


-- | Construct a value of type 'GroupRuleGroupCondition' (by applying it's required fields, if any)
mkGroupRuleGroupCondition
  :: GroupRuleGroupCondition
mkGroupRuleGroupCondition =
  GroupRuleGroupCondition
  { groupRuleGroupConditionExclude = Nothing
  , groupRuleGroupConditionInclude = Nothing
  }

-- ** GroupRulePeopleCondition
-- | GroupRulePeopleCondition
data GroupRulePeopleCondition = GroupRulePeopleCondition
  { groupRulePeopleConditionGroups :: !(Maybe GroupRuleGroupCondition) -- ^ "groups"
  , groupRulePeopleConditionUsers :: !(Maybe GroupRuleUserCondition) -- ^ "users"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRulePeopleCondition
instance A.FromJSON GroupRulePeopleCondition where
  parseJSON = A.withObject "GroupRulePeopleCondition" $ \o ->
    GroupRulePeopleCondition
      <$> (o .:? "groups")
      <*> (o .:? "users")

-- | ToJSON GroupRulePeopleCondition
instance A.ToJSON GroupRulePeopleCondition where
  toJSON GroupRulePeopleCondition {..} =
   _omitNulls
      [ "groups" .= groupRulePeopleConditionGroups
      , "users" .= groupRulePeopleConditionUsers
      ]


-- | Construct a value of type 'GroupRulePeopleCondition' (by applying it's required fields, if any)
mkGroupRulePeopleCondition
  :: GroupRulePeopleCondition
mkGroupRulePeopleCondition =
  GroupRulePeopleCondition
  { groupRulePeopleConditionGroups = Nothing
  , groupRulePeopleConditionUsers = Nothing
  }

-- ** GroupRuleUserCondition
-- | GroupRuleUserCondition
data GroupRuleUserCondition = GroupRuleUserCondition
  { groupRuleUserConditionExclude :: !(Maybe [Text]) -- ^ "exclude"
  , groupRuleUserConditionInclude :: !(Maybe [Text]) -- ^ "include"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupRuleUserCondition
instance A.FromJSON GroupRuleUserCondition where
  parseJSON = A.withObject "GroupRuleUserCondition" $ \o ->
    GroupRuleUserCondition
      <$> (o .:? "exclude")
      <*> (o .:? "include")

-- | ToJSON GroupRuleUserCondition
instance A.ToJSON GroupRuleUserCondition where
  toJSON GroupRuleUserCondition {..} =
   _omitNulls
      [ "exclude" .= groupRuleUserConditionExclude
      , "include" .= groupRuleUserConditionInclude
      ]


-- | Construct a value of type 'GroupRuleUserCondition' (by applying it's required fields, if any)
mkGroupRuleUserCondition
  :: GroupRuleUserCondition
mkGroupRuleUserCondition =
  GroupRuleUserCondition
  { groupRuleUserConditionExclude = Nothing
  , groupRuleUserConditionInclude = Nothing
  }

-- ** HardwareFactor
-- | HardwareFactor
data HardwareFactor = HardwareFactor
  { hardwareFactorProfile :: !(Maybe HardwareFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HardwareFactor
instance A.FromJSON HardwareFactor where
  parseJSON = A.withObject "HardwareFactor" $ \o ->
    HardwareFactor
      <$> (o .:? "profile")

-- | ToJSON HardwareFactor
instance A.ToJSON HardwareFactor where
  toJSON HardwareFactor {..} =
   _omitNulls
      [ "profile" .= hardwareFactorProfile
      ]


-- | Construct a value of type 'HardwareFactor' (by applying it's required fields, if any)
mkHardwareFactor
  :: HardwareFactor
mkHardwareFactor =
  HardwareFactor
  { hardwareFactorProfile = Nothing
  }

-- ** HardwareFactorProfile
-- | HardwareFactorProfile
data HardwareFactorProfile = HardwareFactorProfile
  { hardwareFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HardwareFactorProfile
instance A.FromJSON HardwareFactorProfile where
  parseJSON = A.withObject "HardwareFactorProfile" $ \o ->
    HardwareFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON HardwareFactorProfile
instance A.ToJSON HardwareFactorProfile where
  toJSON HardwareFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= hardwareFactorProfileCredentialId
      ]


-- | Construct a value of type 'HardwareFactorProfile' (by applying it's required fields, if any)
mkHardwareFactorProfile
  :: HardwareFactorProfile
mkHardwareFactorProfile =
  HardwareFactorProfile
  { hardwareFactorProfileCredentialId = Nothing
  }

-- ** JsonWebKey
-- | JsonWebKey
data JsonWebKey = JsonWebKey
  { jsonWebKeyLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , jsonWebKeyAlg :: !(Maybe Text) -- ^ "alg"
  , jsonWebKeyCreated :: !(Maybe DateTime) -- ^ "created"
  , jsonWebKeyE :: !(Maybe Text) -- ^ "e"
  , jsonWebKeyExpiresAt :: !(Maybe DateTime) -- ^ "expiresAt"
  , jsonWebKeyKeyOps :: !(Maybe [Text]) -- ^ "key_ops"
  , jsonWebKeyKid :: !(Maybe Text) -- ^ "kid"
  , jsonWebKeyKty :: !(Maybe Text) -- ^ "kty"
  , jsonWebKeyLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , jsonWebKeyN :: !(Maybe Text) -- ^ "n"
  , jsonWebKeyStatus :: !(Maybe Text) -- ^ "status"
  , jsonWebKeyUse :: !(Maybe Text) -- ^ "use"
  , jsonWebKeyX5c :: !(Maybe [Text]) -- ^ "x5c"
  , jsonWebKeyX5t :: !(Maybe Text) -- ^ "x5t"
  , jsonWebKeyX5tS256 :: !(Maybe Text) -- ^ "x5t#S256"
  , jsonWebKeyX5u :: !(Maybe Text) -- ^ "x5u"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonWebKey
instance A.FromJSON JsonWebKey where
  parseJSON = A.withObject "JsonWebKey" $ \o ->
    JsonWebKey
      <$> (o .:? "_links")
      <*> (o .:? "alg")
      <*> (o .:? "created")
      <*> (o .:? "e")
      <*> (o .:? "expiresAt")
      <*> (o .:? "key_ops")
      <*> (o .:? "kid")
      <*> (o .:? "kty")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "n")
      <*> (o .:? "status")
      <*> (o .:? "use")
      <*> (o .:? "x5c")
      <*> (o .:? "x5t")
      <*> (o .:? "x5t#S256")
      <*> (o .:? "x5u")

-- | ToJSON JsonWebKey
instance A.ToJSON JsonWebKey where
  toJSON JsonWebKey {..} =
   _omitNulls
      [ "_links" .= jsonWebKeyLinks
      , "alg" .= jsonWebKeyAlg
      , "created" .= jsonWebKeyCreated
      , "e" .= jsonWebKeyE
      , "expiresAt" .= jsonWebKeyExpiresAt
      , "key_ops" .= jsonWebKeyKeyOps
      , "kid" .= jsonWebKeyKid
      , "kty" .= jsonWebKeyKty
      , "lastUpdated" .= jsonWebKeyLastUpdated
      , "n" .= jsonWebKeyN
      , "status" .= jsonWebKeyStatus
      , "use" .= jsonWebKeyUse
      , "x5c" .= jsonWebKeyX5c
      , "x5t" .= jsonWebKeyX5t
      , "x5t#S256" .= jsonWebKeyX5tS256
      , "x5u" .= jsonWebKeyX5u
      ]


-- | Construct a value of type 'JsonWebKey' (by applying it's required fields, if any)
mkJsonWebKey
  :: JsonWebKey
mkJsonWebKey =
  JsonWebKey
  { jsonWebKeyLinks = Nothing
  , jsonWebKeyAlg = Nothing
  , jsonWebKeyCreated = Nothing
  , jsonWebKeyE = Nothing
  , jsonWebKeyExpiresAt = Nothing
  , jsonWebKeyKeyOps = Nothing
  , jsonWebKeyKid = Nothing
  , jsonWebKeyKty = Nothing
  , jsonWebKeyLastUpdated = Nothing
  , jsonWebKeyN = Nothing
  , jsonWebKeyStatus = Nothing
  , jsonWebKeyUse = Nothing
  , jsonWebKeyX5c = Nothing
  , jsonWebKeyX5t = Nothing
  , jsonWebKeyX5tS256 = Nothing
  , jsonWebKeyX5u = Nothing
  }

-- ** LogActor
-- | LogActor
data LogActor = LogActor
  { logActorAlternateId :: !(Maybe Text) -- ^ "alternateId"
  , logActorDetail :: !(Maybe (Map.Map String A.Value)) -- ^ "detail"
  , logActorDisplayName :: !(Maybe Text) -- ^ "displayName"
  , logActorId :: !(Maybe Text) -- ^ "id"
  , logActorType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogActor
instance A.FromJSON LogActor where
  parseJSON = A.withObject "LogActor" $ \o ->
    LogActor
      <$> (o .:? "alternateId")
      <*> (o .:? "detail")
      <*> (o .:? "displayName")
      <*> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogActor
instance A.ToJSON LogActor where
  toJSON LogActor {..} =
   _omitNulls
      [ "alternateId" .= logActorAlternateId
      , "detail" .= logActorDetail
      , "displayName" .= logActorDisplayName
      , "id" .= logActorId
      , "type" .= logActorType
      ]


-- | Construct a value of type 'LogActor' (by applying it's required fields, if any)
mkLogActor
  :: LogActor
mkLogActor =
  LogActor
  { logActorAlternateId = Nothing
  , logActorDetail = Nothing
  , logActorDisplayName = Nothing
  , logActorId = Nothing
  , logActorType = Nothing
  }

-- ** LogAuthenticationContext
-- | LogAuthenticationContext
data LogAuthenticationContext = LogAuthenticationContext
  { logAuthenticationContextAuthenticationProvider :: !(Maybe LogAuthenticationProvider) -- ^ "authenticationProvider"
  , logAuthenticationContextAuthenticationStep :: !(Maybe Int) -- ^ "authenticationStep"
  , logAuthenticationContextCredentialProvider :: !(Maybe [LogCredentialProvider]) -- ^ "credentialProvider"
  , logAuthenticationContextCredentialType :: !(Maybe [LogCredentialType]) -- ^ "credentialType"
  , logAuthenticationContextExternalSessionId :: !(Maybe Text) -- ^ "externalSessionId"
  , logAuthenticationContextInterface :: !(Maybe Text) -- ^ "interface"
  , logAuthenticationContextIssuer :: !(Maybe LogIssuer) -- ^ "issuer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogAuthenticationContext
instance A.FromJSON LogAuthenticationContext where
  parseJSON = A.withObject "LogAuthenticationContext" $ \o ->
    LogAuthenticationContext
      <$> (o .:? "authenticationProvider")
      <*> (o .:? "authenticationStep")
      <*> (o .:? "credentialProvider")
      <*> (o .:? "credentialType")
      <*> (o .:? "externalSessionId")
      <*> (o .:? "interface")
      <*> (o .:? "issuer")

-- | ToJSON LogAuthenticationContext
instance A.ToJSON LogAuthenticationContext where
  toJSON LogAuthenticationContext {..} =
   _omitNulls
      [ "authenticationProvider" .= logAuthenticationContextAuthenticationProvider
      , "authenticationStep" .= logAuthenticationContextAuthenticationStep
      , "credentialProvider" .= logAuthenticationContextCredentialProvider
      , "credentialType" .= logAuthenticationContextCredentialType
      , "externalSessionId" .= logAuthenticationContextExternalSessionId
      , "interface" .= logAuthenticationContextInterface
      , "issuer" .= logAuthenticationContextIssuer
      ]


-- | Construct a value of type 'LogAuthenticationContext' (by applying it's required fields, if any)
mkLogAuthenticationContext
  :: LogAuthenticationContext
mkLogAuthenticationContext =
  LogAuthenticationContext
  { logAuthenticationContextAuthenticationProvider = Nothing
  , logAuthenticationContextAuthenticationStep = Nothing
  , logAuthenticationContextCredentialProvider = Nothing
  , logAuthenticationContextCredentialType = Nothing
  , logAuthenticationContextExternalSessionId = Nothing
  , logAuthenticationContextInterface = Nothing
  , logAuthenticationContextIssuer = Nothing
  }

-- ** LogClient
-- | LogClient
data LogClient = LogClient
  { logClientDevice :: !(Maybe Text) -- ^ "device"
  , logClientGeographicalContext :: !(Maybe LogGeographicalContext) -- ^ "geographicalContext"
  , logClientId :: !(Maybe Text) -- ^ "id"
  , logClientIpAddress :: !(Maybe Text) -- ^ "ipAddress"
  , logClientUserAgent :: !(Maybe LogUserAgent) -- ^ "userAgent"
  , logClientZone :: !(Maybe Text) -- ^ "zone"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogClient
instance A.FromJSON LogClient where
  parseJSON = A.withObject "LogClient" $ \o ->
    LogClient
      <$> (o .:? "device")
      <*> (o .:? "geographicalContext")
      <*> (o .:? "id")
      <*> (o .:? "ipAddress")
      <*> (o .:? "userAgent")
      <*> (o .:? "zone")

-- | ToJSON LogClient
instance A.ToJSON LogClient where
  toJSON LogClient {..} =
   _omitNulls
      [ "device" .= logClientDevice
      , "geographicalContext" .= logClientGeographicalContext
      , "id" .= logClientId
      , "ipAddress" .= logClientIpAddress
      , "userAgent" .= logClientUserAgent
      , "zone" .= logClientZone
      ]


-- | Construct a value of type 'LogClient' (by applying it's required fields, if any)
mkLogClient
  :: LogClient
mkLogClient =
  LogClient
  { logClientDevice = Nothing
  , logClientGeographicalContext = Nothing
  , logClientId = Nothing
  , logClientIpAddress = Nothing
  , logClientUserAgent = Nothing
  , logClientZone = Nothing
  }

-- ** LogDebugContext
-- | LogDebugContext
data LogDebugContext = LogDebugContext
  { logDebugContextDebugData :: !(Maybe (Map.Map String A.Value)) -- ^ "debugData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogDebugContext
instance A.FromJSON LogDebugContext where
  parseJSON = A.withObject "LogDebugContext" $ \o ->
    LogDebugContext
      <$> (o .:? "debugData")

-- | ToJSON LogDebugContext
instance A.ToJSON LogDebugContext where
  toJSON LogDebugContext {..} =
   _omitNulls
      [ "debugData" .= logDebugContextDebugData
      ]


-- | Construct a value of type 'LogDebugContext' (by applying it's required fields, if any)
mkLogDebugContext
  :: LogDebugContext
mkLogDebugContext =
  LogDebugContext
  { logDebugContextDebugData = Nothing
  }

-- ** LogEvent
-- | LogEvent
data LogEvent = LogEvent
  { logEventActor :: !(Maybe LogActor) -- ^ "actor"
  , logEventAuthenticationContext :: !(Maybe LogAuthenticationContext) -- ^ "authenticationContext"
  , logEventClient :: !(Maybe LogClient) -- ^ "client"
  , logEventDebugContext :: !(Maybe LogDebugContext) -- ^ "debugContext"
  , logEventDisplayMessage :: !(Maybe Text) -- ^ "displayMessage"
  , logEventEventType :: !(Maybe Text) -- ^ "eventType"
  , logEventLegacyEventType :: !(Maybe Text) -- ^ "legacyEventType"
  , logEventOutcome :: !(Maybe LogOutcome) -- ^ "outcome"
  , logEventPublished :: !(Maybe DateTime) -- ^ "published"
  , logEventRequest :: !(Maybe LogRequest) -- ^ "request"
  , logEventSecurityContext :: !(Maybe LogSecurityContext) -- ^ "securityContext"
  , logEventSeverity :: !(Maybe LogSeverity) -- ^ "severity"
  , logEventTarget :: !(Maybe [LogTarget]) -- ^ "target"
  , logEventTransaction :: !(Maybe LogTransaction) -- ^ "transaction"
  , logEventUuid :: !(Maybe Text) -- ^ "uuid"
  , logEventVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogEvent
instance A.FromJSON LogEvent where
  parseJSON = A.withObject "LogEvent" $ \o ->
    LogEvent
      <$> (o .:? "actor")
      <*> (o .:? "authenticationContext")
      <*> (o .:? "client")
      <*> (o .:? "debugContext")
      <*> (o .:? "displayMessage")
      <*> (o .:? "eventType")
      <*> (o .:? "legacyEventType")
      <*> (o .:? "outcome")
      <*> (o .:? "published")
      <*> (o .:? "request")
      <*> (o .:? "securityContext")
      <*> (o .:? "severity")
      <*> (o .:? "target")
      <*> (o .:? "transaction")
      <*> (o .:? "uuid")
      <*> (o .:? "version")

-- | ToJSON LogEvent
instance A.ToJSON LogEvent where
  toJSON LogEvent {..} =
   _omitNulls
      [ "actor" .= logEventActor
      , "authenticationContext" .= logEventAuthenticationContext
      , "client" .= logEventClient
      , "debugContext" .= logEventDebugContext
      , "displayMessage" .= logEventDisplayMessage
      , "eventType" .= logEventEventType
      , "legacyEventType" .= logEventLegacyEventType
      , "outcome" .= logEventOutcome
      , "published" .= logEventPublished
      , "request" .= logEventRequest
      , "securityContext" .= logEventSecurityContext
      , "severity" .= logEventSeverity
      , "target" .= logEventTarget
      , "transaction" .= logEventTransaction
      , "uuid" .= logEventUuid
      , "version" .= logEventVersion
      ]


-- | Construct a value of type 'LogEvent' (by applying it's required fields, if any)
mkLogEvent
  :: LogEvent
mkLogEvent =
  LogEvent
  { logEventActor = Nothing
  , logEventAuthenticationContext = Nothing
  , logEventClient = Nothing
  , logEventDebugContext = Nothing
  , logEventDisplayMessage = Nothing
  , logEventEventType = Nothing
  , logEventLegacyEventType = Nothing
  , logEventOutcome = Nothing
  , logEventPublished = Nothing
  , logEventRequest = Nothing
  , logEventSecurityContext = Nothing
  , logEventSeverity = Nothing
  , logEventTarget = Nothing
  , logEventTransaction = Nothing
  , logEventUuid = Nothing
  , logEventVersion = Nothing
  }

-- ** LogGeographicalContext
-- | LogGeographicalContext
data LogGeographicalContext = LogGeographicalContext
  { logGeographicalContextCity :: !(Maybe Text) -- ^ "city"
  , logGeographicalContextCountry :: !(Maybe Text) -- ^ "country"
  , logGeographicalContextGeolocation :: !(Maybe LogGeolocation) -- ^ "geolocation"
  , logGeographicalContextPostalCode :: !(Maybe Text) -- ^ "postalCode"
  , logGeographicalContextState :: !(Maybe Text) -- ^ "state"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogGeographicalContext
instance A.FromJSON LogGeographicalContext where
  parseJSON = A.withObject "LogGeographicalContext" $ \o ->
    LogGeographicalContext
      <$> (o .:? "city")
      <*> (o .:? "country")
      <*> (o .:? "geolocation")
      <*> (o .:? "postalCode")
      <*> (o .:? "state")

-- | ToJSON LogGeographicalContext
instance A.ToJSON LogGeographicalContext where
  toJSON LogGeographicalContext {..} =
   _omitNulls
      [ "city" .= logGeographicalContextCity
      , "country" .= logGeographicalContextCountry
      , "geolocation" .= logGeographicalContextGeolocation
      , "postalCode" .= logGeographicalContextPostalCode
      , "state" .= logGeographicalContextState
      ]


-- | Construct a value of type 'LogGeographicalContext' (by applying it's required fields, if any)
mkLogGeographicalContext
  :: LogGeographicalContext
mkLogGeographicalContext =
  LogGeographicalContext
  { logGeographicalContextCity = Nothing
  , logGeographicalContextCountry = Nothing
  , logGeographicalContextGeolocation = Nothing
  , logGeographicalContextPostalCode = Nothing
  , logGeographicalContextState = Nothing
  }

-- ** LogGeolocation
-- | LogGeolocation
data LogGeolocation = LogGeolocation
  { logGeolocationLat :: !(Maybe Double) -- ^ "lat"
  , logGeolocationLon :: !(Maybe Double) -- ^ "lon"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogGeolocation
instance A.FromJSON LogGeolocation where
  parseJSON = A.withObject "LogGeolocation" $ \o ->
    LogGeolocation
      <$> (o .:? "lat")
      <*> (o .:? "lon")

-- | ToJSON LogGeolocation
instance A.ToJSON LogGeolocation where
  toJSON LogGeolocation {..} =
   _omitNulls
      [ "lat" .= logGeolocationLat
      , "lon" .= logGeolocationLon
      ]


-- | Construct a value of type 'LogGeolocation' (by applying it's required fields, if any)
mkLogGeolocation
  :: LogGeolocation
mkLogGeolocation =
  LogGeolocation
  { logGeolocationLat = Nothing
  , logGeolocationLon = Nothing
  }

-- ** LogIpAddress
-- | LogIpAddress
data LogIpAddress = LogIpAddress
  { logIpAddressGeographicalContext :: !(Maybe LogGeographicalContext) -- ^ "geographicalContext"
  , logIpAddressIp :: !(Maybe Text) -- ^ "ip"
  , logIpAddressSource :: !(Maybe Text) -- ^ "source"
  , logIpAddressVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogIpAddress
instance A.FromJSON LogIpAddress where
  parseJSON = A.withObject "LogIpAddress" $ \o ->
    LogIpAddress
      <$> (o .:? "geographicalContext")
      <*> (o .:? "ip")
      <*> (o .:? "source")
      <*> (o .:? "version")

-- | ToJSON LogIpAddress
instance A.ToJSON LogIpAddress where
  toJSON LogIpAddress {..} =
   _omitNulls
      [ "geographicalContext" .= logIpAddressGeographicalContext
      , "ip" .= logIpAddressIp
      , "source" .= logIpAddressSource
      , "version" .= logIpAddressVersion
      ]


-- | Construct a value of type 'LogIpAddress' (by applying it's required fields, if any)
mkLogIpAddress
  :: LogIpAddress
mkLogIpAddress =
  LogIpAddress
  { logIpAddressGeographicalContext = Nothing
  , logIpAddressIp = Nothing
  , logIpAddressSource = Nothing
  , logIpAddressVersion = Nothing
  }

-- ** LogIssuer
-- | LogIssuer
data LogIssuer = LogIssuer
  { logIssuerId :: !(Maybe Text) -- ^ "id"
  , logIssuerType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogIssuer
instance A.FromJSON LogIssuer where
  parseJSON = A.withObject "LogIssuer" $ \o ->
    LogIssuer
      <$> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogIssuer
instance A.ToJSON LogIssuer where
  toJSON LogIssuer {..} =
   _omitNulls
      [ "id" .= logIssuerId
      , "type" .= logIssuerType
      ]


-- | Construct a value of type 'LogIssuer' (by applying it's required fields, if any)
mkLogIssuer
  :: LogIssuer
mkLogIssuer =
  LogIssuer
  { logIssuerId = Nothing
  , logIssuerType = Nothing
  }

-- ** LogOutcome
-- | LogOutcome
data LogOutcome = LogOutcome
  { logOutcomeReason :: !(Maybe Text) -- ^ "reason"
  , logOutcomeResult :: !(Maybe Text) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogOutcome
instance A.FromJSON LogOutcome where
  parseJSON = A.withObject "LogOutcome" $ \o ->
    LogOutcome
      <$> (o .:? "reason")
      <*> (o .:? "result")

-- | ToJSON LogOutcome
instance A.ToJSON LogOutcome where
  toJSON LogOutcome {..} =
   _omitNulls
      [ "reason" .= logOutcomeReason
      , "result" .= logOutcomeResult
      ]


-- | Construct a value of type 'LogOutcome' (by applying it's required fields, if any)
mkLogOutcome
  :: LogOutcome
mkLogOutcome =
  LogOutcome
  { logOutcomeReason = Nothing
  , logOutcomeResult = Nothing
  }

-- ** LogRequest
-- | LogRequest
data LogRequest = LogRequest
  { logRequestIpChain :: !(Maybe [LogIpAddress]) -- ^ "ipChain"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogRequest
instance A.FromJSON LogRequest where
  parseJSON = A.withObject "LogRequest" $ \o ->
    LogRequest
      <$> (o .:? "ipChain")

-- | ToJSON LogRequest
instance A.ToJSON LogRequest where
  toJSON LogRequest {..} =
   _omitNulls
      [ "ipChain" .= logRequestIpChain
      ]


-- | Construct a value of type 'LogRequest' (by applying it's required fields, if any)
mkLogRequest
  :: LogRequest
mkLogRequest =
  LogRequest
  { logRequestIpChain = Nothing
  }

-- ** LogSecurityContext
-- | LogSecurityContext
data LogSecurityContext = LogSecurityContext
  { logSecurityContextAsNumber :: !(Maybe Int) -- ^ "asNumber"
  , logSecurityContextAsOrg :: !(Maybe Text) -- ^ "asOrg"
  , logSecurityContextDomain :: !(Maybe Text) -- ^ "domain"
  , logSecurityContextIsProxy :: !(Maybe Bool) -- ^ "isProxy"
  , logSecurityContextIsp :: !(Maybe Text) -- ^ "isp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogSecurityContext
instance A.FromJSON LogSecurityContext where
  parseJSON = A.withObject "LogSecurityContext" $ \o ->
    LogSecurityContext
      <$> (o .:? "asNumber")
      <*> (o .:? "asOrg")
      <*> (o .:? "domain")
      <*> (o .:? "isProxy")
      <*> (o .:? "isp")

-- | ToJSON LogSecurityContext
instance A.ToJSON LogSecurityContext where
  toJSON LogSecurityContext {..} =
   _omitNulls
      [ "asNumber" .= logSecurityContextAsNumber
      , "asOrg" .= logSecurityContextAsOrg
      , "domain" .= logSecurityContextDomain
      , "isProxy" .= logSecurityContextIsProxy
      , "isp" .= logSecurityContextIsp
      ]


-- | Construct a value of type 'LogSecurityContext' (by applying it's required fields, if any)
mkLogSecurityContext
  :: LogSecurityContext
mkLogSecurityContext =
  LogSecurityContext
  { logSecurityContextAsNumber = Nothing
  , logSecurityContextAsOrg = Nothing
  , logSecurityContextDomain = Nothing
  , logSecurityContextIsProxy = Nothing
  , logSecurityContextIsp = Nothing
  }

-- ** LogTarget
-- | LogTarget
data LogTarget = LogTarget
  { logTargetAlternateId :: !(Maybe Text) -- ^ "alternateId"
  , logTargetDetailEntry :: !(Maybe (Map.Map String A.Value)) -- ^ "detailEntry"
  , logTargetDisplayName :: !(Maybe Text) -- ^ "displayName"
  , logTargetId :: !(Maybe Text) -- ^ "id"
  , logTargetType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogTarget
instance A.FromJSON LogTarget where
  parseJSON = A.withObject "LogTarget" $ \o ->
    LogTarget
      <$> (o .:? "alternateId")
      <*> (o .:? "detailEntry")
      <*> (o .:? "displayName")
      <*> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogTarget
instance A.ToJSON LogTarget where
  toJSON LogTarget {..} =
   _omitNulls
      [ "alternateId" .= logTargetAlternateId
      , "detailEntry" .= logTargetDetailEntry
      , "displayName" .= logTargetDisplayName
      , "id" .= logTargetId
      , "type" .= logTargetType
      ]


-- | Construct a value of type 'LogTarget' (by applying it's required fields, if any)
mkLogTarget
  :: LogTarget
mkLogTarget =
  LogTarget
  { logTargetAlternateId = Nothing
  , logTargetDetailEntry = Nothing
  , logTargetDisplayName = Nothing
  , logTargetId = Nothing
  , logTargetType = Nothing
  }

-- ** LogTransaction
-- | LogTransaction
data LogTransaction = LogTransaction
  { logTransactionDetail :: !(Maybe (Map.Map String A.Value)) -- ^ "detail"
  , logTransactionId :: !(Maybe Text) -- ^ "id"
  , logTransactionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogTransaction
instance A.FromJSON LogTransaction where
  parseJSON = A.withObject "LogTransaction" $ \o ->
    LogTransaction
      <$> (o .:? "detail")
      <*> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON LogTransaction
instance A.ToJSON LogTransaction where
  toJSON LogTransaction {..} =
   _omitNulls
      [ "detail" .= logTransactionDetail
      , "id" .= logTransactionId
      , "type" .= logTransactionType
      ]


-- | Construct a value of type 'LogTransaction' (by applying it's required fields, if any)
mkLogTransaction
  :: LogTransaction
mkLogTransaction =
  LogTransaction
  { logTransactionDetail = Nothing
  , logTransactionId = Nothing
  , logTransactionType = Nothing
  }

-- ** LogUserAgent
-- | LogUserAgent
data LogUserAgent = LogUserAgent
  { logUserAgentBrowser :: !(Maybe Text) -- ^ "browser"
  , logUserAgentOs :: !(Maybe Text) -- ^ "os"
  , logUserAgentRawUserAgent :: !(Maybe Text) -- ^ "rawUserAgent"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LogUserAgent
instance A.FromJSON LogUserAgent where
  parseJSON = A.withObject "LogUserAgent" $ \o ->
    LogUserAgent
      <$> (o .:? "browser")
      <*> (o .:? "os")
      <*> (o .:? "rawUserAgent")

-- | ToJSON LogUserAgent
instance A.ToJSON LogUserAgent where
  toJSON LogUserAgent {..} =
   _omitNulls
      [ "browser" .= logUserAgentBrowser
      , "os" .= logUserAgentOs
      , "rawUserAgent" .= logUserAgentRawUserAgent
      ]


-- | Construct a value of type 'LogUserAgent' (by applying it's required fields, if any)
mkLogUserAgent
  :: LogUserAgent
mkLogUserAgent =
  LogUserAgent
  { logUserAgentBrowser = Nothing
  , logUserAgentOs = Nothing
  , logUserAgentRawUserAgent = Nothing
  }

-- ** OAuthApplicationCredentials
-- | OAuthApplicationCredentials
data OAuthApplicationCredentials = OAuthApplicationCredentials
  { oAuthApplicationCredentialsOauthClient :: !(Maybe ApplicationCredentialsOAuthClient) -- ^ "oauthClient"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OAuthApplicationCredentials
instance A.FromJSON OAuthApplicationCredentials where
  parseJSON = A.withObject "OAuthApplicationCredentials" $ \o ->
    OAuthApplicationCredentials
      <$> (o .:? "oauthClient")

-- | ToJSON OAuthApplicationCredentials
instance A.ToJSON OAuthApplicationCredentials where
  toJSON OAuthApplicationCredentials {..} =
   _omitNulls
      [ "oauthClient" .= oAuthApplicationCredentialsOauthClient
      ]


-- | Construct a value of type 'OAuthApplicationCredentials' (by applying it's required fields, if any)
mkOAuthApplicationCredentials
  :: OAuthApplicationCredentials
mkOAuthApplicationCredentials =
  OAuthApplicationCredentials
  { oAuthApplicationCredentialsOauthClient = Nothing
  }

-- ** OpenIdConnectApplication
-- | OpenIdConnectApplication
data OpenIdConnectApplication = OpenIdConnectApplication
  { openIdConnectApplicationCredentials :: !(Maybe OAuthApplicationCredentials) -- ^ "credentials"
  , openIdConnectApplicationName :: !(Maybe A.Value) -- ^ "name"
  , openIdConnectApplicationSettings :: !(Maybe OpenIdConnectApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplication
instance A.FromJSON OpenIdConnectApplication where
  parseJSON = A.withObject "OpenIdConnectApplication" $ \o ->
    OpenIdConnectApplication
      <$> (o .:? "credentials")
      <*> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON OpenIdConnectApplication
instance A.ToJSON OpenIdConnectApplication where
  toJSON OpenIdConnectApplication {..} =
   _omitNulls
      [ "credentials" .= openIdConnectApplicationCredentials
      , "name" .= openIdConnectApplicationName
      , "settings" .= openIdConnectApplicationSettings
      ]


-- | Construct a value of type 'OpenIdConnectApplication' (by applying it's required fields, if any)
mkOpenIdConnectApplication
  :: OpenIdConnectApplication
mkOpenIdConnectApplication =
  OpenIdConnectApplication
  { openIdConnectApplicationCredentials = Nothing
  , openIdConnectApplicationName = Nothing
  , openIdConnectApplicationSettings = Nothing
  }

-- ** OpenIdConnectApplicationSettings
-- | OpenIdConnectApplicationSettings
data OpenIdConnectApplicationSettings = OpenIdConnectApplicationSettings
  { openIdConnectApplicationSettingsOauthClient :: !(Maybe OpenIdConnectApplicationSettingsClient) -- ^ "oauthClient"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationSettings
instance A.FromJSON OpenIdConnectApplicationSettings where
  parseJSON = A.withObject "OpenIdConnectApplicationSettings" $ \o ->
    OpenIdConnectApplicationSettings
      <$> (o .:? "oauthClient")

-- | ToJSON OpenIdConnectApplicationSettings
instance A.ToJSON OpenIdConnectApplicationSettings where
  toJSON OpenIdConnectApplicationSettings {..} =
   _omitNulls
      [ "oauthClient" .= openIdConnectApplicationSettingsOauthClient
      ]


-- | Construct a value of type 'OpenIdConnectApplicationSettings' (by applying it's required fields, if any)
mkOpenIdConnectApplicationSettings
  :: OpenIdConnectApplicationSettings
mkOpenIdConnectApplicationSettings =
  OpenIdConnectApplicationSettings
  { openIdConnectApplicationSettingsOauthClient = Nothing
  }

-- ** OpenIdConnectApplicationSettingsClient
-- | OpenIdConnectApplicationSettingsClient
data OpenIdConnectApplicationSettingsClient = OpenIdConnectApplicationSettingsClient
  { openIdConnectApplicationSettingsClientApplicationType :: !(Maybe OpenIdConnectApplicationType) -- ^ "application_type"
  , openIdConnectApplicationSettingsClientClientUri :: !(Maybe Text) -- ^ "client_uri"
  , openIdConnectApplicationSettingsClientConsentMethod :: !(Maybe OpenIdConnectApplicationConsentMethod) -- ^ "consent_method"
  , openIdConnectApplicationSettingsClientGrantTypes :: !(Maybe [OAuthGrantType]) -- ^ "grant_types"
  , openIdConnectApplicationSettingsClientLogoUri :: !(Maybe Text) -- ^ "logo_uri"
  , openIdConnectApplicationSettingsClientPolicyUri :: !(Maybe Text) -- ^ "policy_uri"
  , openIdConnectApplicationSettingsClientRedirectUris :: !(Maybe [Text]) -- ^ "redirect_uris"
  , openIdConnectApplicationSettingsClientResponseTypes :: !(Maybe [OAuthResponseType]) -- ^ "response_types"
  , openIdConnectApplicationSettingsClientTosUri :: !(Maybe Text) -- ^ "tos_uri"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenIdConnectApplicationSettingsClient
instance A.FromJSON OpenIdConnectApplicationSettingsClient where
  parseJSON = A.withObject "OpenIdConnectApplicationSettingsClient" $ \o ->
    OpenIdConnectApplicationSettingsClient
      <$> (o .:? "application_type")
      <*> (o .:? "client_uri")
      <*> (o .:? "consent_method")
      <*> (o .:? "grant_types")
      <*> (o .:? "logo_uri")
      <*> (o .:? "policy_uri")
      <*> (o .:? "redirect_uris")
      <*> (o .:? "response_types")
      <*> (o .:? "tos_uri")

-- | ToJSON OpenIdConnectApplicationSettingsClient
instance A.ToJSON OpenIdConnectApplicationSettingsClient where
  toJSON OpenIdConnectApplicationSettingsClient {..} =
   _omitNulls
      [ "application_type" .= openIdConnectApplicationSettingsClientApplicationType
      , "client_uri" .= openIdConnectApplicationSettingsClientClientUri
      , "consent_method" .= openIdConnectApplicationSettingsClientConsentMethod
      , "grant_types" .= openIdConnectApplicationSettingsClientGrantTypes
      , "logo_uri" .= openIdConnectApplicationSettingsClientLogoUri
      , "policy_uri" .= openIdConnectApplicationSettingsClientPolicyUri
      , "redirect_uris" .= openIdConnectApplicationSettingsClientRedirectUris
      , "response_types" .= openIdConnectApplicationSettingsClientResponseTypes
      , "tos_uri" .= openIdConnectApplicationSettingsClientTosUri
      ]


-- | Construct a value of type 'OpenIdConnectApplicationSettingsClient' (by applying it's required fields, if any)
mkOpenIdConnectApplicationSettingsClient
  :: OpenIdConnectApplicationSettingsClient
mkOpenIdConnectApplicationSettingsClient =
  OpenIdConnectApplicationSettingsClient
  { openIdConnectApplicationSettingsClientApplicationType = Nothing
  , openIdConnectApplicationSettingsClientClientUri = Nothing
  , openIdConnectApplicationSettingsClientConsentMethod = Nothing
  , openIdConnectApplicationSettingsClientGrantTypes = Nothing
  , openIdConnectApplicationSettingsClientLogoUri = Nothing
  , openIdConnectApplicationSettingsClientPolicyUri = Nothing
  , openIdConnectApplicationSettingsClientRedirectUris = Nothing
  , openIdConnectApplicationSettingsClientResponseTypes = Nothing
  , openIdConnectApplicationSettingsClientTosUri = Nothing
  }

-- ** PasswordCredential
-- | PasswordCredential
data PasswordCredential = PasswordCredential
  { passwordCredentialValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PasswordCredential
instance A.FromJSON PasswordCredential where
  parseJSON = A.withObject "PasswordCredential" $ \o ->
    PasswordCredential
      <$> (o .:? "value")

-- | ToJSON PasswordCredential
instance A.ToJSON PasswordCredential where
  toJSON PasswordCredential {..} =
   _omitNulls
      [ "value" .= passwordCredentialValue
      ]


-- | Construct a value of type 'PasswordCredential' (by applying it's required fields, if any)
mkPasswordCredential
  :: PasswordCredential
mkPasswordCredential =
  PasswordCredential
  { passwordCredentialValue = Nothing
  }

-- ** PushFactor
-- | PushFactor
data PushFactor = PushFactor
  { pushFactorProfile :: !(Maybe PushFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushFactor
instance A.FromJSON PushFactor where
  parseJSON = A.withObject "PushFactor" $ \o ->
    PushFactor
      <$> (o .:? "profile")

-- | ToJSON PushFactor
instance A.ToJSON PushFactor where
  toJSON PushFactor {..} =
   _omitNulls
      [ "profile" .= pushFactorProfile
      ]


-- | Construct a value of type 'PushFactor' (by applying it's required fields, if any)
mkPushFactor
  :: PushFactor
mkPushFactor =
  PushFactor
  { pushFactorProfile = Nothing
  }

-- ** PushFactorProfile
-- | PushFactorProfile
data PushFactorProfile = PushFactorProfile
  { pushFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  , pushFactorProfileDeviceType :: !(Maybe Text) -- ^ "deviceType"
  , pushFactorProfileName :: !(Maybe Text) -- ^ "name"
  , pushFactorProfilePlatform :: !(Maybe Text) -- ^ "platform"
  , pushFactorProfileVersion :: !(Maybe Text) -- ^ "version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushFactorProfile
instance A.FromJSON PushFactorProfile where
  parseJSON = A.withObject "PushFactorProfile" $ \o ->
    PushFactorProfile
      <$> (o .:? "credentialId")
      <*> (o .:? "deviceType")
      <*> (o .:? "name")
      <*> (o .:? "platform")
      <*> (o .:? "version")

-- | ToJSON PushFactorProfile
instance A.ToJSON PushFactorProfile where
  toJSON PushFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= pushFactorProfileCredentialId
      , "deviceType" .= pushFactorProfileDeviceType
      , "name" .= pushFactorProfileName
      , "platform" .= pushFactorProfilePlatform
      , "version" .= pushFactorProfileVersion
      ]


-- | Construct a value of type 'PushFactorProfile' (by applying it's required fields, if any)
mkPushFactorProfile
  :: PushFactorProfile
mkPushFactorProfile =
  PushFactorProfile
  { pushFactorProfileCredentialId = Nothing
  , pushFactorProfileDeviceType = Nothing
  , pushFactorProfileName = Nothing
  , pushFactorProfilePlatform = Nothing
  , pushFactorProfileVersion = Nothing
  }

-- ** RecoveryQuestionCredential
-- | RecoveryQuestionCredential
data RecoveryQuestionCredential = RecoveryQuestionCredential
  { recoveryQuestionCredentialAnswer :: !(Maybe Text) -- ^ "answer"
  , recoveryQuestionCredentialQuestion :: !(Maybe Text) -- ^ "question"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RecoveryQuestionCredential
instance A.FromJSON RecoveryQuestionCredential where
  parseJSON = A.withObject "RecoveryQuestionCredential" $ \o ->
    RecoveryQuestionCredential
      <$> (o .:? "answer")
      <*> (o .:? "question")

-- | ToJSON RecoveryQuestionCredential
instance A.ToJSON RecoveryQuestionCredential where
  toJSON RecoveryQuestionCredential {..} =
   _omitNulls
      [ "answer" .= recoveryQuestionCredentialAnswer
      , "question" .= recoveryQuestionCredentialQuestion
      ]


-- | Construct a value of type 'RecoveryQuestionCredential' (by applying it's required fields, if any)
mkRecoveryQuestionCredential
  :: RecoveryQuestionCredential
mkRecoveryQuestionCredential =
  RecoveryQuestionCredential
  { recoveryQuestionCredentialAnswer = Nothing
  , recoveryQuestionCredentialQuestion = Nothing
  }

-- ** ResetPasswordToken
-- | ResetPasswordToken
data ResetPasswordToken = ResetPasswordToken
  { resetPasswordTokenResetPasswordUrl :: !(Maybe Text) -- ^ "resetPasswordUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResetPasswordToken
instance A.FromJSON ResetPasswordToken where
  parseJSON = A.withObject "ResetPasswordToken" $ \o ->
    ResetPasswordToken
      <$> (o .:? "resetPasswordUrl")

-- | ToJSON ResetPasswordToken
instance A.ToJSON ResetPasswordToken where
  toJSON ResetPasswordToken {..} =
   _omitNulls
      [ "resetPasswordUrl" .= resetPasswordTokenResetPasswordUrl
      ]


-- | Construct a value of type 'ResetPasswordToken' (by applying it's required fields, if any)
mkResetPasswordToken
  :: ResetPasswordToken
mkResetPasswordToken =
  ResetPasswordToken
  { resetPasswordTokenResetPasswordUrl = Nothing
  }

-- ** Role
-- | Role
data Role = Role
  { roleEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , roleCreated :: !(Maybe DateTime) -- ^ "created"
  , roleDescription :: !(Maybe Text) -- ^ "description"
  , roleId :: !(Maybe Text) -- ^ "id"
  , roleLabel :: !(Maybe Text) -- ^ "label"
  , roleLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , roleStatus :: !(Maybe RoleStatus) -- ^ "status"
  , roleType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Role
instance A.FromJSON Role where
  parseJSON = A.withObject "Role" $ \o ->
    Role
      <$> (o .:? "_embedded")
      <*> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "label")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "status")
      <*> (o .:? "type")

-- | ToJSON Role
instance A.ToJSON Role where
  toJSON Role {..} =
   _omitNulls
      [ "_embedded" .= roleEmbedded
      , "created" .= roleCreated
      , "description" .= roleDescription
      , "id" .= roleId
      , "label" .= roleLabel
      , "lastUpdated" .= roleLastUpdated
      , "status" .= roleStatus
      , "type" .= roleType
      ]


-- | Construct a value of type 'Role' (by applying it's required fields, if any)
mkRole
  :: Role
mkRole =
  Role
  { roleEmbedded = Nothing
  , roleCreated = Nothing
  , roleDescription = Nothing
  , roleId = Nothing
  , roleLabel = Nothing
  , roleLastUpdated = Nothing
  , roleStatus = Nothing
  , roleType = Nothing
  }

-- ** SamlApplication
-- | SamlApplication
data SamlApplication = SamlApplication
  { samlApplicationSettings :: !(Maybe SamlApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlApplication
instance A.FromJSON SamlApplication where
  parseJSON = A.withObject "SamlApplication" $ \o ->
    SamlApplication
      <$> (o .:? "settings")

-- | ToJSON SamlApplication
instance A.ToJSON SamlApplication where
  toJSON SamlApplication {..} =
   _omitNulls
      [ "settings" .= samlApplicationSettings
      ]


-- | Construct a value of type 'SamlApplication' (by applying it's required fields, if any)
mkSamlApplication
  :: SamlApplication
mkSamlApplication =
  SamlApplication
  { samlApplicationSettings = Nothing
  }

-- ** SamlApplicationSettings
-- | SamlApplicationSettings
data SamlApplicationSettings = SamlApplicationSettings
  { samlApplicationSettingsSignOn :: !(Maybe SamlApplicationSettingsSignOn) -- ^ "signOn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlApplicationSettings
instance A.FromJSON SamlApplicationSettings where
  parseJSON = A.withObject "SamlApplicationSettings" $ \o ->
    SamlApplicationSettings
      <$> (o .:? "signOn")

-- | ToJSON SamlApplicationSettings
instance A.ToJSON SamlApplicationSettings where
  toJSON SamlApplicationSettings {..} =
   _omitNulls
      [ "signOn" .= samlApplicationSettingsSignOn
      ]


-- | Construct a value of type 'SamlApplicationSettings' (by applying it's required fields, if any)
mkSamlApplicationSettings
  :: SamlApplicationSettings
mkSamlApplicationSettings =
  SamlApplicationSettings
  { samlApplicationSettingsSignOn = Nothing
  }

-- ** SamlApplicationSettingsSignOn
-- | SamlApplicationSettingsSignOn
data SamlApplicationSettingsSignOn = SamlApplicationSettingsSignOn
  { samlApplicationSettingsSignOnAssertionSigned :: !(Maybe Bool) -- ^ "assertionSigned"
  , samlApplicationSettingsSignOnAttributeStatements :: !(Maybe [SamlAttributeStatement]) -- ^ "attributeStatements"
  , samlApplicationSettingsSignOnAudience :: !(Maybe Text) -- ^ "audience"
  , samlApplicationSettingsSignOnAudienceOverride :: !(Maybe Text) -- ^ "audienceOverride"
  , samlApplicationSettingsSignOnAuthnContextClassRef :: !(Maybe Text) -- ^ "authnContextClassRef"
  , samlApplicationSettingsSignOnDefaultRelayState :: !(Maybe Text) -- ^ "defaultRelayState"
  , samlApplicationSettingsSignOnDestination :: !(Maybe Text) -- ^ "destination"
  , samlApplicationSettingsSignOnDestinationOverride :: !(Maybe Text) -- ^ "destinationOverride"
  , samlApplicationSettingsSignOnDigestAlgorithm :: !(Maybe Text) -- ^ "digestAlgorithm"
  , samlApplicationSettingsSignOnHonorForceAuthn :: !(Maybe Bool) -- ^ "honorForceAuthn"
  , samlApplicationSettingsSignOnIdpIssuer :: !(Maybe Text) -- ^ "idpIssuer"
  , samlApplicationSettingsSignOnRecipient :: !(Maybe Text) -- ^ "recipient"
  , samlApplicationSettingsSignOnRecipientOverride :: !(Maybe Text) -- ^ "recipientOverride"
  , samlApplicationSettingsSignOnRequestCompressed :: !(Maybe Bool) -- ^ "requestCompressed"
  , samlApplicationSettingsSignOnResponseSigned :: !(Maybe Bool) -- ^ "responseSigned"
  , samlApplicationSettingsSignOnSignatureAlgorithm :: !(Maybe Text) -- ^ "signatureAlgorithm"
  , samlApplicationSettingsSignOnSpIssuer :: !(Maybe Text) -- ^ "spIssuer"
  , samlApplicationSettingsSignOnSsoAcsUrl :: !(Maybe Text) -- ^ "ssoAcsUrl"
  , samlApplicationSettingsSignOnSsoAcsUrlOverride :: !(Maybe Text) -- ^ "ssoAcsUrlOverride"
  , samlApplicationSettingsSignOnSubjectNameIdFormat :: !(Maybe Text) -- ^ "subjectNameIdFormat"
  , samlApplicationSettingsSignOnSubjectNameIdTemplate :: !(Maybe Text) -- ^ "subjectNameIdTemplate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlApplicationSettingsSignOn
instance A.FromJSON SamlApplicationSettingsSignOn where
  parseJSON = A.withObject "SamlApplicationSettingsSignOn" $ \o ->
    SamlApplicationSettingsSignOn
      <$> (o .:? "assertionSigned")
      <*> (o .:? "attributeStatements")
      <*> (o .:? "audience")
      <*> (o .:? "audienceOverride")
      <*> (o .:? "authnContextClassRef")
      <*> (o .:? "defaultRelayState")
      <*> (o .:? "destination")
      <*> (o .:? "destinationOverride")
      <*> (o .:? "digestAlgorithm")
      <*> (o .:? "honorForceAuthn")
      <*> (o .:? "idpIssuer")
      <*> (o .:? "recipient")
      <*> (o .:? "recipientOverride")
      <*> (o .:? "requestCompressed")
      <*> (o .:? "responseSigned")
      <*> (o .:? "signatureAlgorithm")
      <*> (o .:? "spIssuer")
      <*> (o .:? "ssoAcsUrl")
      <*> (o .:? "ssoAcsUrlOverride")
      <*> (o .:? "subjectNameIdFormat")
      <*> (o .:? "subjectNameIdTemplate")

-- | ToJSON SamlApplicationSettingsSignOn
instance A.ToJSON SamlApplicationSettingsSignOn where
  toJSON SamlApplicationSettingsSignOn {..} =
   _omitNulls
      [ "assertionSigned" .= samlApplicationSettingsSignOnAssertionSigned
      , "attributeStatements" .= samlApplicationSettingsSignOnAttributeStatements
      , "audience" .= samlApplicationSettingsSignOnAudience
      , "audienceOverride" .= samlApplicationSettingsSignOnAudienceOverride
      , "authnContextClassRef" .= samlApplicationSettingsSignOnAuthnContextClassRef
      , "defaultRelayState" .= samlApplicationSettingsSignOnDefaultRelayState
      , "destination" .= samlApplicationSettingsSignOnDestination
      , "destinationOverride" .= samlApplicationSettingsSignOnDestinationOverride
      , "digestAlgorithm" .= samlApplicationSettingsSignOnDigestAlgorithm
      , "honorForceAuthn" .= samlApplicationSettingsSignOnHonorForceAuthn
      , "idpIssuer" .= samlApplicationSettingsSignOnIdpIssuer
      , "recipient" .= samlApplicationSettingsSignOnRecipient
      , "recipientOverride" .= samlApplicationSettingsSignOnRecipientOverride
      , "requestCompressed" .= samlApplicationSettingsSignOnRequestCompressed
      , "responseSigned" .= samlApplicationSettingsSignOnResponseSigned
      , "signatureAlgorithm" .= samlApplicationSettingsSignOnSignatureAlgorithm
      , "spIssuer" .= samlApplicationSettingsSignOnSpIssuer
      , "ssoAcsUrl" .= samlApplicationSettingsSignOnSsoAcsUrl
      , "ssoAcsUrlOverride" .= samlApplicationSettingsSignOnSsoAcsUrlOverride
      , "subjectNameIdFormat" .= samlApplicationSettingsSignOnSubjectNameIdFormat
      , "subjectNameIdTemplate" .= samlApplicationSettingsSignOnSubjectNameIdTemplate
      ]


-- | Construct a value of type 'SamlApplicationSettingsSignOn' (by applying it's required fields, if any)
mkSamlApplicationSettingsSignOn
  :: SamlApplicationSettingsSignOn
mkSamlApplicationSettingsSignOn =
  SamlApplicationSettingsSignOn
  { samlApplicationSettingsSignOnAssertionSigned = Nothing
  , samlApplicationSettingsSignOnAttributeStatements = Nothing
  , samlApplicationSettingsSignOnAudience = Nothing
  , samlApplicationSettingsSignOnAudienceOverride = Nothing
  , samlApplicationSettingsSignOnAuthnContextClassRef = Nothing
  , samlApplicationSettingsSignOnDefaultRelayState = Nothing
  , samlApplicationSettingsSignOnDestination = Nothing
  , samlApplicationSettingsSignOnDestinationOverride = Nothing
  , samlApplicationSettingsSignOnDigestAlgorithm = Nothing
  , samlApplicationSettingsSignOnHonorForceAuthn = Nothing
  , samlApplicationSettingsSignOnIdpIssuer = Nothing
  , samlApplicationSettingsSignOnRecipient = Nothing
  , samlApplicationSettingsSignOnRecipientOverride = Nothing
  , samlApplicationSettingsSignOnRequestCompressed = Nothing
  , samlApplicationSettingsSignOnResponseSigned = Nothing
  , samlApplicationSettingsSignOnSignatureAlgorithm = Nothing
  , samlApplicationSettingsSignOnSpIssuer = Nothing
  , samlApplicationSettingsSignOnSsoAcsUrl = Nothing
  , samlApplicationSettingsSignOnSsoAcsUrlOverride = Nothing
  , samlApplicationSettingsSignOnSubjectNameIdFormat = Nothing
  , samlApplicationSettingsSignOnSubjectNameIdTemplate = Nothing
  }

-- ** SamlAttributeStatement
-- | SamlAttributeStatement
data SamlAttributeStatement = SamlAttributeStatement
  { samlAttributeStatementName :: !(Maybe Text) -- ^ "name"
  , samlAttributeStatementNamespace :: !(Maybe Text) -- ^ "namespace"
  , samlAttributeStatementType :: !(Maybe Text) -- ^ "type"
  , samlAttributeStatementValues :: !(Maybe [Text]) -- ^ "values"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SamlAttributeStatement
instance A.FromJSON SamlAttributeStatement where
  parseJSON = A.withObject "SamlAttributeStatement" $ \o ->
    SamlAttributeStatement
      <$> (o .:? "name")
      <*> (o .:? "namespace")
      <*> (o .:? "type")
      <*> (o .:? "values")

-- | ToJSON SamlAttributeStatement
instance A.ToJSON SamlAttributeStatement where
  toJSON SamlAttributeStatement {..} =
   _omitNulls
      [ "name" .= samlAttributeStatementName
      , "namespace" .= samlAttributeStatementNamespace
      , "type" .= samlAttributeStatementType
      , "values" .= samlAttributeStatementValues
      ]


-- | Construct a value of type 'SamlAttributeStatement' (by applying it's required fields, if any)
mkSamlAttributeStatement
  :: SamlAttributeStatement
mkSamlAttributeStatement =
  SamlAttributeStatement
  { samlAttributeStatementName = Nothing
  , samlAttributeStatementNamespace = Nothing
  , samlAttributeStatementType = Nothing
  , samlAttributeStatementValues = Nothing
  }

-- ** SchemeApplicationCredentials
-- | SchemeApplicationCredentials
data SchemeApplicationCredentials = SchemeApplicationCredentials
  { schemeApplicationCredentialsPassword :: !(Maybe PasswordCredential) -- ^ "password"
  , schemeApplicationCredentialsRevealPassword :: !(Maybe Bool) -- ^ "revealPassword"
  , schemeApplicationCredentialsScheme :: !(Maybe ApplicationCredentialsScheme) -- ^ "scheme"
  , schemeApplicationCredentialsSigning :: !(Maybe ApplicationCredentialsSigning) -- ^ "signing"
  , schemeApplicationCredentialsUserName :: !(Maybe Text) -- ^ "userName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SchemeApplicationCredentials
instance A.FromJSON SchemeApplicationCredentials where
  parseJSON = A.withObject "SchemeApplicationCredentials" $ \o ->
    SchemeApplicationCredentials
      <$> (o .:? "password")
      <*> (o .:? "revealPassword")
      <*> (o .:? "scheme")
      <*> (o .:? "signing")
      <*> (o .:? "userName")

-- | ToJSON SchemeApplicationCredentials
instance A.ToJSON SchemeApplicationCredentials where
  toJSON SchemeApplicationCredentials {..} =
   _omitNulls
      [ "password" .= schemeApplicationCredentialsPassword
      , "revealPassword" .= schemeApplicationCredentialsRevealPassword
      , "scheme" .= schemeApplicationCredentialsScheme
      , "signing" .= schemeApplicationCredentialsSigning
      , "userName" .= schemeApplicationCredentialsUserName
      ]


-- | Construct a value of type 'SchemeApplicationCredentials' (by applying it's required fields, if any)
mkSchemeApplicationCredentials
  :: SchemeApplicationCredentials
mkSchemeApplicationCredentials =
  SchemeApplicationCredentials
  { schemeApplicationCredentialsPassword = Nothing
  , schemeApplicationCredentialsRevealPassword = Nothing
  , schemeApplicationCredentialsScheme = Nothing
  , schemeApplicationCredentialsSigning = Nothing
  , schemeApplicationCredentialsUserName = Nothing
  }

-- ** SecurePasswordStoreApplication
-- | SecurePasswordStoreApplication
data SecurePasswordStoreApplication = SecurePasswordStoreApplication
  { securePasswordStoreApplicationCredentials :: !(Maybe SchemeApplicationCredentials) -- ^ "credentials"
  , securePasswordStoreApplicationName :: !(Maybe A.Value) -- ^ "name"
  , securePasswordStoreApplicationSettings :: !(Maybe SecurePasswordStoreApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurePasswordStoreApplication
instance A.FromJSON SecurePasswordStoreApplication where
  parseJSON = A.withObject "SecurePasswordStoreApplication" $ \o ->
    SecurePasswordStoreApplication
      <$> (o .:? "credentials")
      <*> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON SecurePasswordStoreApplication
instance A.ToJSON SecurePasswordStoreApplication where
  toJSON SecurePasswordStoreApplication {..} =
   _omitNulls
      [ "credentials" .= securePasswordStoreApplicationCredentials
      , "name" .= securePasswordStoreApplicationName
      , "settings" .= securePasswordStoreApplicationSettings
      ]


-- | Construct a value of type 'SecurePasswordStoreApplication' (by applying it's required fields, if any)
mkSecurePasswordStoreApplication
  :: SecurePasswordStoreApplication
mkSecurePasswordStoreApplication =
  SecurePasswordStoreApplication
  { securePasswordStoreApplicationCredentials = Nothing
  , securePasswordStoreApplicationName = Nothing
  , securePasswordStoreApplicationSettings = Nothing
  }

-- ** SecurePasswordStoreApplicationSettings
-- | SecurePasswordStoreApplicationSettings
data SecurePasswordStoreApplicationSettings = SecurePasswordStoreApplicationSettings
  { securePasswordStoreApplicationSettingsApp :: !(Maybe SecurePasswordStoreApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurePasswordStoreApplicationSettings
instance A.FromJSON SecurePasswordStoreApplicationSettings where
  parseJSON = A.withObject "SecurePasswordStoreApplicationSettings" $ \o ->
    SecurePasswordStoreApplicationSettings
      <$> (o .:? "app")

-- | ToJSON SecurePasswordStoreApplicationSettings
instance A.ToJSON SecurePasswordStoreApplicationSettings where
  toJSON SecurePasswordStoreApplicationSettings {..} =
   _omitNulls
      [ "app" .= securePasswordStoreApplicationSettingsApp
      ]


-- | Construct a value of type 'SecurePasswordStoreApplicationSettings' (by applying it's required fields, if any)
mkSecurePasswordStoreApplicationSettings
  :: SecurePasswordStoreApplicationSettings
mkSecurePasswordStoreApplicationSettings =
  SecurePasswordStoreApplicationSettings
  { securePasswordStoreApplicationSettingsApp = Nothing
  }

-- ** SecurePasswordStoreApplicationSettingsApplication
-- | SecurePasswordStoreApplicationSettingsApplication
data SecurePasswordStoreApplicationSettingsApplication = SecurePasswordStoreApplicationSettingsApplication
  { securePasswordStoreApplicationSettingsApplicationOptionalField1 :: !(Maybe Text) -- ^ "optionalField1"
  , securePasswordStoreApplicationSettingsApplicationOptionalField1Value :: !(Maybe Text) -- ^ "optionalField1Value"
  , securePasswordStoreApplicationSettingsApplicationOptionalField2 :: !(Maybe Text) -- ^ "optionalField2"
  , securePasswordStoreApplicationSettingsApplicationOptionalField2Value :: !(Maybe Text) -- ^ "optionalField2Value"
  , securePasswordStoreApplicationSettingsApplicationOptionalField3 :: !(Maybe Text) -- ^ "optionalField3"
  , securePasswordStoreApplicationSettingsApplicationOptionalField3Value :: !(Maybe Text) -- ^ "optionalField3Value"
  , securePasswordStoreApplicationSettingsApplicationPasswordField :: !(Maybe Text) -- ^ "passwordField"
  , securePasswordStoreApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  , securePasswordStoreApplicationSettingsApplicationUsernameField :: !(Maybe Text) -- ^ "usernameField"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurePasswordStoreApplicationSettingsApplication
instance A.FromJSON SecurePasswordStoreApplicationSettingsApplication where
  parseJSON = A.withObject "SecurePasswordStoreApplicationSettingsApplication" $ \o ->
    SecurePasswordStoreApplicationSettingsApplication
      <$> (o .:? "optionalField1")
      <*> (o .:? "optionalField1Value")
      <*> (o .:? "optionalField2")
      <*> (o .:? "optionalField2Value")
      <*> (o .:? "optionalField3")
      <*> (o .:? "optionalField3Value")
      <*> (o .:? "passwordField")
      <*> (o .:? "url")
      <*> (o .:? "usernameField")

-- | ToJSON SecurePasswordStoreApplicationSettingsApplication
instance A.ToJSON SecurePasswordStoreApplicationSettingsApplication where
  toJSON SecurePasswordStoreApplicationSettingsApplication {..} =
   _omitNulls
      [ "optionalField1" .= securePasswordStoreApplicationSettingsApplicationOptionalField1
      , "optionalField1Value" .= securePasswordStoreApplicationSettingsApplicationOptionalField1Value
      , "optionalField2" .= securePasswordStoreApplicationSettingsApplicationOptionalField2
      , "optionalField2Value" .= securePasswordStoreApplicationSettingsApplicationOptionalField2Value
      , "optionalField3" .= securePasswordStoreApplicationSettingsApplicationOptionalField3
      , "optionalField3Value" .= securePasswordStoreApplicationSettingsApplicationOptionalField3Value
      , "passwordField" .= securePasswordStoreApplicationSettingsApplicationPasswordField
      , "url" .= securePasswordStoreApplicationSettingsApplicationUrl
      , "usernameField" .= securePasswordStoreApplicationSettingsApplicationUsernameField
      ]


-- | Construct a value of type 'SecurePasswordStoreApplicationSettingsApplication' (by applying it's required fields, if any)
mkSecurePasswordStoreApplicationSettingsApplication
  :: SecurePasswordStoreApplicationSettingsApplication
mkSecurePasswordStoreApplicationSettingsApplication =
  SecurePasswordStoreApplicationSettingsApplication
  { securePasswordStoreApplicationSettingsApplicationOptionalField1 = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField1Value = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField2 = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField2Value = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField3 = Nothing
  , securePasswordStoreApplicationSettingsApplicationOptionalField3Value = Nothing
  , securePasswordStoreApplicationSettingsApplicationPasswordField = Nothing
  , securePasswordStoreApplicationSettingsApplicationUrl = Nothing
  , securePasswordStoreApplicationSettingsApplicationUsernameField = Nothing
  }

-- ** SecurityQuestion
-- | SecurityQuestion
data SecurityQuestion = SecurityQuestion
  { securityQuestionAnswer :: !(Maybe Text) -- ^ "answer"
  , securityQuestionQuestion :: !(Maybe Text) -- ^ "question"
  , securityQuestionQuestionText :: !(Maybe Text) -- ^ "questionText"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestion
instance A.FromJSON SecurityQuestion where
  parseJSON = A.withObject "SecurityQuestion" $ \o ->
    SecurityQuestion
      <$> (o .:? "answer")
      <*> (o .:? "question")
      <*> (o .:? "questionText")

-- | ToJSON SecurityQuestion
instance A.ToJSON SecurityQuestion where
  toJSON SecurityQuestion {..} =
   _omitNulls
      [ "answer" .= securityQuestionAnswer
      , "question" .= securityQuestionQuestion
      , "questionText" .= securityQuestionQuestionText
      ]


-- | Construct a value of type 'SecurityQuestion' (by applying it's required fields, if any)
mkSecurityQuestion
  :: SecurityQuestion
mkSecurityQuestion =
  SecurityQuestion
  { securityQuestionAnswer = Nothing
  , securityQuestionQuestion = Nothing
  , securityQuestionQuestionText = Nothing
  }

-- ** SecurityQuestionFactor
-- | SecurityQuestionFactor
data SecurityQuestionFactor = SecurityQuestionFactor
  { securityQuestionFactorProfile :: !(Maybe SecurityQuestionFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestionFactor
instance A.FromJSON SecurityQuestionFactor where
  parseJSON = A.withObject "SecurityQuestionFactor" $ \o ->
    SecurityQuestionFactor
      <$> (o .:? "profile")

-- | ToJSON SecurityQuestionFactor
instance A.ToJSON SecurityQuestionFactor where
  toJSON SecurityQuestionFactor {..} =
   _omitNulls
      [ "profile" .= securityQuestionFactorProfile
      ]


-- | Construct a value of type 'SecurityQuestionFactor' (by applying it's required fields, if any)
mkSecurityQuestionFactor
  :: SecurityQuestionFactor
mkSecurityQuestionFactor =
  SecurityQuestionFactor
  { securityQuestionFactorProfile = Nothing
  }

-- ** SecurityQuestionFactorProfile
-- | SecurityQuestionFactorProfile
data SecurityQuestionFactorProfile = SecurityQuestionFactorProfile
  { securityQuestionFactorProfileAnswer :: !(Maybe Text) -- ^ "answer"
  , securityQuestionFactorProfileQuestion :: !(Maybe Text) -- ^ "question"
  , securityQuestionFactorProfileQuestionText :: !(Maybe Text) -- ^ "questionText"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecurityQuestionFactorProfile
instance A.FromJSON SecurityQuestionFactorProfile where
  parseJSON = A.withObject "SecurityQuestionFactorProfile" $ \o ->
    SecurityQuestionFactorProfile
      <$> (o .:? "answer")
      <*> (o .:? "question")
      <*> (o .:? "questionText")

-- | ToJSON SecurityQuestionFactorProfile
instance A.ToJSON SecurityQuestionFactorProfile where
  toJSON SecurityQuestionFactorProfile {..} =
   _omitNulls
      [ "answer" .= securityQuestionFactorProfileAnswer
      , "question" .= securityQuestionFactorProfileQuestion
      , "questionText" .= securityQuestionFactorProfileQuestionText
      ]


-- | Construct a value of type 'SecurityQuestionFactorProfile' (by applying it's required fields, if any)
mkSecurityQuestionFactorProfile
  :: SecurityQuestionFactorProfile
mkSecurityQuestionFactorProfile =
  SecurityQuestionFactorProfile
  { securityQuestionFactorProfileAnswer = Nothing
  , securityQuestionFactorProfileQuestion = Nothing
  , securityQuestionFactorProfileQuestionText = Nothing
  }

-- ** Session
-- | Session
data Session = Session
  { sessionLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , sessionAmr :: !(Maybe [SessionAuthenticationMethod]) -- ^ "amr"
  , sessionCreatedAt :: !(Maybe DateTime) -- ^ "createdAt"
  , sessionExpiresAt :: !(Maybe DateTime) -- ^ "expiresAt"
  , sessionId :: !(Maybe Text) -- ^ "id"
  , sessionIdp :: !(Maybe SessionIdentityProvider) -- ^ "idp"
  , sessionLastFactorVerification :: !(Maybe DateTime) -- ^ "lastFactorVerification"
  , sessionLastPasswordVerification :: !(Maybe DateTime) -- ^ "lastPasswordVerification"
  , sessionLogin :: !(Maybe Text) -- ^ "login"
  , sessionStatus :: !(Maybe SessionStatus) -- ^ "status"
  , sessionUserId :: !(Maybe Text) -- ^ "userId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Session
instance A.FromJSON Session where
  parseJSON = A.withObject "Session" $ \o ->
    Session
      <$> (o .:? "_links")
      <*> (o .:? "amr")
      <*> (o .:? "createdAt")
      <*> (o .:? "expiresAt")
      <*> (o .:? "id")
      <*> (o .:? "idp")
      <*> (o .:? "lastFactorVerification")
      <*> (o .:? "lastPasswordVerification")
      <*> (o .:? "login")
      <*> (o .:? "status")
      <*> (o .:? "userId")

-- | ToJSON Session
instance A.ToJSON Session where
  toJSON Session {..} =
   _omitNulls
      [ "_links" .= sessionLinks
      , "amr" .= sessionAmr
      , "createdAt" .= sessionCreatedAt
      , "expiresAt" .= sessionExpiresAt
      , "id" .= sessionId
      , "idp" .= sessionIdp
      , "lastFactorVerification" .= sessionLastFactorVerification
      , "lastPasswordVerification" .= sessionLastPasswordVerification
      , "login" .= sessionLogin
      , "status" .= sessionStatus
      , "userId" .= sessionUserId
      ]


-- | Construct a value of type 'Session' (by applying it's required fields, if any)
mkSession
  :: Session
mkSession =
  Session
  { sessionLinks = Nothing
  , sessionAmr = Nothing
  , sessionCreatedAt = Nothing
  , sessionExpiresAt = Nothing
  , sessionId = Nothing
  , sessionIdp = Nothing
  , sessionLastFactorVerification = Nothing
  , sessionLastPasswordVerification = Nothing
  , sessionLogin = Nothing
  , sessionStatus = Nothing
  , sessionUserId = Nothing
  }

-- ** SessionIdentityProvider
-- | SessionIdentityProvider
data SessionIdentityProvider = SessionIdentityProvider
  { sessionIdentityProviderId :: !(Maybe Text) -- ^ "id"
  , sessionIdentityProviderType :: !(Maybe SessionIdentityProviderType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SessionIdentityProvider
instance A.FromJSON SessionIdentityProvider where
  parseJSON = A.withObject "SessionIdentityProvider" $ \o ->
    SessionIdentityProvider
      <$> (o .:? "id")
      <*> (o .:? "type")

-- | ToJSON SessionIdentityProvider
instance A.ToJSON SessionIdentityProvider where
  toJSON SessionIdentityProvider {..} =
   _omitNulls
      [ "id" .= sessionIdentityProviderId
      , "type" .= sessionIdentityProviderType
      ]


-- | Construct a value of type 'SessionIdentityProvider' (by applying it's required fields, if any)
mkSessionIdentityProvider
  :: SessionIdentityProvider
mkSessionIdentityProvider =
  SessionIdentityProvider
  { sessionIdentityProviderId = Nothing
  , sessionIdentityProviderType = Nothing
  }

-- ** SmsFactor
-- | SmsFactor
data SmsFactor = SmsFactor
  { smsFactorProfile :: !(Maybe SmsFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmsFactor
instance A.FromJSON SmsFactor where
  parseJSON = A.withObject "SmsFactor" $ \o ->
    SmsFactor
      <$> (o .:? "profile")

-- | ToJSON SmsFactor
instance A.ToJSON SmsFactor where
  toJSON SmsFactor {..} =
   _omitNulls
      [ "profile" .= smsFactorProfile
      ]


-- | Construct a value of type 'SmsFactor' (by applying it's required fields, if any)
mkSmsFactor
  :: SmsFactor
mkSmsFactor =
  SmsFactor
  { smsFactorProfile = Nothing
  }

-- ** SmsFactorProfile
-- | SmsFactorProfile
data SmsFactorProfile = SmsFactorProfile
  { smsFactorProfilePhoneNumber :: !(Maybe Text) -- ^ "phoneNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmsFactorProfile
instance A.FromJSON SmsFactorProfile where
  parseJSON = A.withObject "SmsFactorProfile" $ \o ->
    SmsFactorProfile
      <$> (o .:? "phoneNumber")

-- | ToJSON SmsFactorProfile
instance A.ToJSON SmsFactorProfile where
  toJSON SmsFactorProfile {..} =
   _omitNulls
      [ "phoneNumber" .= smsFactorProfilePhoneNumber
      ]


-- | Construct a value of type 'SmsFactorProfile' (by applying it's required fields, if any)
mkSmsFactorProfile
  :: SmsFactorProfile
mkSmsFactorProfile =
  SmsFactorProfile
  { smsFactorProfilePhoneNumber = Nothing
  }

-- ** SwaApplication
-- | SwaApplication
data SwaApplication = SwaApplication
  { swaApplicationName :: !(Maybe A.Value) -- ^ "name"
  , swaApplicationSettings :: !(Maybe SwaApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaApplication
instance A.FromJSON SwaApplication where
  parseJSON = A.withObject "SwaApplication" $ \o ->
    SwaApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON SwaApplication
instance A.ToJSON SwaApplication where
  toJSON SwaApplication {..} =
   _omitNulls
      [ "name" .= swaApplicationName
      , "settings" .= swaApplicationSettings
      ]


-- | Construct a value of type 'SwaApplication' (by applying it's required fields, if any)
mkSwaApplication
  :: SwaApplication
mkSwaApplication =
  SwaApplication
  { swaApplicationName = Nothing
  , swaApplicationSettings = Nothing
  }

-- ** SwaApplicationSettings
-- | SwaApplicationSettings
data SwaApplicationSettings = SwaApplicationSettings
  { swaApplicationSettingsApp :: !(Maybe SwaApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaApplicationSettings
instance A.FromJSON SwaApplicationSettings where
  parseJSON = A.withObject "SwaApplicationSettings" $ \o ->
    SwaApplicationSettings
      <$> (o .:? "app")

-- | ToJSON SwaApplicationSettings
instance A.ToJSON SwaApplicationSettings where
  toJSON SwaApplicationSettings {..} =
   _omitNulls
      [ "app" .= swaApplicationSettingsApp
      ]


-- | Construct a value of type 'SwaApplicationSettings' (by applying it's required fields, if any)
mkSwaApplicationSettings
  :: SwaApplicationSettings
mkSwaApplicationSettings =
  SwaApplicationSettings
  { swaApplicationSettingsApp = Nothing
  }

-- ** SwaApplicationSettingsApplication
-- | SwaApplicationSettingsApplication
data SwaApplicationSettingsApplication = SwaApplicationSettingsApplication
  { swaApplicationSettingsApplicationButtonField :: !(Maybe Text) -- ^ "buttonField"
  , swaApplicationSettingsApplicationLoginUrlRegex :: !(Maybe Text) -- ^ "loginUrlRegex"
  , swaApplicationSettingsApplicationPasswordField :: !(Maybe Text) -- ^ "passwordField"
  , swaApplicationSettingsApplicationUrl :: !(Maybe Text) -- ^ "url"
  , swaApplicationSettingsApplicationUsernameField :: !(Maybe Text) -- ^ "usernameField"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaApplicationSettingsApplication
instance A.FromJSON SwaApplicationSettingsApplication where
  parseJSON = A.withObject "SwaApplicationSettingsApplication" $ \o ->
    SwaApplicationSettingsApplication
      <$> (o .:? "buttonField")
      <*> (o .:? "loginUrlRegex")
      <*> (o .:? "passwordField")
      <*> (o .:? "url")
      <*> (o .:? "usernameField")

-- | ToJSON SwaApplicationSettingsApplication
instance A.ToJSON SwaApplicationSettingsApplication where
  toJSON SwaApplicationSettingsApplication {..} =
   _omitNulls
      [ "buttonField" .= swaApplicationSettingsApplicationButtonField
      , "loginUrlRegex" .= swaApplicationSettingsApplicationLoginUrlRegex
      , "passwordField" .= swaApplicationSettingsApplicationPasswordField
      , "url" .= swaApplicationSettingsApplicationUrl
      , "usernameField" .= swaApplicationSettingsApplicationUsernameField
      ]


-- | Construct a value of type 'SwaApplicationSettingsApplication' (by applying it's required fields, if any)
mkSwaApplicationSettingsApplication
  :: SwaApplicationSettingsApplication
mkSwaApplicationSettingsApplication =
  SwaApplicationSettingsApplication
  { swaApplicationSettingsApplicationButtonField = Nothing
  , swaApplicationSettingsApplicationLoginUrlRegex = Nothing
  , swaApplicationSettingsApplicationPasswordField = Nothing
  , swaApplicationSettingsApplicationUrl = Nothing
  , swaApplicationSettingsApplicationUsernameField = Nothing
  }

-- ** SwaThreeFieldApplication
-- | SwaThreeFieldApplication
data SwaThreeFieldApplication = SwaThreeFieldApplication
  { swaThreeFieldApplicationName :: !(Maybe A.Value) -- ^ "name"
  , swaThreeFieldApplicationSettings :: !(Maybe SwaThreeFieldApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaThreeFieldApplication
instance A.FromJSON SwaThreeFieldApplication where
  parseJSON = A.withObject "SwaThreeFieldApplication" $ \o ->
    SwaThreeFieldApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON SwaThreeFieldApplication
instance A.ToJSON SwaThreeFieldApplication where
  toJSON SwaThreeFieldApplication {..} =
   _omitNulls
      [ "name" .= swaThreeFieldApplicationName
      , "settings" .= swaThreeFieldApplicationSettings
      ]


-- | Construct a value of type 'SwaThreeFieldApplication' (by applying it's required fields, if any)
mkSwaThreeFieldApplication
  :: SwaThreeFieldApplication
mkSwaThreeFieldApplication =
  SwaThreeFieldApplication
  { swaThreeFieldApplicationName = Nothing
  , swaThreeFieldApplicationSettings = Nothing
  }

-- ** SwaThreeFieldApplicationSettings
-- | SwaThreeFieldApplicationSettings
data SwaThreeFieldApplicationSettings = SwaThreeFieldApplicationSettings
  { swaThreeFieldApplicationSettingsApp :: !(Maybe SwaThreeFieldApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaThreeFieldApplicationSettings
instance A.FromJSON SwaThreeFieldApplicationSettings where
  parseJSON = A.withObject "SwaThreeFieldApplicationSettings" $ \o ->
    SwaThreeFieldApplicationSettings
      <$> (o .:? "app")

-- | ToJSON SwaThreeFieldApplicationSettings
instance A.ToJSON SwaThreeFieldApplicationSettings where
  toJSON SwaThreeFieldApplicationSettings {..} =
   _omitNulls
      [ "app" .= swaThreeFieldApplicationSettingsApp
      ]


-- | Construct a value of type 'SwaThreeFieldApplicationSettings' (by applying it's required fields, if any)
mkSwaThreeFieldApplicationSettings
  :: SwaThreeFieldApplicationSettings
mkSwaThreeFieldApplicationSettings =
  SwaThreeFieldApplicationSettings
  { swaThreeFieldApplicationSettingsApp = Nothing
  }

-- ** SwaThreeFieldApplicationSettingsApplication
-- | SwaThreeFieldApplicationSettingsApplication
data SwaThreeFieldApplicationSettingsApplication = SwaThreeFieldApplicationSettingsApplication
  { swaThreeFieldApplicationSettingsApplicationButtonSelector :: !(Maybe Text) -- ^ "buttonSelector"
  , swaThreeFieldApplicationSettingsApplicationExtraFieldSelector :: !(Maybe Text) -- ^ "extraFieldSelector"
  , swaThreeFieldApplicationSettingsApplicationExtraFieldValue :: !(Maybe Text) -- ^ "extraFieldValue"
  , swaThreeFieldApplicationSettingsApplicationLoginUrlRegex :: !(Maybe Text) -- ^ "loginUrlRegex"
  , swaThreeFieldApplicationSettingsApplicationPasswordSelector :: !(Maybe Text) -- ^ "passwordSelector"
  , swaThreeFieldApplicationSettingsApplicationTargetUrl :: !(Maybe Text) -- ^ "targetUrl"
  , swaThreeFieldApplicationSettingsApplicationUserNameSelector :: !(Maybe Text) -- ^ "userNameSelector"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwaThreeFieldApplicationSettingsApplication
instance A.FromJSON SwaThreeFieldApplicationSettingsApplication where
  parseJSON = A.withObject "SwaThreeFieldApplicationSettingsApplication" $ \o ->
    SwaThreeFieldApplicationSettingsApplication
      <$> (o .:? "buttonSelector")
      <*> (o .:? "extraFieldSelector")
      <*> (o .:? "extraFieldValue")
      <*> (o .:? "loginUrlRegex")
      <*> (o .:? "passwordSelector")
      <*> (o .:? "targetUrl")
      <*> (o .:? "userNameSelector")

-- | ToJSON SwaThreeFieldApplicationSettingsApplication
instance A.ToJSON SwaThreeFieldApplicationSettingsApplication where
  toJSON SwaThreeFieldApplicationSettingsApplication {..} =
   _omitNulls
      [ "buttonSelector" .= swaThreeFieldApplicationSettingsApplicationButtonSelector
      , "extraFieldSelector" .= swaThreeFieldApplicationSettingsApplicationExtraFieldSelector
      , "extraFieldValue" .= swaThreeFieldApplicationSettingsApplicationExtraFieldValue
      , "loginUrlRegex" .= swaThreeFieldApplicationSettingsApplicationLoginUrlRegex
      , "passwordSelector" .= swaThreeFieldApplicationSettingsApplicationPasswordSelector
      , "targetUrl" .= swaThreeFieldApplicationSettingsApplicationTargetUrl
      , "userNameSelector" .= swaThreeFieldApplicationSettingsApplicationUserNameSelector
      ]


-- | Construct a value of type 'SwaThreeFieldApplicationSettingsApplication' (by applying it's required fields, if any)
mkSwaThreeFieldApplicationSettingsApplication
  :: SwaThreeFieldApplicationSettingsApplication
mkSwaThreeFieldApplicationSettingsApplication =
  SwaThreeFieldApplicationSettingsApplication
  { swaThreeFieldApplicationSettingsApplicationButtonSelector = Nothing
  , swaThreeFieldApplicationSettingsApplicationExtraFieldSelector = Nothing
  , swaThreeFieldApplicationSettingsApplicationExtraFieldValue = Nothing
  , swaThreeFieldApplicationSettingsApplicationLoginUrlRegex = Nothing
  , swaThreeFieldApplicationSettingsApplicationPasswordSelector = Nothing
  , swaThreeFieldApplicationSettingsApplicationTargetUrl = Nothing
  , swaThreeFieldApplicationSettingsApplicationUserNameSelector = Nothing
  }

-- ** TempPassword
-- | TempPassword
data TempPassword = TempPassword
  { tempPasswordTempPassword :: !(Maybe Text) -- ^ "tempPassword"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TempPassword
instance A.FromJSON TempPassword where
  parseJSON = A.withObject "TempPassword" $ \o ->
    TempPassword
      <$> (o .:? "tempPassword")

-- | ToJSON TempPassword
instance A.ToJSON TempPassword where
  toJSON TempPassword {..} =
   _omitNulls
      [ "tempPassword" .= tempPasswordTempPassword
      ]


-- | Construct a value of type 'TempPassword' (by applying it's required fields, if any)
mkTempPassword
  :: TempPassword
mkTempPassword =
  TempPassword
  { tempPasswordTempPassword = Nothing
  }

-- ** TokenFactor
-- | TokenFactor
data TokenFactor = TokenFactor
  { tokenFactorProfile :: !(Maybe TokenFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenFactor
instance A.FromJSON TokenFactor where
  parseJSON = A.withObject "TokenFactor" $ \o ->
    TokenFactor
      <$> (o .:? "profile")

-- | ToJSON TokenFactor
instance A.ToJSON TokenFactor where
  toJSON TokenFactor {..} =
   _omitNulls
      [ "profile" .= tokenFactorProfile
      ]


-- | Construct a value of type 'TokenFactor' (by applying it's required fields, if any)
mkTokenFactor
  :: TokenFactor
mkTokenFactor =
  TokenFactor
  { tokenFactorProfile = Nothing
  }

-- ** TokenFactorProfile
-- | TokenFactorProfile
data TokenFactorProfile = TokenFactorProfile
  { tokenFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenFactorProfile
instance A.FromJSON TokenFactorProfile where
  parseJSON = A.withObject "TokenFactorProfile" $ \o ->
    TokenFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON TokenFactorProfile
instance A.ToJSON TokenFactorProfile where
  toJSON TokenFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= tokenFactorProfileCredentialId
      ]


-- | Construct a value of type 'TokenFactorProfile' (by applying it's required fields, if any)
mkTokenFactorProfile
  :: TokenFactorProfile
mkTokenFactorProfile =
  TokenFactorProfile
  { tokenFactorProfileCredentialId = Nothing
  }

-- ** TotpFactor
-- | TotpFactor
data TotpFactor = TotpFactor
  { totpFactorProfile :: !(Maybe TotpFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TotpFactor
instance A.FromJSON TotpFactor where
  parseJSON = A.withObject "TotpFactor" $ \o ->
    TotpFactor
      <$> (o .:? "profile")

-- | ToJSON TotpFactor
instance A.ToJSON TotpFactor where
  toJSON TotpFactor {..} =
   _omitNulls
      [ "profile" .= totpFactorProfile
      ]


-- | Construct a value of type 'TotpFactor' (by applying it's required fields, if any)
mkTotpFactor
  :: TotpFactor
mkTotpFactor =
  TotpFactor
  { totpFactorProfile = Nothing
  }

-- ** TotpFactorProfile
-- | TotpFactorProfile
data TotpFactorProfile = TotpFactorProfile
  { totpFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TotpFactorProfile
instance A.FromJSON TotpFactorProfile where
  parseJSON = A.withObject "TotpFactorProfile" $ \o ->
    TotpFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON TotpFactorProfile
instance A.ToJSON TotpFactorProfile where
  toJSON TotpFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= totpFactorProfileCredentialId
      ]


-- | Construct a value of type 'TotpFactorProfile' (by applying it's required fields, if any)
mkTotpFactorProfile
  :: TotpFactorProfile
mkTotpFactorProfile =
  TotpFactorProfile
  { totpFactorProfileCredentialId = Nothing
  }

-- ** U2fFactor
-- | U2fFactor
data U2fFactor = U2fFactor
  { u2fFactorProfile :: !(Maybe A.Value) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON U2fFactor
instance A.FromJSON U2fFactor where
  parseJSON = A.withObject "U2fFactor" $ \o ->
    U2fFactor
      <$> (o .:? "profile")

-- | ToJSON U2fFactor
instance A.ToJSON U2fFactor where
  toJSON U2fFactor {..} =
   _omitNulls
      [ "profile" .= u2fFactorProfile
      ]


-- | Construct a value of type 'U2fFactor' (by applying it's required fields, if any)
mkU2fFactor
  :: U2fFactor
mkU2fFactor =
  U2fFactor
  { u2fFactorProfile = Nothing
  }


-- | A quick hack to expose custom profile attributes by default
type User = UserP A.Object

-- | Access to typed original auto-generated UserProfile
type User' = UserP UserProfile

-- ** User
-- | User
data UserP p = User
  { userEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , userLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , userActivated :: !(Maybe DateTime) -- ^ "activated"
  , userCreated :: !(Maybe DateTime) -- ^ "created"
  , userCredentials :: !(Maybe UserCredentials) -- ^ "credentials"
  , userGroupIds :: !(Maybe [Text]) -- ^ "groupIds"
  , userId :: !(Maybe Text) -- ^ "id"
  , userLastLogin :: !(Maybe DateTime) -- ^ "lastLogin"
  , userLastUpdated :: !(Maybe DateTime) -- ^ "lastUpdated"
  , userPasswordChanged :: !(Maybe DateTime) -- ^ "passwordChanged"
  , userProfile :: !(Maybe p) -- ^ "profile"
  , userStatus :: !(Maybe UserStatus) -- ^ "status"
  , userStatusChanged :: !(Maybe DateTime) -- ^ "statusChanged"
  , userTransitioningToStatus :: !(Maybe UserStatus) -- ^ "transitioningToStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON p => A.FromJSON (UserP p) where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "activated")
      <*> (o .:? "created")
      <*> (o .:? "credentials")
      <*> (o .:? "groupIds")
      <*> (o .:? "id")
      <*> (o .:? "lastLogin")
      <*> (o .:? "lastUpdated")
      <*> (o .:? "passwordChanged")
      <*> (o .:? "profile")
      <*> (o .:? "status")
      <*> (o .:? "statusChanged")
      <*> (o .:? "transitioningToStatus")

-- | ToJSON User
instance A.ToJSON p => A.ToJSON (UserP p) where
  toJSON User {..} =
   _omitNulls
      [ "_embedded" .= userEmbedded
      , "_links" .= userLinks
      , "activated" .= userActivated
      , "created" .= userCreated
      , "credentials" .= userCredentials
      , "groupIds" .= userGroupIds
      , "id" .= userId
      , "lastLogin" .= userLastLogin
      , "lastUpdated" .= userLastUpdated
      , "passwordChanged" .= userPasswordChanged
      , "profile" .= userProfile
      , "status" .= userStatus
      , "statusChanged" .= userStatusChanged
      , "transitioningToStatus" .= userTransitioningToStatus
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userEmbedded = Nothing
  , userLinks = Nothing
  , userActivated = Nothing
  , userCreated = Nothing
  , userCredentials = Nothing
  , userGroupIds = Nothing
  , userId = Nothing
  , userLastLogin = Nothing
  , userLastUpdated = Nothing
  , userPasswordChanged = Nothing
  , userProfile = Nothing
  , userStatus = Nothing
  , userStatusChanged = Nothing
  , userTransitioningToStatus = Nothing
  }

-- ** UserActivationToken
-- | UserActivationToken
data UserActivationToken = UserActivationToken
  { userActivationTokenActivationToken :: !(Maybe Text) -- ^ "activationToken"
  , userActivationTokenActivationUrl :: !(Maybe Text) -- ^ "activationUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserActivationToken
instance A.FromJSON UserActivationToken where
  parseJSON = A.withObject "UserActivationToken" $ \o ->
    UserActivationToken
      <$> (o .:? "activationToken")
      <*> (o .:? "activationUrl")

-- | ToJSON UserActivationToken
instance A.ToJSON UserActivationToken where
  toJSON UserActivationToken {..} =
   _omitNulls
      [ "activationToken" .= userActivationTokenActivationToken
      , "activationUrl" .= userActivationTokenActivationUrl
      ]


-- | Construct a value of type 'UserActivationToken' (by applying it's required fields, if any)
mkUserActivationToken
  :: UserActivationToken
mkUserActivationToken =
  UserActivationToken
  { userActivationTokenActivationToken = Nothing
  , userActivationTokenActivationUrl = Nothing
  }

-- ** UserCredentials
-- | UserCredentials
data UserCredentials = UserCredentials
  { userCredentialsEmails :: !(Maybe [EmailAddress]) -- ^ "emails"
  , userCredentialsPassword :: !(Maybe PasswordCredential) -- ^ "password"
  , userCredentialsProvider :: !(Maybe AuthenticationProvider) -- ^ "provider"
  , userCredentialsRecoveryQuestion :: !(Maybe RecoveryQuestionCredential) -- ^ "recovery_question"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCredentials
instance A.FromJSON UserCredentials where
  parseJSON = A.withObject "UserCredentials" $ \o ->
    UserCredentials
      <$> (o .:? "emails")
      <*> (o .:? "password")
      <*> (o .:? "provider")
      <*> (o .:? "recovery_question")

-- | ToJSON UserCredentials
instance A.ToJSON UserCredentials where
  toJSON UserCredentials {..} =
   _omitNulls
      [ "emails" .= userCredentialsEmails
      , "password" .= userCredentialsPassword
      , "provider" .= userCredentialsProvider
      , "recovery_question" .= userCredentialsRecoveryQuestion
      ]


-- | Construct a value of type 'UserCredentials' (by applying it's required fields, if any)
mkUserCredentials
  :: UserCredentials
mkUserCredentials =
  UserCredentials
  { userCredentialsEmails = Nothing
  , userCredentialsPassword = Nothing
  , userCredentialsProvider = Nothing
  , userCredentialsRecoveryQuestion = Nothing
  }

-- ** UserProfile
-- | UserProfile
data UserProfile = UserProfile
  { userProfileEmail :: !(Maybe Text) -- ^ "email"
  , userProfileFirstName :: !(Maybe Text) -- ^ "firstName"
  , userProfileLastName :: !(Maybe Text) -- ^ "lastName"
  , userProfileLogin :: !(Maybe Text) -- ^ "login"
  , userProfileMobilePhone :: !(Maybe Text) -- ^ "mobilePhone"
  , userProfileSecondEmail :: !(Maybe Text) -- ^ "secondEmail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserProfile
instance A.FromJSON UserProfile where
  parseJSON = A.withObject "UserProfile" $ \o ->
    UserProfile
      <$> (o .:? "email")
      <*> (o .:? "firstName")
      <*> (o .:? "lastName")
      <*> (o .:? "login")
      <*> (o .:? "mobilePhone")
      <*> (o .:? "secondEmail")

-- | ToJSON UserProfile
instance A.ToJSON UserProfile where
  toJSON UserProfile {..} =
   _omitNulls
      [ "email" .= userProfileEmail
      , "firstName" .= userProfileFirstName
      , "lastName" .= userProfileLastName
      , "login" .= userProfileLogin
      , "mobilePhone" .= userProfileMobilePhone
      , "secondEmail" .= userProfileSecondEmail
      ]


-- | Construct a value of type 'UserProfile' (by applying it's required fields, if any)
mkUserProfile
  :: UserProfile
mkUserProfile =
  UserProfile
  { userProfileEmail = Nothing
  , userProfileFirstName = Nothing
  , userProfileLastName = Nothing
  , userProfileLogin = Nothing
  , userProfileMobilePhone = Nothing
  , userProfileSecondEmail = Nothing
  }

-- ** VerifyFactorRequest
-- | VerifyFactorRequest
data VerifyFactorRequest = VerifyFactorRequest
  { verifyFactorRequestActivationToken :: !(Maybe Text) -- ^ "activationToken"
  , verifyFactorRequestAnswer :: !(Maybe Text) -- ^ "answer"
  , verifyFactorRequestNextPassCode :: !(Maybe Text) -- ^ "nextPassCode"
  , verifyFactorRequestPassCode :: !(Maybe Text) -- ^ "passCode"
  , verifyFactorRequestTokenLifetimeSeconds :: !(Maybe Int) -- ^ "tokenLifetimeSeconds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyFactorRequest
instance A.FromJSON VerifyFactorRequest where
  parseJSON = A.withObject "VerifyFactorRequest" $ \o ->
    VerifyFactorRequest
      <$> (o .:? "activationToken")
      <*> (o .:? "answer")
      <*> (o .:? "nextPassCode")
      <*> (o .:? "passCode")
      <*> (o .:? "tokenLifetimeSeconds")

-- | ToJSON VerifyFactorRequest
instance A.ToJSON VerifyFactorRequest where
  toJSON VerifyFactorRequest {..} =
   _omitNulls
      [ "activationToken" .= verifyFactorRequestActivationToken
      , "answer" .= verifyFactorRequestAnswer
      , "nextPassCode" .= verifyFactorRequestNextPassCode
      , "passCode" .= verifyFactorRequestPassCode
      , "tokenLifetimeSeconds" .= verifyFactorRequestTokenLifetimeSeconds
      ]


-- | Construct a value of type 'VerifyFactorRequest' (by applying it's required fields, if any)
mkVerifyFactorRequest
  :: VerifyFactorRequest
mkVerifyFactorRequest =
  VerifyFactorRequest
  { verifyFactorRequestActivationToken = Nothing
  , verifyFactorRequestAnswer = Nothing
  , verifyFactorRequestNextPassCode = Nothing
  , verifyFactorRequestPassCode = Nothing
  , verifyFactorRequestTokenLifetimeSeconds = Nothing
  }

-- ** VerifyFactorResponse
-- | VerifyFactorResponse
data VerifyFactorResponse = VerifyFactorResponse
  { verifyFactorResponseEmbedded :: !(Maybe (Map.Map String A.Value)) -- ^ "_embedded"
  , verifyFactorResponseLinks :: !(Maybe (Map.Map String A.Value)) -- ^ "_links"
  , verifyFactorResponseExpiresAt :: !(Maybe DateTime) -- ^ "expiresAt"
  , verifyFactorResponseFactorResult :: !(Maybe FactorResultType) -- ^ "factorResult"
  , verifyFactorResponseFactorResultMessage :: !(Maybe Text) -- ^ "factorResultMessage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VerifyFactorResponse
instance A.FromJSON VerifyFactorResponse where
  parseJSON = A.withObject "VerifyFactorResponse" $ \o ->
    VerifyFactorResponse
      <$> (o .:? "_embedded")
      <*> (o .:? "_links")
      <*> (o .:? "expiresAt")
      <*> (o .:? "factorResult")
      <*> (o .:? "factorResultMessage")

-- | ToJSON VerifyFactorResponse
instance A.ToJSON VerifyFactorResponse where
  toJSON VerifyFactorResponse {..} =
   _omitNulls
      [ "_embedded" .= verifyFactorResponseEmbedded
      , "_links" .= verifyFactorResponseLinks
      , "expiresAt" .= verifyFactorResponseExpiresAt
      , "factorResult" .= verifyFactorResponseFactorResult
      , "factorResultMessage" .= verifyFactorResponseFactorResultMessage
      ]


-- | Construct a value of type 'VerifyFactorResponse' (by applying it's required fields, if any)
mkVerifyFactorResponse
  :: VerifyFactorResponse
mkVerifyFactorResponse =
  VerifyFactorResponse
  { verifyFactorResponseEmbedded = Nothing
  , verifyFactorResponseLinks = Nothing
  , verifyFactorResponseExpiresAt = Nothing
  , verifyFactorResponseFactorResult = Nothing
  , verifyFactorResponseFactorResultMessage = Nothing
  }

-- ** WebFactor
-- | WebFactor
data WebFactor = WebFactor
  { webFactorProfile :: !(Maybe WebFactorProfile) -- ^ "profile"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebFactor
instance A.FromJSON WebFactor where
  parseJSON = A.withObject "WebFactor" $ \o ->
    WebFactor
      <$> (o .:? "profile")

-- | ToJSON WebFactor
instance A.ToJSON WebFactor where
  toJSON WebFactor {..} =
   _omitNulls
      [ "profile" .= webFactorProfile
      ]


-- | Construct a value of type 'WebFactor' (by applying it's required fields, if any)
mkWebFactor
  :: WebFactor
mkWebFactor =
  WebFactor
  { webFactorProfile = Nothing
  }

-- ** WebFactorProfile
-- | WebFactorProfile
data WebFactorProfile = WebFactorProfile
  { webFactorProfileCredentialId :: !(Maybe Text) -- ^ "credentialId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebFactorProfile
instance A.FromJSON WebFactorProfile where
  parseJSON = A.withObject "WebFactorProfile" $ \o ->
    WebFactorProfile
      <$> (o .:? "credentialId")

-- | ToJSON WebFactorProfile
instance A.ToJSON WebFactorProfile where
  toJSON WebFactorProfile {..} =
   _omitNulls
      [ "credentialId" .= webFactorProfileCredentialId
      ]


-- | Construct a value of type 'WebFactorProfile' (by applying it's required fields, if any)
mkWebFactorProfile
  :: WebFactorProfile
mkWebFactorProfile =
  WebFactorProfile
  { webFactorProfileCredentialId = Nothing
  }

-- ** WsFederationApplication
-- | WsFederationApplication
data WsFederationApplication = WsFederationApplication
  { wsFederationApplicationName :: !(Maybe A.Value) -- ^ "name"
  , wsFederationApplicationSettings :: !(Maybe WsFederationApplicationSettings) -- ^ "settings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WsFederationApplication
instance A.FromJSON WsFederationApplication where
  parseJSON = A.withObject "WsFederationApplication" $ \o ->
    WsFederationApplication
      <$> (o .:? "name")
      <*> (o .:? "settings")

-- | ToJSON WsFederationApplication
instance A.ToJSON WsFederationApplication where
  toJSON WsFederationApplication {..} =
   _omitNulls
      [ "name" .= wsFederationApplicationName
      , "settings" .= wsFederationApplicationSettings
      ]


-- | Construct a value of type 'WsFederationApplication' (by applying it's required fields, if any)
mkWsFederationApplication
  :: WsFederationApplication
mkWsFederationApplication =
  WsFederationApplication
  { wsFederationApplicationName = Nothing
  , wsFederationApplicationSettings = Nothing
  }

-- ** WsFederationApplicationSettings
-- | WsFederationApplicationSettings
data WsFederationApplicationSettings = WsFederationApplicationSettings
  { wsFederationApplicationSettingsApp :: !(Maybe WsFederationApplicationSettingsApplication) -- ^ "app"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WsFederationApplicationSettings
instance A.FromJSON WsFederationApplicationSettings where
  parseJSON = A.withObject "WsFederationApplicationSettings" $ \o ->
    WsFederationApplicationSettings
      <$> (o .:? "app")

-- | ToJSON WsFederationApplicationSettings
instance A.ToJSON WsFederationApplicationSettings where
  toJSON WsFederationApplicationSettings {..} =
   _omitNulls
      [ "app" .= wsFederationApplicationSettingsApp
      ]


-- | Construct a value of type 'WsFederationApplicationSettings' (by applying it's required fields, if any)
mkWsFederationApplicationSettings
  :: WsFederationApplicationSettings
mkWsFederationApplicationSettings =
  WsFederationApplicationSettings
  { wsFederationApplicationSettingsApp = Nothing
  }

-- ** WsFederationApplicationSettingsApplication
-- | WsFederationApplicationSettingsApplication
data WsFederationApplicationSettingsApplication = WsFederationApplicationSettingsApplication
  { wsFederationApplicationSettingsApplicationAttributeStatements :: !(Maybe Text) -- ^ "attributeStatements"
  , wsFederationApplicationSettingsApplicationAudienceRestriction :: !(Maybe Text) -- ^ "audienceRestriction"
  , wsFederationApplicationSettingsApplicationAuthnContextClassRef :: !(Maybe Text) -- ^ "authnContextClassRef"
  , wsFederationApplicationSettingsApplicationGroupFilter :: !(Maybe Text) -- ^ "groupFilter"
  , wsFederationApplicationSettingsApplicationGroupName :: !(Maybe Text) -- ^ "groupName"
  , wsFederationApplicationSettingsApplicationGroupValueFormat :: !(Maybe Text) -- ^ "groupValueFormat"
  , wsFederationApplicationSettingsApplicationNameIdFormat :: !(Maybe Text) -- ^ "nameIDFormat"
  , wsFederationApplicationSettingsApplicationRealm :: !(Maybe Text) -- ^ "realm"
  , wsFederationApplicationSettingsApplicationSiteUrl :: !(Maybe Text) -- ^ "siteURL"
  , wsFederationApplicationSettingsApplicationUsernameAttribute :: !(Maybe Text) -- ^ "usernameAttribute"
  , wsFederationApplicationSettingsApplicationWReplyOverride :: !(Maybe Bool) -- ^ "wReplyOverride"
  , wsFederationApplicationSettingsApplicationWReplyUrl :: !(Maybe Text) -- ^ "wReplyURL"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WsFederationApplicationSettingsApplication
instance A.FromJSON WsFederationApplicationSettingsApplication where
  parseJSON = A.withObject "WsFederationApplicationSettingsApplication" $ \o ->
    WsFederationApplicationSettingsApplication
      <$> (o .:? "attributeStatements")
      <*> (o .:? "audienceRestriction")
      <*> (o .:? "authnContextClassRef")
      <*> (o .:? "groupFilter")
      <*> (o .:? "groupName")
      <*> (o .:? "groupValueFormat")
      <*> (o .:? "nameIDFormat")
      <*> (o .:? "realm")
      <*> (o .:? "siteURL")
      <*> (o .:? "usernameAttribute")
      <*> (o .:? "wReplyOverride")
      <*> (o .:? "wReplyURL")

-- | ToJSON WsFederationApplicationSettingsApplication
instance A.ToJSON WsFederationApplicationSettingsApplication where
  toJSON WsFederationApplicationSettingsApplication {..} =
   _omitNulls
      [ "attributeStatements" .= wsFederationApplicationSettingsApplicationAttributeStatements
      , "audienceRestriction" .= wsFederationApplicationSettingsApplicationAudienceRestriction
      , "authnContextClassRef" .= wsFederationApplicationSettingsApplicationAuthnContextClassRef
      , "groupFilter" .= wsFederationApplicationSettingsApplicationGroupFilter
      , "groupName" .= wsFederationApplicationSettingsApplicationGroupName
      , "groupValueFormat" .= wsFederationApplicationSettingsApplicationGroupValueFormat
      , "nameIDFormat" .= wsFederationApplicationSettingsApplicationNameIdFormat
      , "realm" .= wsFederationApplicationSettingsApplicationRealm
      , "siteURL" .= wsFederationApplicationSettingsApplicationSiteUrl
      , "usernameAttribute" .= wsFederationApplicationSettingsApplicationUsernameAttribute
      , "wReplyOverride" .= wsFederationApplicationSettingsApplicationWReplyOverride
      , "wReplyURL" .= wsFederationApplicationSettingsApplicationWReplyUrl
      ]


-- | Construct a value of type 'WsFederationApplicationSettingsApplication' (by applying it's required fields, if any)
mkWsFederationApplicationSettingsApplication
  :: WsFederationApplicationSettingsApplication
mkWsFederationApplicationSettingsApplication =
  WsFederationApplicationSettingsApplication
  { wsFederationApplicationSettingsApplicationAttributeStatements = Nothing
  , wsFederationApplicationSettingsApplicationAudienceRestriction = Nothing
  , wsFederationApplicationSettingsApplicationAuthnContextClassRef = Nothing
  , wsFederationApplicationSettingsApplicationGroupFilter = Nothing
  , wsFederationApplicationSettingsApplicationGroupName = Nothing
  , wsFederationApplicationSettingsApplicationGroupValueFormat = Nothing
  , wsFederationApplicationSettingsApplicationNameIdFormat = Nothing
  , wsFederationApplicationSettingsApplicationRealm = Nothing
  , wsFederationApplicationSettingsApplicationSiteUrl = Nothing
  , wsFederationApplicationSettingsApplicationUsernameAttribute = Nothing
  , wsFederationApplicationSettingsApplicationWReplyOverride = Nothing
  , wsFederationApplicationSettingsApplicationWReplyUrl = Nothing
  }


-- * Enums


-- ** ApplicationCredentialsScheme

-- | Enum of 'Text'
data ApplicationCredentialsScheme
  = ApplicationCredentialsScheme'SHARED_USERNAME_AND_PASSWORD -- ^ @"SHARED_USERNAME_AND_PASSWORD"@
  | ApplicationCredentialsScheme'EXTERNAL_PASSWORD_SYNC -- ^ @"EXTERNAL_PASSWORD_SYNC"@
  | ApplicationCredentialsScheme'EDIT_USERNAME_AND_PASSWORD -- ^ @"EDIT_USERNAME_AND_PASSWORD"@
  | ApplicationCredentialsScheme'EDIT_PASSWORD_ONLY -- ^ @"EDIT_PASSWORD_ONLY"@
  | ApplicationCredentialsScheme'ADMIN_SETS_CREDENTIALS -- ^ @"ADMIN_SETS_CREDENTIALS"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApplicationCredentialsScheme where toJSON = A.toJSON . fromApplicationCredentialsScheme
instance A.FromJSON ApplicationCredentialsScheme where parseJSON o = P.either P.fail (pure . P.id) . toApplicationCredentialsScheme =<< A.parseJSON o
instance WH.ToHttpApiData ApplicationCredentialsScheme where toQueryParam = WH.toQueryParam . fromApplicationCredentialsScheme
instance WH.FromHttpApiData ApplicationCredentialsScheme where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApplicationCredentialsScheme
instance MimeRender MimeMultipartFormData ApplicationCredentialsScheme where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApplicationCredentialsScheme' enum
fromApplicationCredentialsScheme :: ApplicationCredentialsScheme -> Text
fromApplicationCredentialsScheme = \case
  ApplicationCredentialsScheme'SHARED_USERNAME_AND_PASSWORD -> "SHARED_USERNAME_AND_PASSWORD"
  ApplicationCredentialsScheme'EXTERNAL_PASSWORD_SYNC -> "EXTERNAL_PASSWORD_SYNC"
  ApplicationCredentialsScheme'EDIT_USERNAME_AND_PASSWORD -> "EDIT_USERNAME_AND_PASSWORD"
  ApplicationCredentialsScheme'EDIT_PASSWORD_ONLY -> "EDIT_PASSWORD_ONLY"
  ApplicationCredentialsScheme'ADMIN_SETS_CREDENTIALS -> "ADMIN_SETS_CREDENTIALS"

-- | parse 'ApplicationCredentialsScheme' enum
toApplicationCredentialsScheme :: Text -> P.Either String ApplicationCredentialsScheme
toApplicationCredentialsScheme = \case
  "SHARED_USERNAME_AND_PASSWORD" -> P.Right ApplicationCredentialsScheme'SHARED_USERNAME_AND_PASSWORD
  "EXTERNAL_PASSWORD_SYNC" -> P.Right ApplicationCredentialsScheme'EXTERNAL_PASSWORD_SYNC
  "EDIT_USERNAME_AND_PASSWORD" -> P.Right ApplicationCredentialsScheme'EDIT_USERNAME_AND_PASSWORD
  "EDIT_PASSWORD_ONLY" -> P.Right ApplicationCredentialsScheme'EDIT_PASSWORD_ONLY
  "ADMIN_SETS_CREDENTIALS" -> P.Right ApplicationCredentialsScheme'ADMIN_SETS_CREDENTIALS
  s -> P.Left $ "toApplicationCredentialsScheme: enum parse failure: " P.++ P.show s


-- ** ApplicationSignOnMode

-- | Enum of 'Text'
data ApplicationSignOnMode
  = ApplicationSignOnMode'BOOKMARK -- ^ @"BOOKMARK"@
  | ApplicationSignOnMode'BASIC_AUTH -- ^ @"BASIC_AUTH"@
  | ApplicationSignOnMode'BROWSER_PLUGIN -- ^ @"BROWSER_PLUGIN"@
  | ApplicationSignOnMode'SECURE_PASSWORD_STORE -- ^ @"SECURE_PASSWORD_STORE"@
  | ApplicationSignOnMode'AUTO_LOGIN -- ^ @"AUTO_LOGIN"@
  | ApplicationSignOnMode'WS_FEDERATION -- ^ @"WS_FEDERATION"@
  | ApplicationSignOnMode'SAML_2_0 -- ^ @"SAML_2_0"@
  | ApplicationSignOnMode'OPENID_CONNECT -- ^ @"OPENID_CONNECT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ApplicationSignOnMode where toJSON = A.toJSON . fromApplicationSignOnMode
instance A.FromJSON ApplicationSignOnMode where parseJSON o = P.either P.fail (pure . P.id) . toApplicationSignOnMode =<< A.parseJSON o
instance WH.ToHttpApiData ApplicationSignOnMode where toQueryParam = WH.toQueryParam . fromApplicationSignOnMode
instance WH.FromHttpApiData ApplicationSignOnMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toApplicationSignOnMode
instance MimeRender MimeMultipartFormData ApplicationSignOnMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ApplicationSignOnMode' enum
fromApplicationSignOnMode :: ApplicationSignOnMode -> Text
fromApplicationSignOnMode = \case
  ApplicationSignOnMode'BOOKMARK -> "BOOKMARK"
  ApplicationSignOnMode'BASIC_AUTH -> "BASIC_AUTH"
  ApplicationSignOnMode'BROWSER_PLUGIN -> "BROWSER_PLUGIN"
  ApplicationSignOnMode'SECURE_PASSWORD_STORE -> "SECURE_PASSWORD_STORE"
  ApplicationSignOnMode'AUTO_LOGIN -> "AUTO_LOGIN"
  ApplicationSignOnMode'WS_FEDERATION -> "WS_FEDERATION"
  ApplicationSignOnMode'SAML_2_0 -> "SAML_2_0"
  ApplicationSignOnMode'OPENID_CONNECT -> "OPENID_CONNECT"

-- | parse 'ApplicationSignOnMode' enum
toApplicationSignOnMode :: Text -> P.Either String ApplicationSignOnMode
toApplicationSignOnMode = \case
  "BOOKMARK" -> P.Right ApplicationSignOnMode'BOOKMARK
  "BASIC_AUTH" -> P.Right ApplicationSignOnMode'BASIC_AUTH
  "BROWSER_PLUGIN" -> P.Right ApplicationSignOnMode'BROWSER_PLUGIN
  "SECURE_PASSWORD_STORE" -> P.Right ApplicationSignOnMode'SECURE_PASSWORD_STORE
  "AUTO_LOGIN" -> P.Right ApplicationSignOnMode'AUTO_LOGIN
  "WS_FEDERATION" -> P.Right ApplicationSignOnMode'WS_FEDERATION
  "SAML_2_0" -> P.Right ApplicationSignOnMode'SAML_2_0
  "OPENID_CONNECT" -> P.Right ApplicationSignOnMode'OPENID_CONNECT
  s -> P.Left $ "toApplicationSignOnMode: enum parse failure: " P.++ P.show s


-- ** AuthenticationProviderType

-- | Enum of 'Text'
data AuthenticationProviderType
  = AuthenticationProviderType'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | AuthenticationProviderType'FEDERATION -- ^ @"FEDERATION"@
  | AuthenticationProviderType'LDAP -- ^ @"LDAP"@
  | AuthenticationProviderType'OKTA -- ^ @"OKTA"@
  | AuthenticationProviderType'SOCIAL -- ^ @"SOCIAL"@
  | AuthenticationProviderType'IMPORT -- ^ @"IMPORT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON AuthenticationProviderType where toJSON = A.toJSON . fromAuthenticationProviderType
instance A.FromJSON AuthenticationProviderType where parseJSON o = P.either P.fail (pure . P.id) . toAuthenticationProviderType =<< A.parseJSON o
instance WH.ToHttpApiData AuthenticationProviderType where toQueryParam = WH.toQueryParam . fromAuthenticationProviderType
instance WH.FromHttpApiData AuthenticationProviderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toAuthenticationProviderType
instance MimeRender MimeMultipartFormData AuthenticationProviderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'AuthenticationProviderType' enum
fromAuthenticationProviderType :: AuthenticationProviderType -> Text
fromAuthenticationProviderType = \case
  AuthenticationProviderType'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  AuthenticationProviderType'FEDERATION -> "FEDERATION"
  AuthenticationProviderType'LDAP -> "LDAP"
  AuthenticationProviderType'OKTA -> "OKTA"
  AuthenticationProviderType'SOCIAL -> "SOCIAL"
  AuthenticationProviderType'IMPORT -> "IMPORT"

-- | parse 'AuthenticationProviderType' enum
toAuthenticationProviderType :: Text -> P.Either String AuthenticationProviderType
toAuthenticationProviderType = \case
  "ACTIVE_DIRECTORY" -> P.Right AuthenticationProviderType'ACTIVE_DIRECTORY
  "FEDERATION" -> P.Right AuthenticationProviderType'FEDERATION
  "LDAP" -> P.Right AuthenticationProviderType'LDAP
  "OKTA" -> P.Right AuthenticationProviderType'OKTA
  "SOCIAL" -> P.Right AuthenticationProviderType'SOCIAL
  "IMPORT" -> P.Right AuthenticationProviderType'IMPORT
  s -> P.Left $ "toAuthenticationProviderType: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text'
data E'Status
  = E'Status'ACTIVE -- ^ @"ACTIVE"@
  | E'Status'INACTIVE -- ^ @"INACTIVE"@
  | E'Status'DELETED -- ^ @"DELETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'ACTIVE -> "ACTIVE"
  E'Status'INACTIVE -> "INACTIVE"
  E'Status'DELETED -> "DELETED"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "ACTIVE" -> P.Right E'Status'ACTIVE
  "INACTIVE" -> P.Right E'Status'INACTIVE
  "DELETED" -> P.Right E'Status'DELETED
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** EmailStatus

-- | Enum of 'Text'
data EmailStatus
  = EmailStatus'VERIFIED -- ^ @"VERIFIED"@
  | EmailStatus'UNVERIFIED -- ^ @"UNVERIFIED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EmailStatus where toJSON = A.toJSON . fromEmailStatus
instance A.FromJSON EmailStatus where parseJSON o = P.either P.fail (pure . P.id) . toEmailStatus =<< A.parseJSON o
instance WH.ToHttpApiData EmailStatus where toQueryParam = WH.toQueryParam . fromEmailStatus
instance WH.FromHttpApiData EmailStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEmailStatus
instance MimeRender MimeMultipartFormData EmailStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EmailStatus' enum
fromEmailStatus :: EmailStatus -> Text
fromEmailStatus = \case
  EmailStatus'VERIFIED -> "VERIFIED"
  EmailStatus'UNVERIFIED -> "UNVERIFIED"

-- | parse 'EmailStatus' enum
toEmailStatus :: Text -> P.Either String EmailStatus
toEmailStatus = \case
  "VERIFIED" -> P.Right EmailStatus'VERIFIED
  "UNVERIFIED" -> P.Right EmailStatus'UNVERIFIED
  s -> P.Left $ "toEmailStatus: enum parse failure: " P.++ P.show s


-- ** EmailType

-- | Enum of 'Text'
data EmailType
  = EmailType'PRIMARY -- ^ @"PRIMARY"@
  | EmailType'SECONDARY -- ^ @"SECONDARY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON EmailType where toJSON = A.toJSON . fromEmailType
instance A.FromJSON EmailType where parseJSON o = P.either P.fail (pure . P.id) . toEmailType =<< A.parseJSON o
instance WH.ToHttpApiData EmailType where toQueryParam = WH.toQueryParam . fromEmailType
instance WH.FromHttpApiData EmailType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toEmailType
instance MimeRender MimeMultipartFormData EmailType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'EmailType' enum
fromEmailType :: EmailType -> Text
fromEmailType = \case
  EmailType'PRIMARY -> "PRIMARY"
  EmailType'SECONDARY -> "SECONDARY"

-- | parse 'EmailType' enum
toEmailType :: Text -> P.Either String EmailType
toEmailType = \case
  "PRIMARY" -> P.Right EmailType'PRIMARY
  "SECONDARY" -> P.Right EmailType'SECONDARY
  s -> P.Left $ "toEmailType: enum parse failure: " P.++ P.show s


-- ** FactorProvider

-- | Enum of 'Text'
data FactorProvider
  = FactorProvider'OKTA -- ^ @"OKTA"@
  | FactorProvider'RSA -- ^ @"RSA"@
  | FactorProvider'GOOGLE -- ^ @"GOOGLE"@
  | FactorProvider'SYMANTEC -- ^ @"SYMANTEC"@
  | FactorProvider'DUO -- ^ @"DUO"@
  | FactorProvider'YUBICO -- ^ @"YUBICO"@
  | FactorProvider'FIDO -- ^ @"FIDO"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorProvider where toJSON = A.toJSON . fromFactorProvider
instance A.FromJSON FactorProvider where parseJSON o = P.either P.fail (pure . P.id) . toFactorProvider =<< A.parseJSON o
instance WH.ToHttpApiData FactorProvider where toQueryParam = WH.toQueryParam . fromFactorProvider
instance WH.FromHttpApiData FactorProvider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorProvider
instance MimeRender MimeMultipartFormData FactorProvider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorProvider' enum
fromFactorProvider :: FactorProvider -> Text
fromFactorProvider = \case
  FactorProvider'OKTA -> "OKTA"
  FactorProvider'RSA -> "RSA"
  FactorProvider'GOOGLE -> "GOOGLE"
  FactorProvider'SYMANTEC -> "SYMANTEC"
  FactorProvider'DUO -> "DUO"
  FactorProvider'YUBICO -> "YUBICO"
  FactorProvider'FIDO -> "FIDO"

-- | parse 'FactorProvider' enum
toFactorProvider :: Text -> P.Either String FactorProvider
toFactorProvider = \case
  "OKTA" -> P.Right FactorProvider'OKTA
  "RSA" -> P.Right FactorProvider'RSA
  "GOOGLE" -> P.Right FactorProvider'GOOGLE
  "SYMANTEC" -> P.Right FactorProvider'SYMANTEC
  "DUO" -> P.Right FactorProvider'DUO
  "YUBICO" -> P.Right FactorProvider'YUBICO
  "FIDO" -> P.Right FactorProvider'FIDO
  s -> P.Left $ "toFactorProvider: enum parse failure: " P.++ P.show s


-- ** FactorResultType

-- | Enum of 'Text'
data FactorResultType
  = FactorResultType'SUCCESS -- ^ @"SUCCESS"@
  | FactorResultType'CHALLENGE -- ^ @"CHALLENGE"@
  | FactorResultType'WAITING -- ^ @"WAITING"@
  | FactorResultType'FAILED -- ^ @"FAILED"@
  | FactorResultType'REJECTED -- ^ @"REJECTED"@
  | FactorResultType'TIMEOUT -- ^ @"TIMEOUT"@
  | FactorResultType'TIME_WINDOW_EXCEEDED -- ^ @"TIME_WINDOW_EXCEEDED"@
  | FactorResultType'PASSCODE_REPLAYED -- ^ @"PASSCODE_REPLAYED"@
  | FactorResultType'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorResultType where toJSON = A.toJSON . fromFactorResultType
instance A.FromJSON FactorResultType where parseJSON o = P.either P.fail (pure . P.id) . toFactorResultType =<< A.parseJSON o
instance WH.ToHttpApiData FactorResultType where toQueryParam = WH.toQueryParam . fromFactorResultType
instance WH.FromHttpApiData FactorResultType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorResultType
instance MimeRender MimeMultipartFormData FactorResultType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorResultType' enum
fromFactorResultType :: FactorResultType -> Text
fromFactorResultType = \case
  FactorResultType'SUCCESS -> "SUCCESS"
  FactorResultType'CHALLENGE -> "CHALLENGE"
  FactorResultType'WAITING -> "WAITING"
  FactorResultType'FAILED -> "FAILED"
  FactorResultType'REJECTED -> "REJECTED"
  FactorResultType'TIMEOUT -> "TIMEOUT"
  FactorResultType'TIME_WINDOW_EXCEEDED -> "TIME_WINDOW_EXCEEDED"
  FactorResultType'PASSCODE_REPLAYED -> "PASSCODE_REPLAYED"
  FactorResultType'ERROR -> "ERROR"

-- | parse 'FactorResultType' enum
toFactorResultType :: Text -> P.Either String FactorResultType
toFactorResultType = \case
  "SUCCESS" -> P.Right FactorResultType'SUCCESS
  "CHALLENGE" -> P.Right FactorResultType'CHALLENGE
  "WAITING" -> P.Right FactorResultType'WAITING
  "FAILED" -> P.Right FactorResultType'FAILED
  "REJECTED" -> P.Right FactorResultType'REJECTED
  "TIMEOUT" -> P.Right FactorResultType'TIMEOUT
  "TIME_WINDOW_EXCEEDED" -> P.Right FactorResultType'TIME_WINDOW_EXCEEDED
  "PASSCODE_REPLAYED" -> P.Right FactorResultType'PASSCODE_REPLAYED
  "ERROR" -> P.Right FactorResultType'ERROR
  s -> P.Left $ "toFactorResultType: enum parse failure: " P.++ P.show s


-- ** FactorStatus

-- | Enum of 'Text'
data FactorStatus
  = FactorStatus'PENDING_ACTIVATION -- ^ @"PENDING_ACTIVATION"@
  | FactorStatus'ACTIVE -- ^ @"ACTIVE"@
  | FactorStatus'INACTIVE -- ^ @"INACTIVE"@
  | FactorStatus'NOT_SETUP -- ^ @"NOT_SETUP"@
  | FactorStatus'ENROLLED -- ^ @"ENROLLED"@
  | FactorStatus'DISABLED -- ^ @"DISABLED"@
  | FactorStatus'EXPIRED -- ^ @"EXPIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorStatus where toJSON = A.toJSON . fromFactorStatus
instance A.FromJSON FactorStatus where parseJSON o = P.either P.fail (pure . P.id) . toFactorStatus =<< A.parseJSON o
instance WH.ToHttpApiData FactorStatus where toQueryParam = WH.toQueryParam . fromFactorStatus
instance WH.FromHttpApiData FactorStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorStatus
instance MimeRender MimeMultipartFormData FactorStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorStatus' enum
fromFactorStatus :: FactorStatus -> Text
fromFactorStatus = \case
  FactorStatus'PENDING_ACTIVATION -> "PENDING_ACTIVATION"
  FactorStatus'ACTIVE -> "ACTIVE"
  FactorStatus'INACTIVE -> "INACTIVE"
  FactorStatus'NOT_SETUP -> "NOT_SETUP"
  FactorStatus'ENROLLED -> "ENROLLED"
  FactorStatus'DISABLED -> "DISABLED"
  FactorStatus'EXPIRED -> "EXPIRED"

-- | parse 'FactorStatus' enum
toFactorStatus :: Text -> P.Either String FactorStatus
toFactorStatus = \case
  "PENDING_ACTIVATION" -> P.Right FactorStatus'PENDING_ACTIVATION
  "ACTIVE" -> P.Right FactorStatus'ACTIVE
  "INACTIVE" -> P.Right FactorStatus'INACTIVE
  "NOT_SETUP" -> P.Right FactorStatus'NOT_SETUP
  "ENROLLED" -> P.Right FactorStatus'ENROLLED
  "DISABLED" -> P.Right FactorStatus'DISABLED
  "EXPIRED" -> P.Right FactorStatus'EXPIRED
  s -> P.Left $ "toFactorStatus: enum parse failure: " P.++ P.show s


-- ** FactorType

-- | Enum of 'Text'
data FactorType
  = FactorType'Push -- ^ @"push"@
  | FactorType'Sms -- ^ @"sms"@
  | FactorType'Call -- ^ @"call"@
  | FactorType'Token -- ^ @"token"@
  | FactorType'Tokensoftwaretotp -- ^ @"token:software:totp"@
  | FactorType'Tokenhardware -- ^ @"token:hardware"@
  | FactorType'Question -- ^ @"question"@
  | FactorType'Web -- ^ @"web"@
  | FactorType'Email -- ^ @"email"@
  | FactorType'U2f -- ^ @"u2f"@
  | FactorType'Webauthn -- ^ @"webauthn"@
  | FactorType'Tokensoftware -- ^ @"token:software"@
  | FactorType'Custom -- ^ @"custom"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON FactorType where toJSON = A.toJSON . fromFactorType
instance A.FromJSON FactorType where parseJSON o = P.either P.fail (pure . P.id) . toFactorType =<< A.parseJSON o
instance WH.ToHttpApiData FactorType where toQueryParam = WH.toQueryParam . fromFactorType
instance WH.FromHttpApiData FactorType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toFactorType
instance MimeRender MimeMultipartFormData FactorType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'FactorType' enum
fromFactorType :: FactorType -> Text
fromFactorType = \case
  FactorType'Push -> "push"
  FactorType'Sms -> "sms"
  FactorType'Call -> "call"
  FactorType'Token -> "token"
  FactorType'Tokensoftwaretotp -> "token:software:totp"
  FactorType'Tokenhardware -> "token:hardware"
  FactorType'Question -> "question"
  FactorType'Web -> "web"
  FactorType'Email -> "email"
  FactorType'U2f -> "u2f"
  FactorType'Webauthn -> "webauthn"
  FactorType'Tokensoftware -> "token:software"
  FactorType'Custom -> "custom"

-- | parse 'FactorType' enum
toFactorType :: Text -> P.Either String FactorType
toFactorType = \case
  "push" -> P.Right FactorType'Push
  "sms" -> P.Right FactorType'Sms
  "call" -> P.Right FactorType'Call
  "token" -> P.Right FactorType'Token
  "token:software:totp" -> P.Right FactorType'Tokensoftwaretotp
  "token:hardware" -> P.Right FactorType'Tokenhardware
  "question" -> P.Right FactorType'Question
  "web" -> P.Right FactorType'Web
  "email" -> P.Right FactorType'Email
  "u2f" -> P.Right FactorType'U2f
  "webauthn" -> P.Right FactorType'Webauthn
  "token:software" -> P.Right FactorType'Tokensoftware
  "custom" -> P.Right FactorType'Custom
  s -> P.Left $ "toFactorType: enum parse failure: " P.++ P.show s


-- ** GroupRuleStatus

-- | Enum of 'Text'
data GroupRuleStatus
  = GroupRuleStatus'ACTIVE -- ^ @"ACTIVE"@
  | GroupRuleStatus'INACTIVE -- ^ @"INACTIVE"@
  | GroupRuleStatus'INVALID -- ^ @"INVALID"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON GroupRuleStatus where toJSON = A.toJSON . fromGroupRuleStatus
instance A.FromJSON GroupRuleStatus where parseJSON o = P.either P.fail (pure . P.id) . toGroupRuleStatus =<< A.parseJSON o
instance WH.ToHttpApiData GroupRuleStatus where toQueryParam = WH.toQueryParam . fromGroupRuleStatus
instance WH.FromHttpApiData GroupRuleStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toGroupRuleStatus
instance MimeRender MimeMultipartFormData GroupRuleStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'GroupRuleStatus' enum
fromGroupRuleStatus :: GroupRuleStatus -> Text
fromGroupRuleStatus = \case
  GroupRuleStatus'ACTIVE -> "ACTIVE"
  GroupRuleStatus'INACTIVE -> "INACTIVE"
  GroupRuleStatus'INVALID -> "INVALID"

-- | parse 'GroupRuleStatus' enum
toGroupRuleStatus :: Text -> P.Either String GroupRuleStatus
toGroupRuleStatus = \case
  "ACTIVE" -> P.Right GroupRuleStatus'ACTIVE
  "INACTIVE" -> P.Right GroupRuleStatus'INACTIVE
  "INVALID" -> P.Right GroupRuleStatus'INVALID
  s -> P.Left $ "toGroupRuleStatus: enum parse failure: " P.++ P.show s


-- ** LogAuthenticationProvider

-- | Enum of 'Text'
data LogAuthenticationProvider
  = LogAuthenticationProvider'OKTA_AUTHENTICATION_PROVIDER -- ^ @"OKTA_AUTHENTICATION_PROVIDER"@
  | LogAuthenticationProvider'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | LogAuthenticationProvider'LDAP -- ^ @"LDAP"@
  | LogAuthenticationProvider'FEDERATION -- ^ @"FEDERATION"@
  | LogAuthenticationProvider'SOCIAL -- ^ @"SOCIAL"@
  | LogAuthenticationProvider'FACTOR_PROVIDER -- ^ @"FACTOR_PROVIDER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogAuthenticationProvider where toJSON = A.toJSON . fromLogAuthenticationProvider
instance A.FromJSON LogAuthenticationProvider where parseJSON o = P.either P.fail (pure . P.id) . toLogAuthenticationProvider =<< A.parseJSON o
instance WH.ToHttpApiData LogAuthenticationProvider where toQueryParam = WH.toQueryParam . fromLogAuthenticationProvider
instance WH.FromHttpApiData LogAuthenticationProvider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogAuthenticationProvider
instance MimeRender MimeMultipartFormData LogAuthenticationProvider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogAuthenticationProvider' enum
fromLogAuthenticationProvider :: LogAuthenticationProvider -> Text
fromLogAuthenticationProvider = \case
  LogAuthenticationProvider'OKTA_AUTHENTICATION_PROVIDER -> "OKTA_AUTHENTICATION_PROVIDER"
  LogAuthenticationProvider'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  LogAuthenticationProvider'LDAP -> "LDAP"
  LogAuthenticationProvider'FEDERATION -> "FEDERATION"
  LogAuthenticationProvider'SOCIAL -> "SOCIAL"
  LogAuthenticationProvider'FACTOR_PROVIDER -> "FACTOR_PROVIDER"

-- | parse 'LogAuthenticationProvider' enum
toLogAuthenticationProvider :: Text -> P.Either String LogAuthenticationProvider
toLogAuthenticationProvider = \case
  "OKTA_AUTHENTICATION_PROVIDER" -> P.Right LogAuthenticationProvider'OKTA_AUTHENTICATION_PROVIDER
  "ACTIVE_DIRECTORY" -> P.Right LogAuthenticationProvider'ACTIVE_DIRECTORY
  "LDAP" -> P.Right LogAuthenticationProvider'LDAP
  "FEDERATION" -> P.Right LogAuthenticationProvider'FEDERATION
  "SOCIAL" -> P.Right LogAuthenticationProvider'SOCIAL
  "FACTOR_PROVIDER" -> P.Right LogAuthenticationProvider'FACTOR_PROVIDER
  s -> P.Left $ "toLogAuthenticationProvider: enum parse failure: " P.++ P.show s


-- ** LogCredentialProvider

-- | Enum of 'Text'
data LogCredentialProvider
  = LogCredentialProvider'OKTA_AUTHENTICATION_PROVIDER -- ^ @"OKTA_AUTHENTICATION_PROVIDER"@
  | LogCredentialProvider'RSA -- ^ @"RSA"@
  | LogCredentialProvider'SYMANTEC -- ^ @"SYMANTEC"@
  | LogCredentialProvider'GOOGLE -- ^ @"GOOGLE"@
  | LogCredentialProvider'DUO -- ^ @"DUO"@
  | LogCredentialProvider'YUBIKEY -- ^ @"YUBIKEY"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogCredentialProvider where toJSON = A.toJSON . fromLogCredentialProvider
instance A.FromJSON LogCredentialProvider where parseJSON o = P.either P.fail (pure . P.id) . toLogCredentialProvider =<< A.parseJSON o
instance WH.ToHttpApiData LogCredentialProvider where toQueryParam = WH.toQueryParam . fromLogCredentialProvider
instance WH.FromHttpApiData LogCredentialProvider where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogCredentialProvider
instance MimeRender MimeMultipartFormData LogCredentialProvider where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogCredentialProvider' enum
fromLogCredentialProvider :: LogCredentialProvider -> Text
fromLogCredentialProvider = \case
  LogCredentialProvider'OKTA_AUTHENTICATION_PROVIDER -> "OKTA_AUTHENTICATION_PROVIDER"
  LogCredentialProvider'RSA -> "RSA"
  LogCredentialProvider'SYMANTEC -> "SYMANTEC"
  LogCredentialProvider'GOOGLE -> "GOOGLE"
  LogCredentialProvider'DUO -> "DUO"
  LogCredentialProvider'YUBIKEY -> "YUBIKEY"

-- | parse 'LogCredentialProvider' enum
toLogCredentialProvider :: Text -> P.Either String LogCredentialProvider
toLogCredentialProvider = \case
  "OKTA_AUTHENTICATION_PROVIDER" -> P.Right LogCredentialProvider'OKTA_AUTHENTICATION_PROVIDER
  "RSA" -> P.Right LogCredentialProvider'RSA
  "SYMANTEC" -> P.Right LogCredentialProvider'SYMANTEC
  "GOOGLE" -> P.Right LogCredentialProvider'GOOGLE
  "DUO" -> P.Right LogCredentialProvider'DUO
  "YUBIKEY" -> P.Right LogCredentialProvider'YUBIKEY
  s -> P.Left $ "toLogCredentialProvider: enum parse failure: " P.++ P.show s


-- ** LogCredentialType

-- | Enum of 'Text'
data LogCredentialType
  = LogCredentialType'OTP -- ^ @"OTP"@
  | LogCredentialType'SMS -- ^ @"SMS"@
  | LogCredentialType'PASSWORD -- ^ @"PASSWORD"@
  | LogCredentialType'ASSERTION -- ^ @"ASSERTION"@
  | LogCredentialType'IWA -- ^ @"IWA"@
  | LogCredentialType'EMAIL -- ^ @"EMAIL"@
  | LogCredentialType'OAUTH2 -- ^ @"OAUTH2"@
  | LogCredentialType'JWT -- ^ @"JWT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogCredentialType where toJSON = A.toJSON . fromLogCredentialType
instance A.FromJSON LogCredentialType where parseJSON o = P.either P.fail (pure . P.id) . toLogCredentialType =<< A.parseJSON o
instance WH.ToHttpApiData LogCredentialType where toQueryParam = WH.toQueryParam . fromLogCredentialType
instance WH.FromHttpApiData LogCredentialType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogCredentialType
instance MimeRender MimeMultipartFormData LogCredentialType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogCredentialType' enum
fromLogCredentialType :: LogCredentialType -> Text
fromLogCredentialType = \case
  LogCredentialType'OTP -> "OTP"
  LogCredentialType'SMS -> "SMS"
  LogCredentialType'PASSWORD -> "PASSWORD"
  LogCredentialType'ASSERTION -> "ASSERTION"
  LogCredentialType'IWA -> "IWA"
  LogCredentialType'EMAIL -> "EMAIL"
  LogCredentialType'OAUTH2 -> "OAUTH2"
  LogCredentialType'JWT -> "JWT"

-- | parse 'LogCredentialType' enum
toLogCredentialType :: Text -> P.Either String LogCredentialType
toLogCredentialType = \case
  "OTP" -> P.Right LogCredentialType'OTP
  "SMS" -> P.Right LogCredentialType'SMS
  "PASSWORD" -> P.Right LogCredentialType'PASSWORD
  "ASSERTION" -> P.Right LogCredentialType'ASSERTION
  "IWA" -> P.Right LogCredentialType'IWA
  "EMAIL" -> P.Right LogCredentialType'EMAIL
  "OAUTH2" -> P.Right LogCredentialType'OAUTH2
  "JWT" -> P.Right LogCredentialType'JWT
  s -> P.Left $ "toLogCredentialType: enum parse failure: " P.++ P.show s


-- ** LogSeverity

-- | Enum of 'Text'
data LogSeverity
  = LogSeverity'DEBUG -- ^ @"DEBUG"@
  | LogSeverity'INFO -- ^ @"INFO"@
  | LogSeverity'WARN -- ^ @"WARN"@
  | LogSeverity'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LogSeverity where toJSON = A.toJSON . fromLogSeverity
instance A.FromJSON LogSeverity where parseJSON o = P.either P.fail (pure . P.id) . toLogSeverity =<< A.parseJSON o
instance WH.ToHttpApiData LogSeverity where toQueryParam = WH.toQueryParam . fromLogSeverity
instance WH.FromHttpApiData LogSeverity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLogSeverity
instance MimeRender MimeMultipartFormData LogSeverity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LogSeverity' enum
fromLogSeverity :: LogSeverity -> Text
fromLogSeverity = \case
  LogSeverity'DEBUG -> "DEBUG"
  LogSeverity'INFO -> "INFO"
  LogSeverity'WARN -> "WARN"
  LogSeverity'ERROR -> "ERROR"

-- | parse 'LogSeverity' enum
toLogSeverity :: Text -> P.Either String LogSeverity
toLogSeverity = \case
  "DEBUG" -> P.Right LogSeverity'DEBUG
  "INFO" -> P.Right LogSeverity'INFO
  "WARN" -> P.Right LogSeverity'WARN
  "ERROR" -> P.Right LogSeverity'ERROR
  s -> P.Left $ "toLogSeverity: enum parse failure: " P.++ P.show s


-- ** OAuthEndpointAuthenticationMethod

-- | Enum of 'Text'
data OAuthEndpointAuthenticationMethod
  = OAuthEndpointAuthenticationMethod'None -- ^ @"none"@
  | OAuthEndpointAuthenticationMethod'Client_secret_post -- ^ @"client_secret_post"@
  | OAuthEndpointAuthenticationMethod'Client_secret_basic -- ^ @"client_secret_basic"@
  | OAuthEndpointAuthenticationMethod'Client_secret_jwt -- ^ @"client_secret_jwt"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuthEndpointAuthenticationMethod where toJSON = A.toJSON . fromOAuthEndpointAuthenticationMethod
instance A.FromJSON OAuthEndpointAuthenticationMethod where parseJSON o = P.either P.fail (pure . P.id) . toOAuthEndpointAuthenticationMethod =<< A.parseJSON o
instance WH.ToHttpApiData OAuthEndpointAuthenticationMethod where toQueryParam = WH.toQueryParam . fromOAuthEndpointAuthenticationMethod
instance WH.FromHttpApiData OAuthEndpointAuthenticationMethod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuthEndpointAuthenticationMethod
instance MimeRender MimeMultipartFormData OAuthEndpointAuthenticationMethod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuthEndpointAuthenticationMethod' enum
fromOAuthEndpointAuthenticationMethod :: OAuthEndpointAuthenticationMethod -> Text
fromOAuthEndpointAuthenticationMethod = \case
  OAuthEndpointAuthenticationMethod'None -> "none"
  OAuthEndpointAuthenticationMethod'Client_secret_post -> "client_secret_post"
  OAuthEndpointAuthenticationMethod'Client_secret_basic -> "client_secret_basic"
  OAuthEndpointAuthenticationMethod'Client_secret_jwt -> "client_secret_jwt"

-- | parse 'OAuthEndpointAuthenticationMethod' enum
toOAuthEndpointAuthenticationMethod :: Text -> P.Either String OAuthEndpointAuthenticationMethod
toOAuthEndpointAuthenticationMethod = \case
  "none" -> P.Right OAuthEndpointAuthenticationMethod'None
  "client_secret_post" -> P.Right OAuthEndpointAuthenticationMethod'Client_secret_post
  "client_secret_basic" -> P.Right OAuthEndpointAuthenticationMethod'Client_secret_basic
  "client_secret_jwt" -> P.Right OAuthEndpointAuthenticationMethod'Client_secret_jwt
  s -> P.Left $ "toOAuthEndpointAuthenticationMethod: enum parse failure: " P.++ P.show s


-- ** OAuthGrantType

-- | Enum of 'Text'
data OAuthGrantType
  = OAuthGrantType'Authorization_code -- ^ @"authorization_code"@
  | OAuthGrantType'Implicit -- ^ @"implicit"@
  | OAuthGrantType'Password -- ^ @"password"@
  | OAuthGrantType'Refresh_token -- ^ @"refresh_token"@
  | OAuthGrantType'Client_credentials -- ^ @"client_credentials"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuthGrantType where toJSON = A.toJSON . fromOAuthGrantType
instance A.FromJSON OAuthGrantType where parseJSON o = P.either P.fail (pure . P.id) . toOAuthGrantType =<< A.parseJSON o
instance WH.ToHttpApiData OAuthGrantType where toQueryParam = WH.toQueryParam . fromOAuthGrantType
instance WH.FromHttpApiData OAuthGrantType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuthGrantType
instance MimeRender MimeMultipartFormData OAuthGrantType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuthGrantType' enum
fromOAuthGrantType :: OAuthGrantType -> Text
fromOAuthGrantType = \case
  OAuthGrantType'Authorization_code -> "authorization_code"
  OAuthGrantType'Implicit -> "implicit"
  OAuthGrantType'Password -> "password"
  OAuthGrantType'Refresh_token -> "refresh_token"
  OAuthGrantType'Client_credentials -> "client_credentials"

-- | parse 'OAuthGrantType' enum
toOAuthGrantType :: Text -> P.Either String OAuthGrantType
toOAuthGrantType = \case
  "authorization_code" -> P.Right OAuthGrantType'Authorization_code
  "implicit" -> P.Right OAuthGrantType'Implicit
  "password" -> P.Right OAuthGrantType'Password
  "refresh_token" -> P.Right OAuthGrantType'Refresh_token
  "client_credentials" -> P.Right OAuthGrantType'Client_credentials
  s -> P.Left $ "toOAuthGrantType: enum parse failure: " P.++ P.show s


-- ** OAuthResponseType

-- | Enum of 'Text'
data OAuthResponseType
  = OAuthResponseType'Code -- ^ @"code"@
  | OAuthResponseType'Token -- ^ @"token"@
  | OAuthResponseType'Id_token -- ^ @"id_token"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OAuthResponseType where toJSON = A.toJSON . fromOAuthResponseType
instance A.FromJSON OAuthResponseType where parseJSON o = P.either P.fail (pure . P.id) . toOAuthResponseType =<< A.parseJSON o
instance WH.ToHttpApiData OAuthResponseType where toQueryParam = WH.toQueryParam . fromOAuthResponseType
instance WH.FromHttpApiData OAuthResponseType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOAuthResponseType
instance MimeRender MimeMultipartFormData OAuthResponseType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OAuthResponseType' enum
fromOAuthResponseType :: OAuthResponseType -> Text
fromOAuthResponseType = \case
  OAuthResponseType'Code -> "code"
  OAuthResponseType'Token -> "token"
  OAuthResponseType'Id_token -> "id_token"

-- | parse 'OAuthResponseType' enum
toOAuthResponseType :: Text -> P.Either String OAuthResponseType
toOAuthResponseType = \case
  "code" -> P.Right OAuthResponseType'Code
  "token" -> P.Right OAuthResponseType'Token
  "id_token" -> P.Right OAuthResponseType'Id_token
  s -> P.Left $ "toOAuthResponseType: enum parse failure: " P.++ P.show s


-- ** OpenIdConnectApplicationConsentMethod

-- | Enum of 'Text'
data OpenIdConnectApplicationConsentMethod
  = OpenIdConnectApplicationConsentMethod'REQUIRED -- ^ @"REQUIRED"@
  | OpenIdConnectApplicationConsentMethod'TRUSTED -- ^ @"TRUSTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OpenIdConnectApplicationConsentMethod where toJSON = A.toJSON . fromOpenIdConnectApplicationConsentMethod
instance A.FromJSON OpenIdConnectApplicationConsentMethod where parseJSON o = P.either P.fail (pure . P.id) . toOpenIdConnectApplicationConsentMethod =<< A.parseJSON o
instance WH.ToHttpApiData OpenIdConnectApplicationConsentMethod where toQueryParam = WH.toQueryParam . fromOpenIdConnectApplicationConsentMethod
instance WH.FromHttpApiData OpenIdConnectApplicationConsentMethod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOpenIdConnectApplicationConsentMethod
instance MimeRender MimeMultipartFormData OpenIdConnectApplicationConsentMethod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OpenIdConnectApplicationConsentMethod' enum
fromOpenIdConnectApplicationConsentMethod :: OpenIdConnectApplicationConsentMethod -> Text
fromOpenIdConnectApplicationConsentMethod = \case
  OpenIdConnectApplicationConsentMethod'REQUIRED -> "REQUIRED"
  OpenIdConnectApplicationConsentMethod'TRUSTED -> "TRUSTED"

-- | parse 'OpenIdConnectApplicationConsentMethod' enum
toOpenIdConnectApplicationConsentMethod :: Text -> P.Either String OpenIdConnectApplicationConsentMethod
toOpenIdConnectApplicationConsentMethod = \case
  "REQUIRED" -> P.Right OpenIdConnectApplicationConsentMethod'REQUIRED
  "TRUSTED" -> P.Right OpenIdConnectApplicationConsentMethod'TRUSTED
  s -> P.Left $ "toOpenIdConnectApplicationConsentMethod: enum parse failure: " P.++ P.show s


-- ** OpenIdConnectApplicationType

-- | Enum of 'Text'
data OpenIdConnectApplicationType
  = OpenIdConnectApplicationType'Web -- ^ @"web"@
  | OpenIdConnectApplicationType'Native -- ^ @"native"@
  | OpenIdConnectApplicationType'Browser -- ^ @"browser"@
  | OpenIdConnectApplicationType'Service -- ^ @"service"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OpenIdConnectApplicationType where toJSON = A.toJSON . fromOpenIdConnectApplicationType
instance A.FromJSON OpenIdConnectApplicationType where parseJSON o = P.either P.fail (pure . P.id) . toOpenIdConnectApplicationType =<< A.parseJSON o
instance WH.ToHttpApiData OpenIdConnectApplicationType where toQueryParam = WH.toQueryParam . fromOpenIdConnectApplicationType
instance WH.FromHttpApiData OpenIdConnectApplicationType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOpenIdConnectApplicationType
instance MimeRender MimeMultipartFormData OpenIdConnectApplicationType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OpenIdConnectApplicationType' enum
fromOpenIdConnectApplicationType :: OpenIdConnectApplicationType -> Text
fromOpenIdConnectApplicationType = \case
  OpenIdConnectApplicationType'Web -> "web"
  OpenIdConnectApplicationType'Native -> "native"
  OpenIdConnectApplicationType'Browser -> "browser"
  OpenIdConnectApplicationType'Service -> "service"

-- | parse 'OpenIdConnectApplicationType' enum
toOpenIdConnectApplicationType :: Text -> P.Either String OpenIdConnectApplicationType
toOpenIdConnectApplicationType = \case
  "web" -> P.Right OpenIdConnectApplicationType'Web
  "native" -> P.Right OpenIdConnectApplicationType'Native
  "browser" -> P.Right OpenIdConnectApplicationType'Browser
  "service" -> P.Right OpenIdConnectApplicationType'Service
  s -> P.Left $ "toOpenIdConnectApplicationType: enum parse failure: " P.++ P.show s


-- ** RoleStatus

-- | Enum of 'Text'
data RoleStatus
  = RoleStatus'ACTIVE -- ^ @"ACTIVE"@
  | RoleStatus'INACTIVE -- ^ @"INACTIVE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RoleStatus where toJSON = A.toJSON . fromRoleStatus
instance A.FromJSON RoleStatus where parseJSON o = P.either P.fail (pure . P.id) . toRoleStatus =<< A.parseJSON o
instance WH.ToHttpApiData RoleStatus where toQueryParam = WH.toQueryParam . fromRoleStatus
instance WH.FromHttpApiData RoleStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRoleStatus
instance MimeRender MimeMultipartFormData RoleStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RoleStatus' enum
fromRoleStatus :: RoleStatus -> Text
fromRoleStatus = \case
  RoleStatus'ACTIVE -> "ACTIVE"
  RoleStatus'INACTIVE -> "INACTIVE"

-- | parse 'RoleStatus' enum
toRoleStatus :: Text -> P.Either String RoleStatus
toRoleStatus = \case
  "ACTIVE" -> P.Right RoleStatus'ACTIVE
  "INACTIVE" -> P.Right RoleStatus'INACTIVE
  s -> P.Left $ "toRoleStatus: enum parse failure: " P.++ P.show s


-- ** SessionAuthenticationMethod

-- | Enum of 'Text'
data SessionAuthenticationMethod
  = SessionAuthenticationMethod'Pwd -- ^ @"pwd"@
  | SessionAuthenticationMethod'Swk -- ^ @"swk"@
  | SessionAuthenticationMethod'Hwk -- ^ @"hwk"@
  | SessionAuthenticationMethod'Otp -- ^ @"otp"@
  | SessionAuthenticationMethod'Sms -- ^ @"sms"@
  | SessionAuthenticationMethod'Tel -- ^ @"tel"@
  | SessionAuthenticationMethod'Geo -- ^ @"geo"@
  | SessionAuthenticationMethod'Fpt -- ^ @"fpt"@
  | SessionAuthenticationMethod'Kba -- ^ @"kba"@
  | SessionAuthenticationMethod'Mfa -- ^ @"mfa"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SessionAuthenticationMethod where toJSON = A.toJSON . fromSessionAuthenticationMethod
instance A.FromJSON SessionAuthenticationMethod where parseJSON o = P.either P.fail (pure . P.id) . toSessionAuthenticationMethod =<< A.parseJSON o
instance WH.ToHttpApiData SessionAuthenticationMethod where toQueryParam = WH.toQueryParam . fromSessionAuthenticationMethod
instance WH.FromHttpApiData SessionAuthenticationMethod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSessionAuthenticationMethod
instance MimeRender MimeMultipartFormData SessionAuthenticationMethod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SessionAuthenticationMethod' enum
fromSessionAuthenticationMethod :: SessionAuthenticationMethod -> Text
fromSessionAuthenticationMethod = \case
  SessionAuthenticationMethod'Pwd -> "pwd"
  SessionAuthenticationMethod'Swk -> "swk"
  SessionAuthenticationMethod'Hwk -> "hwk"
  SessionAuthenticationMethod'Otp -> "otp"
  SessionAuthenticationMethod'Sms -> "sms"
  SessionAuthenticationMethod'Tel -> "tel"
  SessionAuthenticationMethod'Geo -> "geo"
  SessionAuthenticationMethod'Fpt -> "fpt"
  SessionAuthenticationMethod'Kba -> "kba"
  SessionAuthenticationMethod'Mfa -> "mfa"

-- | parse 'SessionAuthenticationMethod' enum
toSessionAuthenticationMethod :: Text -> P.Either String SessionAuthenticationMethod
toSessionAuthenticationMethod = \case
  "pwd" -> P.Right SessionAuthenticationMethod'Pwd
  "swk" -> P.Right SessionAuthenticationMethod'Swk
  "hwk" -> P.Right SessionAuthenticationMethod'Hwk
  "otp" -> P.Right SessionAuthenticationMethod'Otp
  "sms" -> P.Right SessionAuthenticationMethod'Sms
  "tel" -> P.Right SessionAuthenticationMethod'Tel
  "geo" -> P.Right SessionAuthenticationMethod'Geo
  "fpt" -> P.Right SessionAuthenticationMethod'Fpt
  "kba" -> P.Right SessionAuthenticationMethod'Kba
  "mfa" -> P.Right SessionAuthenticationMethod'Mfa
  s -> P.Left $ "toSessionAuthenticationMethod: enum parse failure: " P.++ P.show s


-- ** SessionIdentityProviderType

-- | Enum of 'Text'
data SessionIdentityProviderType
  = SessionIdentityProviderType'ACTIVE_DIRECTORY -- ^ @"ACTIVE_DIRECTORY"@
  | SessionIdentityProviderType'LDAP -- ^ @"LDAP"@
  | SessionIdentityProviderType'OKTA -- ^ @"OKTA"@
  | SessionIdentityProviderType'FEDERATION -- ^ @"FEDERATION"@
  | SessionIdentityProviderType'SOCIAL -- ^ @"SOCIAL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SessionIdentityProviderType where toJSON = A.toJSON . fromSessionIdentityProviderType
instance A.FromJSON SessionIdentityProviderType where parseJSON o = P.either P.fail (pure . P.id) . toSessionIdentityProviderType =<< A.parseJSON o
instance WH.ToHttpApiData SessionIdentityProviderType where toQueryParam = WH.toQueryParam . fromSessionIdentityProviderType
instance WH.FromHttpApiData SessionIdentityProviderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSessionIdentityProviderType
instance MimeRender MimeMultipartFormData SessionIdentityProviderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SessionIdentityProviderType' enum
fromSessionIdentityProviderType :: SessionIdentityProviderType -> Text
fromSessionIdentityProviderType = \case
  SessionIdentityProviderType'ACTIVE_DIRECTORY -> "ACTIVE_DIRECTORY"
  SessionIdentityProviderType'LDAP -> "LDAP"
  SessionIdentityProviderType'OKTA -> "OKTA"
  SessionIdentityProviderType'FEDERATION -> "FEDERATION"
  SessionIdentityProviderType'SOCIAL -> "SOCIAL"

-- | parse 'SessionIdentityProviderType' enum
toSessionIdentityProviderType :: Text -> P.Either String SessionIdentityProviderType
toSessionIdentityProviderType = \case
  "ACTIVE_DIRECTORY" -> P.Right SessionIdentityProviderType'ACTIVE_DIRECTORY
  "LDAP" -> P.Right SessionIdentityProviderType'LDAP
  "OKTA" -> P.Right SessionIdentityProviderType'OKTA
  "FEDERATION" -> P.Right SessionIdentityProviderType'FEDERATION
  "SOCIAL" -> P.Right SessionIdentityProviderType'SOCIAL
  s -> P.Left $ "toSessionIdentityProviderType: enum parse failure: " P.++ P.show s


-- ** SessionStatus

-- | Enum of 'Text'
data SessionStatus
  = SessionStatus'ACTIVE -- ^ @"ACTIVE"@
  | SessionStatus'MFA_ENROLL -- ^ @"MFA_ENROLL"@
  | SessionStatus'MFA_REQUIRED -- ^ @"MFA_REQUIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SessionStatus where toJSON = A.toJSON . fromSessionStatus
instance A.FromJSON SessionStatus where parseJSON o = P.either P.fail (pure . P.id) . toSessionStatus =<< A.parseJSON o
instance WH.ToHttpApiData SessionStatus where toQueryParam = WH.toQueryParam . fromSessionStatus
instance WH.FromHttpApiData SessionStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSessionStatus
instance MimeRender MimeMultipartFormData SessionStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SessionStatus' enum
fromSessionStatus :: SessionStatus -> Text
fromSessionStatus = \case
  SessionStatus'ACTIVE -> "ACTIVE"
  SessionStatus'MFA_ENROLL -> "MFA_ENROLL"
  SessionStatus'MFA_REQUIRED -> "MFA_REQUIRED"

-- | parse 'SessionStatus' enum
toSessionStatus :: Text -> P.Either String SessionStatus
toSessionStatus = \case
  "ACTIVE" -> P.Right SessionStatus'ACTIVE
  "MFA_ENROLL" -> P.Right SessionStatus'MFA_ENROLL
  "MFA_REQUIRED" -> P.Right SessionStatus'MFA_REQUIRED
  s -> P.Left $ "toSessionStatus: enum parse failure: " P.++ P.show s


-- ** UserNextLogin

-- | Enum of 'Text'
data UserNextLogin
  = UserNextLogin'ChangePassword -- ^ @"changePassword"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserNextLogin where toJSON = A.toJSON . fromUserNextLogin
instance A.FromJSON UserNextLogin where parseJSON o = P.either P.fail (pure . P.id) . toUserNextLogin =<< A.parseJSON o
instance WH.ToHttpApiData UserNextLogin where toQueryParam = WH.toQueryParam . fromUserNextLogin
instance WH.FromHttpApiData UserNextLogin where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserNextLogin
instance MimeRender MimeMultipartFormData UserNextLogin where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserNextLogin' enum
fromUserNextLogin :: UserNextLogin -> Text
fromUserNextLogin = \case
  UserNextLogin'ChangePassword -> "changePassword"

-- | parse 'UserNextLogin' enum
toUserNextLogin :: Text -> P.Either String UserNextLogin
toUserNextLogin = \case
  "changePassword" -> P.Right UserNextLogin'ChangePassword
  s -> P.Left $ "toUserNextLogin: enum parse failure: " P.++ P.show s


-- ** UserStatus

-- | Enum of 'Text'
data UserStatus
  = UserStatus'STAGED -- ^ @"STAGED"@
  | UserStatus'PROVISIONED -- ^ @"PROVISIONED"@
  | UserStatus'ACTIVE -- ^ @"ACTIVE"@
  | UserStatus'RECOVERY -- ^ @"RECOVERY"@
  | UserStatus'PASSWORD_EXPIRED -- ^ @"PASSWORD_EXPIRED"@
  | UserStatus'LOCKED_OUT -- ^ @"LOCKED_OUT"@
  | UserStatus'DEPROVISIONED -- ^ @"DEPROVISIONED"@
  | UserStatus'SUSPENDED -- ^ @"SUSPENDED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserStatus where toJSON = A.toJSON . fromUserStatus
instance A.FromJSON UserStatus where parseJSON o = P.either P.fail (pure . P.id) . toUserStatus =<< A.parseJSON o
instance WH.ToHttpApiData UserStatus where toQueryParam = WH.toQueryParam . fromUserStatus
instance WH.FromHttpApiData UserStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserStatus
instance MimeRender MimeMultipartFormData UserStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserStatus' enum
fromUserStatus :: UserStatus -> Text
fromUserStatus = \case
  UserStatus'STAGED -> "STAGED"
  UserStatus'PROVISIONED -> "PROVISIONED"
  UserStatus'ACTIVE -> "ACTIVE"
  UserStatus'RECOVERY -> "RECOVERY"
  UserStatus'PASSWORD_EXPIRED -> "PASSWORD_EXPIRED"
  UserStatus'LOCKED_OUT -> "LOCKED_OUT"
  UserStatus'DEPROVISIONED -> "DEPROVISIONED"
  UserStatus'SUSPENDED -> "SUSPENDED"

-- | parse 'UserStatus' enum
toUserStatus :: Text -> P.Either String UserStatus
toUserStatus = \case
  "STAGED" -> P.Right UserStatus'STAGED
  "PROVISIONED" -> P.Right UserStatus'PROVISIONED
  "ACTIVE" -> P.Right UserStatus'ACTIVE
  "RECOVERY" -> P.Right UserStatus'RECOVERY
  "PASSWORD_EXPIRED" -> P.Right UserStatus'PASSWORD_EXPIRED
  "LOCKED_OUT" -> P.Right UserStatus'LOCKED_OUT
  "DEPROVISIONED" -> P.Right UserStatus'DEPROVISIONED
  "SUSPENDED" -> P.Right UserStatus'SUSPENDED
  s -> P.Left $ "toUserStatus: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiToken
data AuthApiKeyApiToken =
  AuthApiKeyApiToken Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiToken where
  applyAuthMethod _ a@(AuthApiKeyApiToken secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


