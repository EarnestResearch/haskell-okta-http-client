{-
   Okta API

   Allows customers to easily access the Okta API

   OpenAPI Version: 3.0.1
   Okta API API version: 1.0.0
   Contact: devex-public@okta.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Okta.API.User
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Okta.API.User where

import Okta.Core
import Okta.MimeTypes
import Okta.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** User

-- *** activateUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/activate@
-- 
-- Activate User
-- 
-- Activates a user.  This operation can only be performed on users with a `STAGED` status.  Activation of a user is an asynchronous operation. The user will have the `transitioningToStatus` property with a value of `ACTIVE` during activation to indicate that the user hasn't completed the asynchronous operation.  The user will have a status of `ACTIVE` when the activation process is complete.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
activateUser
  :: UserId -- ^ "userId"
  -> SendEmail -- ^ "sendEmail" -  Sends an activation email to the user if true
  -> OktaRequest ActivateUser MimeNoContent UserActivationToken MimeJSON
activateUser (UserId userId) (SendEmail sendEmail) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/activate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `addQuery` toQuery ("sendEmail", Just sendEmail)

data ActivateUser  
-- | @application/json@
instance Produces ActivateUser MimeJSON


-- *** addAllAppsAsTargetToRole

-- | @PUT \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/catalog\/apps@
-- 
-- Success
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
addAllAppsAsTargetToRole
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest AddAllAppsAsTargetToRole MimeNoContent NoContent MimeNoContent
addAllAppsAsTargetToRole (UserId userId) (RoleId roleId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/catalog/apps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data AddAllAppsAsTargetToRole  
instance Produces AddAllAppsAsTargetToRole MimeNoContent


-- *** addApplicationTargetToAdminRoleForUser

-- | @PUT \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/catalog\/apps\/{appName}@
-- 
-- Success
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
addApplicationTargetToAdminRoleForUser
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> AppName -- ^ "appName"
  -> OktaRequest AddApplicationTargetToAdminRoleForUser MimeNoContent NoContent MimeNoContent
addApplicationTargetToAdminRoleForUser (UserId userId) (RoleId roleId) (AppName appName) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/catalog/apps/",toPath appName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data AddApplicationTargetToAdminRoleForUser  
instance Produces AddApplicationTargetToAdminRoleForUser MimeNoContent


-- *** addApplicationTargetToAppAdminRoleForUser

-- | @PUT \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/catalog\/apps\/{appName}\/{applicationId}@
-- 
-- Add App Instance Target to App Administrator Role given to a User
-- 
-- Add App Instance Target to App Administrator Role given to a User
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
addApplicationTargetToAppAdminRoleForUser
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> AppName -- ^ "appName"
  -> ApplicationId -- ^ "applicationId"
  -> OktaRequest AddApplicationTargetToAppAdminRoleForUser MimeNoContent NoContent MimeNoContent
addApplicationTargetToAppAdminRoleForUser (UserId userId) (RoleId roleId) (AppName appName) (ApplicationId applicationId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/catalog/apps/",toPath appName,"/",toPath applicationId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data AddApplicationTargetToAppAdminRoleForUser  
instance Produces AddApplicationTargetToAppAdminRoleForUser MimeNoContent


-- *** addGroupTargetToRole

-- | @PUT \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/groups\/{groupId}@
-- 
-- Success
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
addGroupTargetToRole
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> GroupId -- ^ "groupId"
  -> OktaRequest AddGroupTargetToRole MimeNoContent NoContent MimeNoContent
addGroupTargetToRole (UserId userId) (RoleId roleId) (GroupId groupId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/groups/",toPath groupId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data AddGroupTargetToRole  
instance Produces AddGroupTargetToRole MimeNoContent


-- *** apiV1UsersUserIdCredentialsForgotPasswordPost

-- | @POST \/api\/v1\/users\/{userId}\/credentials\/forgot_password@
-- 
-- Forgot Password
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
apiV1UsersUserIdCredentialsForgotPasswordPost
  :: UserId -- ^ "userId"
  -> OktaRequest ApiV1UsersUserIdCredentialsForgotPasswordPost MimeNoContent ForgotPasswordResponse MimeJSON
apiV1UsersUserIdCredentialsForgotPasswordPost (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/credentials/forgot_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ApiV1UsersUserIdCredentialsForgotPasswordPost  
-- | @application/json@
instance Produces ApiV1UsersUserIdCredentialsForgotPasswordPost MimeJSON


-- *** assignRoleToUser

-- | @POST \/api\/v1\/users\/{userId}\/roles@
-- 
-- Assigns a role to a user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
assignRoleToUser
  :: (Consumes AssignRoleToUser MimeJSON, MimeRender MimeJSON AssignRoleRequest)
  => AssignRoleRequest -- ^ "assignRoleRequest"
  -> UserId -- ^ "userId"
  -> OktaRequest AssignRoleToUser MimeJSON Role MimeJSON
assignRoleToUser assignRoleRequest (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` assignRoleRequest

data AssignRoleToUser 
instance HasBodyParam AssignRoleToUser AssignRoleRequest 
instance HasOptionalParam AssignRoleToUser DisableNotifications where
  applyOptionalParam req (DisableNotifications xs) =
    req `addQuery` toQuery ("disableNotifications", Just xs)

-- | @application/json@
instance Consumes AssignRoleToUser MimeJSON

-- | @application/json@
instance Produces AssignRoleToUser MimeJSON


-- *** changePassword

-- | @POST \/api\/v1\/users\/{userId}\/credentials\/change_password@
-- 
-- Change Password
-- 
-- Changes a user's password by validating the user's current password. This operation can only be performed on users in `STAGED`, `ACTIVE`, `PASSWORD_EXPIRED`, or `RECOVERY` status that have a valid password credential
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
changePassword
  :: (Consumes ChangePassword MimeJSON, MimeRender MimeJSON ChangePasswordRequest)
  => ChangePasswordRequest -- ^ "changePasswordRequest"
  -> UserId -- ^ "userId"
  -> OktaRequest ChangePassword MimeJSON UserCredentials MimeJSON
changePassword changePasswordRequest (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/credentials/change_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` changePasswordRequest

data ChangePassword 
instance HasBodyParam ChangePassword ChangePasswordRequest 
instance HasOptionalParam ChangePassword Strict where
  applyOptionalParam req (Strict xs) =
    req `addQuery` toQuery ("strict", Just xs)

-- | @application/json@
instance Consumes ChangePassword MimeJSON

-- | @application/json@
instance Produces ChangePassword MimeJSON


-- *** changeRecoveryQuestion

-- | @POST \/api\/v1\/users\/{userId}\/credentials\/change_recovery_question@
-- 
-- Change Recovery Question
-- 
-- Changes a user's recovery question & answer credential by validating the user's current password.  This operation can only be performed on users in **STAGED**, **ACTIVE** or **RECOVERY** `status` that have a valid password credential
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
changeRecoveryQuestion
  :: (Consumes ChangeRecoveryQuestion MimeJSON, MimeRender MimeJSON UserCredentials)
  => UserCredentials -- ^ "userCredentials"
  -> UserId -- ^ "userId"
  -> OktaRequest ChangeRecoveryQuestion MimeJSON UserCredentials MimeJSON
changeRecoveryQuestion userCredentials (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/credentials/change_recovery_question"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` userCredentials

data ChangeRecoveryQuestion 
instance HasBodyParam ChangeRecoveryQuestion UserCredentials 

-- | @application/json@
instance Consumes ChangeRecoveryQuestion MimeJSON

-- | @application/json@
instance Produces ChangeRecoveryQuestion MimeJSON


-- *** clearUserSessions

-- | @DELETE \/api\/v1\/users\/{userId}\/sessions@
-- 
-- Removes all active identity provider sessions. This forces the user to authenticate on the next operation. Optionally revokes OpenID Connect and OAuth refresh and access tokens issued to the user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
clearUserSessions
  :: UserId -- ^ "userId"
  -> OktaRequest ClearUserSessions MimeNoContent NoContent MimeNoContent
clearUserSessions (UserId userId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/sessions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ClearUserSessions  

-- | /Optional Param/ "oauthTokens" - Revoke issued OpenID Connect and OAuth refresh and access tokens
instance HasOptionalParam ClearUserSessions OauthTokens where
  applyOptionalParam req (OauthTokens xs) =
    req `addQuery` toQuery ("oauthTokens", Just xs)
instance Produces ClearUserSessions MimeNoContent


-- *** createUser

-- | @POST \/api\/v1\/users@
-- 
-- Create User
-- 
-- Creates a new user in your Okta organization with or without credentials.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
createUser
  :: (Consumes CreateUser MimeJSON, MimeRender MimeJSON CreateUserRequest)
  => CreateUserRequest -- ^ "body"
  -> OktaRequest CreateUser MimeJSON User MimeJSON
createUser body =
  _mkRequest "POST" ["/api/v1/users"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` body

data CreateUser 
instance HasBodyParam CreateUser CreateUserRequest 

-- | /Optional Param/ "activate" - Executes activation lifecycle operation when creating the user
instance HasOptionalParam CreateUser Activate where
  applyOptionalParam req (Activate xs) =
    req `addQuery` toQuery ("activate", Just xs)

-- | /Optional Param/ "provider" - Indicates whether to create a user with a specified authentication provider
instance HasOptionalParam CreateUser Provider where
  applyOptionalParam req (Provider xs) =
    req `addQuery` toQuery ("provider", Just xs)

-- | /Optional Param/ "nextLogin" - With activate=true, set nextLogin to \"changePassword\" to have the password be EXPIRED, so user must change it the next time they log in.
instance HasOptionalParam CreateUser NextLogin where
  applyOptionalParam req (NextLogin xs) =
    req `addQuery` toQuery ("nextLogin", Just xs)

-- | @application/json@
instance Consumes CreateUser MimeJSON

-- | @application/json@
instance Produces CreateUser MimeJSON


-- *** deactivateOrDeleteUser

-- | @DELETE \/api\/v1\/users\/{userId}@
-- 
-- Delete User
-- 
-- Deletes a user permanently.  This operation can only be performed on users that have a `DEPROVISIONED` status.  **This action cannot be recovered!**
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
deactivateOrDeleteUser
  :: UserId -- ^ "userId"
  -> OktaRequest DeactivateOrDeleteUser MimeNoContent NoContent MimeNoContent
deactivateOrDeleteUser (UserId userId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data DeactivateOrDeleteUser  
instance HasOptionalParam DeactivateOrDeleteUser SendEmail where
  applyOptionalParam req (SendEmail xs) =
    req `addQuery` toQuery ("sendEmail", Just xs)
instance Produces DeactivateOrDeleteUser MimeNoContent


-- *** deactivateUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/deactivate@
-- 
-- Deactivate User
-- 
-- Deactivates a user. This operation can only be performed on users that do not have a `DEPROVISIONED` status. While the asynchronous operation (triggered by HTTP header `Prefer: respond-async`) is proceeding the user's `transitioningToStatus` property is `DEPROVISIONED`. The user's status is `DEPROVISIONED` when the deactivation process is complete.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
deactivateUser
  :: UserId -- ^ "userId"
  -> OktaRequest DeactivateUser MimeNoContent NoContent MimeNoContent
deactivateUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/deactivate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data DeactivateUser  
instance HasOptionalParam DeactivateUser SendEmail where
  applyOptionalParam req (SendEmail xs) =
    req `addQuery` toQuery ("sendEmail", Just xs)
instance Produces DeactivateUser MimeNoContent


-- *** expirePassword

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/expire_password?tempPassword=false@
-- 
-- Expire Password
-- 
-- This operation transitions the user to the status of `PASSWORD_EXPIRED` so that the user is required to change their password at their next login.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
expirePassword
  :: UserId -- ^ "userId"
  -> OktaRequest ExpirePassword MimeNoContent User MimeJSON
expirePassword (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/expire_password?tempPassword=false"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ExpirePassword  
-- | @application/json@
instance Produces ExpirePassword MimeJSON


-- *** expirePasswordAndGetTemporaryPassword

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/expire_password?tempPassword=true@
-- 
-- Expire Password
-- 
-- This operation transitions the user to the status of `PASSWORD_EXPIRED` and the user's password is reset to a temporary password that is returned.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
expirePasswordAndGetTemporaryPassword
  :: UserId -- ^ "userId"
  -> OktaRequest ExpirePasswordAndGetTemporaryPassword MimeNoContent TempPassword MimeJSON
expirePasswordAndGetTemporaryPassword (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/expire_password?tempPassword=true"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ExpirePasswordAndGetTemporaryPassword  
-- | @application/json@
instance Produces ExpirePasswordAndGetTemporaryPassword MimeJSON


-- *** getLinkedObjectsForUser

-- | @GET \/api\/v1\/users\/{userId}\/linkedObjects\/{relationshipName}@
-- 
-- Get linked objects for a user, relationshipName can be a primary or associated relationship name
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getLinkedObjectsForUser
  :: UserId -- ^ "userId"
  -> RelationshipName -- ^ "relationshipName"
  -> OktaRequest GetLinkedObjectsForUser MimeNoContent [ResponseLinks] MimeJSON
getLinkedObjectsForUser (UserId userId) (RelationshipName relationshipName) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/linkedObjects/",toPath relationshipName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetLinkedObjectsForUser  
instance HasOptionalParam GetLinkedObjectsForUser After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
instance HasOptionalParam GetLinkedObjectsForUser Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces GetLinkedObjectsForUser MimeJSON


-- *** getRefreshTokenForUserAndClient

-- | @GET \/api\/v1\/users\/{userId}\/clients\/{clientId}\/tokens\/{tokenId}@
-- 
-- Gets a refresh token issued for the specified User and Client.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getRefreshTokenForUserAndClient
  :: UserId -- ^ "userId"
  -> ClientId -- ^ "clientId"
  -> TokenId -- ^ "tokenId"
  -> OktaRequest GetRefreshTokenForUserAndClient MimeNoContent OAuth2RefreshToken MimeJSON
getRefreshTokenForUserAndClient (UserId userId) (ClientId clientId) (TokenId tokenId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/clients/",toPath clientId,"/tokens/",toPath tokenId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetRefreshTokenForUserAndClient  
instance HasOptionalParam GetRefreshTokenForUserAndClient Expand where
  applyOptionalParam req (Expand xs) =
    req `addQuery` toQuery ("expand", Just xs)
instance HasOptionalParam GetRefreshTokenForUserAndClient Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
instance HasOptionalParam GetRefreshTokenForUserAndClient After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
-- | @application/json@
instance Produces GetRefreshTokenForUserAndClient MimeJSON


-- *** getUser

-- | @GET \/api\/v1\/users\/{userId}@
-- 
-- Get User
-- 
-- Fetches a user from your Okta organization.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getUser
  :: UserId -- ^ "userId"
  -> OktaRequest GetUser MimeNoContent User MimeJSON
getUser (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetUser  
-- | @application/json@
instance Produces GetUser MimeJSON


-- *** getUserGrant

-- | @GET \/api\/v1\/users\/{userId}\/grants\/{grantId}@
-- 
-- Gets a grant for the specified user
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getUserGrant
  :: UserId -- ^ "userId"
  -> GrantId -- ^ "grantId"
  -> OktaRequest GetUserGrant MimeNoContent OAuth2ScopeConsentGrant MimeJSON
getUserGrant (UserId userId) (GrantId grantId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/grants/",toPath grantId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetUserGrant  
instance HasOptionalParam GetUserGrant Expand where
  applyOptionalParam req (Expand xs) =
    req `addQuery` toQuery ("expand", Just xs)
-- | @application/json@
instance Produces GetUserGrant MimeJSON


-- *** getUserRole

-- | @GET \/api\/v1\/users\/{userId}\/roles\/{roleId}@
-- 
-- Gets role that is assigne to user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getUserRole
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest GetUserRole MimeNoContent Role MimeJSON
getUserRole (UserId userId) (RoleId roleId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetUserRole  
-- | @application/json@
instance Produces GetUserRole MimeJSON


-- *** getUserSubscriptionByNotificationType

-- | @GET \/api\/v1\/users\/{userId}\/subscriptions\/{notificationType}@
-- 
-- Get the subscription of a User with a specific notification type
-- 
-- Get the subscriptions of a User with a specific notification type. Only gets subscriptions for current user. An AccessDeniedException message is sent if requests are made from other users.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getUserSubscriptionByNotificationType
  :: UserId -- ^ "userId"
  -> NotificationTypeText -- ^ "notificationType"
  -> OktaRequest GetUserSubscriptionByNotificationType MimeNoContent Subscription MimeJSON
getUserSubscriptionByNotificationType (UserId userId) (NotificationTypeText notificationType) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/subscriptions/",toPath notificationType]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetUserSubscriptionByNotificationType  
-- | @application/json@
instance Produces GetUserSubscriptionByNotificationType MimeJSON


-- *** listAppLinks

-- | @GET \/api\/v1\/users\/{userId}\/appLinks@
-- 
-- Get Assigned App Links
-- 
-- Fetches appLinks for all direct or indirect (via group membership) assigned applications.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listAppLinks
  :: UserId -- ^ "userId"
  -> OktaRequest ListAppLinks MimeNoContent [AppLink] MimeJSON
listAppLinks (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/appLinks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListAppLinks  
-- | @application/json@
instance Produces ListAppLinks MimeJSON


-- *** listApplicationTargetsForApplicationAdministratorRoleForUser

-- | @GET \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/catalog\/apps@
-- 
-- Lists all App targets for an `APP_ADMIN` Role assigned to a User. This methods return list may include full Applications or Instances. The response for an instance will have an `ID` value, while Application will not have an ID.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listApplicationTargetsForApplicationAdministratorRoleForUser
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest ListApplicationTargetsForApplicationAdministratorRoleForUser MimeNoContent [CatalogApplication] MimeJSON
listApplicationTargetsForApplicationAdministratorRoleForUser (UserId userId) (RoleId roleId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/catalog/apps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListApplicationTargetsForApplicationAdministratorRoleForUser  
instance HasOptionalParam ListApplicationTargetsForApplicationAdministratorRoleForUser After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListApplicationTargetsForApplicationAdministratorRoleForUser Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListApplicationTargetsForApplicationAdministratorRoleForUser MimeJSON


-- *** listAssignedRolesForUser

-- | @GET \/api\/v1\/users\/{userId}\/roles@
-- 
-- Lists all roles assigned to a user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listAssignedRolesForUser
  :: UserId -- ^ "userId"
  -> OktaRequest ListAssignedRolesForUser MimeNoContent [Role] MimeJSON
listAssignedRolesForUser (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListAssignedRolesForUser  
instance HasOptionalParam ListAssignedRolesForUser Expand where
  applyOptionalParam req (Expand xs) =
    req `addQuery` toQuery ("expand", Just xs)
-- | @application/json@
instance Produces ListAssignedRolesForUser MimeJSON


-- *** listGrantsForUserAndClient

-- | @GET \/api\/v1\/users\/{userId}\/clients\/{clientId}\/grants@
-- 
-- Lists all grants for a specified user and client
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listGrantsForUserAndClient
  :: UserId -- ^ "userId"
  -> ClientId -- ^ "clientId"
  -> OktaRequest ListGrantsForUserAndClient MimeNoContent [OAuth2ScopeConsentGrant] MimeJSON
listGrantsForUserAndClient (UserId userId) (ClientId clientId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/clients/",toPath clientId,"/grants"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListGrantsForUserAndClient  
instance HasOptionalParam ListGrantsForUserAndClient Expand where
  applyOptionalParam req (Expand xs) =
    req `addQuery` toQuery ("expand", Just xs)
instance HasOptionalParam ListGrantsForUserAndClient After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListGrantsForUserAndClient Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListGrantsForUserAndClient MimeJSON


-- *** listGroupTargetsForRole

-- | @GET \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/groups@
-- 
-- Success
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listGroupTargetsForRole
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest ListGroupTargetsForRole MimeNoContent [Group] MimeJSON
listGroupTargetsForRole (UserId userId) (RoleId roleId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/groups"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListGroupTargetsForRole  
instance HasOptionalParam ListGroupTargetsForRole After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListGroupTargetsForRole Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListGroupTargetsForRole MimeJSON


-- *** listRefreshTokensForUserAndClient

-- | @GET \/api\/v1\/users\/{userId}\/clients\/{clientId}\/tokens@
-- 
-- Lists all refresh tokens issued for the specified User and Client.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listRefreshTokensForUserAndClient
  :: UserId -- ^ "userId"
  -> ClientId -- ^ "clientId"
  -> OktaRequest ListRefreshTokensForUserAndClient MimeNoContent [OAuth2RefreshToken] MimeJSON
listRefreshTokensForUserAndClient (UserId userId) (ClientId clientId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/clients/",toPath clientId,"/tokens"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListRefreshTokensForUserAndClient  
instance HasOptionalParam ListRefreshTokensForUserAndClient Expand where
  applyOptionalParam req (Expand xs) =
    req `addQuery` toQuery ("expand", Just xs)
instance HasOptionalParam ListRefreshTokensForUserAndClient After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListRefreshTokensForUserAndClient Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListRefreshTokensForUserAndClient MimeJSON


-- *** listUserClients

-- | @GET \/api\/v1\/users\/{userId}\/clients@
-- 
-- Lists all client resources for which the specified user has grants or tokens.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUserClients
  :: UserId -- ^ "userId"
  -> OktaRequest ListUserClients MimeNoContent [OAuth2Client] MimeJSON
listUserClients (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/clients"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUserClients  
-- | @application/json@
instance Produces ListUserClients MimeJSON


-- *** listUserGrants

-- | @GET \/api\/v1\/users\/{userId}\/grants@
-- 
-- Lists all grants for the specified user
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUserGrants
  :: UserId -- ^ "userId"
  -> OktaRequest ListUserGrants MimeNoContent [OAuth2ScopeConsentGrant] MimeJSON
listUserGrants (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/grants"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUserGrants  
instance HasOptionalParam ListUserGrants ScopeId where
  applyOptionalParam req (ScopeId xs) =
    req `addQuery` toQuery ("scopeId", Just xs)
instance HasOptionalParam ListUserGrants Expand where
  applyOptionalParam req (Expand xs) =
    req `addQuery` toQuery ("expand", Just xs)
instance HasOptionalParam ListUserGrants After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListUserGrants Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListUserGrants MimeJSON


-- *** listUserGroups

-- | @GET \/api\/v1\/users\/{userId}\/groups@
-- 
-- Get Member Groups
-- 
-- Fetches the groups of which the user is a member.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUserGroups
  :: UserId -- ^ "userId"
  -> OktaRequest ListUserGroups MimeNoContent [Group] MimeJSON
listUserGroups (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/groups"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUserGroups  
-- | @application/json@
instance Produces ListUserGroups MimeJSON


-- *** listUserIdentityProviders

-- | @GET \/api\/v1\/users\/{userId}\/idps@
-- 
-- Listing IdPs associated with a user
-- 
-- Lists the IdPs associated with the user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUserIdentityProviders
  :: UserId -- ^ "userId"
  -> OktaRequest ListUserIdentityProviders MimeNoContent [IdentityProvider] MimeJSON
listUserIdentityProviders (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/idps"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUserIdentityProviders  
-- | @application/json@
instance Produces ListUserIdentityProviders MimeJSON


-- *** listUserSubscriptions

-- | @GET \/api\/v1\/users\/{userId}\/subscriptions@
-- 
-- List subscriptions of a User
-- 
-- List subscriptions of a User. Only lists subscriptions for current user. An AccessDeniedException message is sent if requests are made from other users.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUserSubscriptions
  :: UserId -- ^ "userId"
  -> OktaRequest ListUserSubscriptions MimeNoContent [Subscription] MimeJSON
listUserSubscriptions (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/subscriptions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUserSubscriptions  
-- | @application/json@
instance Produces ListUserSubscriptions MimeJSON


-- *** listUsers

-- | @GET \/api\/v1\/users@
-- 
-- List Users
-- 
-- Lists users in your organization with pagination in most cases.  A subset of users can be returned that match a supported filter expression or search criteria.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUsers
  :: OktaRequest ListUsers MimeNoContent [User] MimeJSON
listUsers =
  _mkRequest "GET" ["/api/v1/users"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUsers  

-- | /Optional Param/ "q" - Finds a user that matches firstName, lastName, and email properties
instance HasOptionalParam ListUsers Q where
  applyOptionalParam req (Q xs) =
    req `addQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "after" - Specifies the pagination cursor for the next page of users
instance HasOptionalParam ListUsers After where
  applyOptionalParam req (After xs) =
    req `addQuery` toQuery ("after", Just xs)

-- | /Optional Param/ "limit" - Specifies the number of results returned
instance HasOptionalParam ListUsers Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "filter" - Filters users with a supported expression for a subset of properties
instance HasOptionalParam ListUsers Filter where
  applyOptionalParam req (Filter xs) =
    req `addQuery` toQuery ("filter", Just xs)

-- | /Optional Param/ "search" - Searches for users with a supported filtering  expression for most properties
instance HasOptionalParam ListUsers Search where
  applyOptionalParam req (Search xs) =
    req `addQuery` toQuery ("search", Just xs)
instance HasOptionalParam ListUsers SortBy where
  applyOptionalParam req (SortBy xs) =
    req `addQuery` toQuery ("sortBy", Just xs)
instance HasOptionalParam ListUsers SortOrder where
  applyOptionalParam req (SortOrder xs) =
    req `addQuery` toQuery ("sortOrder", Just xs)
-- | @application/json@
instance Produces ListUsers MimeJSON


-- *** partialUpdateUser

-- | @POST \/api\/v1\/users\/{userId}@
-- 
-- Fetch a user by `id`, `login`, or `login shortname` if the short name is unambiguous.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
partialUpdateUser
  :: (Consumes PartialUpdateUser MimeJSON, MimeRender MimeJSON User)
  => User -- ^ "user"
  -> UserId -- ^ "userId"
  -> OktaRequest PartialUpdateUser MimeJSON User MimeJSON
partialUpdateUser user (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` user

data PartialUpdateUser 
instance HasBodyParam PartialUpdateUser User 
instance HasOptionalParam PartialUpdateUser Strict where
  applyOptionalParam req (Strict xs) =
    req `addQuery` toQuery ("strict", Just xs)

-- | @application/json@
instance Consumes PartialUpdateUser MimeJSON

-- | @application/json@
instance Produces PartialUpdateUser MimeJSON


-- *** reactivateUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/reactivate@
-- 
-- Reactivate User
-- 
-- Reactivates a user.  This operation can only be performed on users with a `PROVISIONED` status.  This operation restarts the activation workflow if for some reason the user activation was not completed when using the activationToken from [Activate User](#activate-user).
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
reactivateUser
  :: UserId -- ^ "userId"
  -> OktaRequest ReactivateUser MimeNoContent UserActivationToken MimeJSON
reactivateUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/reactivate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ReactivateUser  

-- | /Optional Param/ "sendEmail" - Sends an activation email to the user if true
instance HasOptionalParam ReactivateUser SendEmail where
  applyOptionalParam req (SendEmail xs) =
    req `addQuery` toQuery ("sendEmail", Just xs)
-- | @application/json@
instance Produces ReactivateUser MimeJSON


-- *** removeApplicationTargetFromAdministratorRoleForUser

-- | @DELETE \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/catalog\/apps\/{appName}\/{applicationId}@
-- 
-- Remove App Instance Target to App Administrator Role given to a User
-- 
-- Remove App Instance Target to App Administrator Role given to a User
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeApplicationTargetFromAdministratorRoleForUser
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> AppName -- ^ "appName"
  -> ApplicationId -- ^ "applicationId"
  -> OktaRequest RemoveApplicationTargetFromAdministratorRoleForUser MimeNoContent NoContent MimeNoContent
removeApplicationTargetFromAdministratorRoleForUser (UserId userId) (RoleId roleId) (AppName appName) (ApplicationId applicationId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/catalog/apps/",toPath appName,"/",toPath applicationId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveApplicationTargetFromAdministratorRoleForUser  
instance Produces RemoveApplicationTargetFromAdministratorRoleForUser MimeNoContent


-- *** removeApplicationTargetFromApplicationAdministratorRoleForUser

-- | @DELETE \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/catalog\/apps\/{appName}@
-- 
-- Success
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeApplicationTargetFromApplicationAdministratorRoleForUser
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> AppName -- ^ "appName"
  -> OktaRequest RemoveApplicationTargetFromApplicationAdministratorRoleForUser MimeNoContent NoContent MimeNoContent
removeApplicationTargetFromApplicationAdministratorRoleForUser (UserId userId) (RoleId roleId) (AppName appName) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/catalog/apps/",toPath appName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveApplicationTargetFromApplicationAdministratorRoleForUser  
instance Produces RemoveApplicationTargetFromApplicationAdministratorRoleForUser MimeNoContent


-- *** removeGroupTargetFromRole

-- | @DELETE \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/groups\/{groupId}@
-- 
-- Success
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeGroupTargetFromRole
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> GroupId -- ^ "groupId"
  -> OktaRequest RemoveGroupTargetFromRole MimeNoContent NoContent MimeNoContent
removeGroupTargetFromRole (UserId userId) (RoleId roleId) (GroupId groupId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/groups/",toPath groupId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveGroupTargetFromRole  
instance Produces RemoveGroupTargetFromRole MimeNoContent


-- *** removeLinkedObjectForUser

-- | @DELETE \/api\/v1\/users\/{userId}\/linkedObjects\/{relationshipName}@
-- 
-- Delete linked objects for a user, relationshipName can be ONLY a primary relationship name
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeLinkedObjectForUser
  :: UserId -- ^ "userId"
  -> RelationshipName -- ^ "relationshipName"
  -> OktaRequest RemoveLinkedObjectForUser MimeNoContent NoContent MimeNoContent
removeLinkedObjectForUser (UserId userId) (RelationshipName relationshipName) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/linkedObjects/",toPath relationshipName]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveLinkedObjectForUser  
instance Produces RemoveLinkedObjectForUser MimeNoContent


-- *** removeRoleFromUser

-- | @DELETE \/api\/v1\/users\/{userId}\/roles\/{roleId}@
-- 
-- Unassigns a role from a user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeRoleFromUser
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest RemoveRoleFromUser MimeNoContent NoContent MimeNoContent
removeRoleFromUser (UserId userId) (RoleId roleId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveRoleFromUser  
instance Produces RemoveRoleFromUser MimeNoContent


-- *** resetFactors

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/reset_factors@
-- 
-- Reset Factors
-- 
-- This operation resets all factors for the specified user. All MFA factor enrollments returned to the unenrolled state. The user's status remains ACTIVE. This link is present only if the user is currently enrolled in one or more MFA factors.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
resetFactors
  :: UserId -- ^ "userId"
  -> OktaRequest ResetFactors MimeNoContent NoContent MimeNoContent
resetFactors (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/reset_factors"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ResetFactors  
instance Produces ResetFactors MimeNoContent


-- *** resetPassword

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/reset_password@
-- 
-- Reset Password
-- 
-- Generates a one-time token (OTT) that can be used to reset a user's password.  The OTT link can be automatically emailed to the user or returned to the API caller and distributed using a custom flow.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
resetPassword
  :: UserId -- ^ "userId"
  -> SendEmail -- ^ "sendEmail"
  -> OktaRequest ResetPassword MimeNoContent ResetPasswordToken MimeJSON
resetPassword (UserId userId) (SendEmail sendEmail) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/reset_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `addQuery` toQuery ("sendEmail", Just sendEmail)

data ResetPassword  
-- | @application/json@
instance Produces ResetPassword MimeJSON


-- *** revokeGrantsForUserAndClient

-- | @DELETE \/api\/v1\/users\/{userId}\/clients\/{clientId}\/grants@
-- 
-- Revokes all grants for the specified user and client
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
revokeGrantsForUserAndClient
  :: UserId -- ^ "userId"
  -> ClientId -- ^ "clientId"
  -> OktaRequest RevokeGrantsForUserAndClient MimeNoContent NoContent MimeNoContent
revokeGrantsForUserAndClient (UserId userId) (ClientId clientId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/clients/",toPath clientId,"/grants"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RevokeGrantsForUserAndClient  
instance Produces RevokeGrantsForUserAndClient MimeNoContent


-- *** revokeTokenForUserAndClient

-- | @DELETE \/api\/v1\/users\/{userId}\/clients\/{clientId}\/tokens\/{tokenId}@
-- 
-- Revokes the specified refresh token.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
revokeTokenForUserAndClient
  :: UserId -- ^ "userId"
  -> ClientId -- ^ "clientId"
  -> TokenId -- ^ "tokenId"
  -> OktaRequest RevokeTokenForUserAndClient MimeNoContent NoContent MimeNoContent
revokeTokenForUserAndClient (UserId userId) (ClientId clientId) (TokenId tokenId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/clients/",toPath clientId,"/tokens/",toPath tokenId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RevokeTokenForUserAndClient  
instance Produces RevokeTokenForUserAndClient MimeNoContent


-- *** revokeTokensForUserAndClient

-- | @DELETE \/api\/v1\/users\/{userId}\/clients\/{clientId}\/tokens@
-- 
-- Revokes all refresh tokens issued for the specified User and Client.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
revokeTokensForUserAndClient
  :: UserId -- ^ "userId"
  -> ClientId -- ^ "clientId"
  -> OktaRequest RevokeTokensForUserAndClient MimeNoContent NoContent MimeNoContent
revokeTokensForUserAndClient (UserId userId) (ClientId clientId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/clients/",toPath clientId,"/tokens"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RevokeTokensForUserAndClient  
instance Produces RevokeTokensForUserAndClient MimeNoContent


-- *** revokeUserGrant

-- | @DELETE \/api\/v1\/users\/{userId}\/grants\/{grantId}@
-- 
-- Revokes one grant for a specified user
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
revokeUserGrant
  :: UserId -- ^ "userId"
  -> GrantId -- ^ "grantId"
  -> OktaRequest RevokeUserGrant MimeNoContent NoContent MimeNoContent
revokeUserGrant (UserId userId) (GrantId grantId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/grants/",toPath grantId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RevokeUserGrant  
instance Produces RevokeUserGrant MimeNoContent


-- *** revokeUserGrants

-- | @DELETE \/api\/v1\/users\/{userId}\/grants@
-- 
-- Revokes all grants for a specified user
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
revokeUserGrants
  :: UserId -- ^ "userId"
  -> OktaRequest RevokeUserGrants MimeNoContent NoContent MimeNoContent
revokeUserGrants (UserId userId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/grants"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RevokeUserGrants  
instance Produces RevokeUserGrants MimeNoContent


-- *** setLinkedObjectForUser

-- | @PUT \/api\/v1\/users\/{associatedUserId}\/linkedObjects\/{primaryRelationshipName}\/{primaryUserId}@
-- 
setLinkedObjectForUser
  :: AssociatedUserId -- ^ "associatedUserId"
  -> PrimaryRelationshipName -- ^ "primaryRelationshipName"
  -> PrimaryUserId -- ^ "primaryUserId"
  -> OktaRequest SetLinkedObjectForUser MimeNoContent NoContent MimeNoContent
setLinkedObjectForUser (AssociatedUserId associatedUserId) (PrimaryRelationshipName primaryRelationshipName) (PrimaryUserId primaryUserId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath associatedUserId,"/linkedObjects/",toPath primaryRelationshipName,"/",toPath primaryUserId]

data SetLinkedObjectForUser  
instance Produces SetLinkedObjectForUser MimeNoContent


-- *** suspendUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/suspend@
-- 
-- Suspend User
-- 
-- Suspends a user.  This operation can only be performed on users with an `ACTIVE` status.  The user will have a status of `SUSPENDED` when the process is complete.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
suspendUser
  :: UserId -- ^ "userId"
  -> OktaRequest SuspendUser MimeNoContent NoContent MimeNoContent
suspendUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/suspend"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data SuspendUser  
instance Produces SuspendUser MimeNoContent


-- *** unlockUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/unlock@
-- 
-- Unlock User
-- 
-- Unlocks a user with a `LOCKED_OUT` status and returns them to `ACTIVE` status.  Users will be able to login with their current password.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
unlockUser
  :: UserId -- ^ "userId"
  -> OktaRequest UnlockUser MimeNoContent NoContent MimeNoContent
unlockUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/unlock"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data UnlockUser  
instance Produces UnlockUser MimeNoContent


-- *** unsuspendUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/unsuspend@
-- 
-- Unsuspend User
-- 
-- Unsuspends a user and returns them to the `ACTIVE` state.  This operation can only be performed on users that have a `SUSPENDED` status.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
unsuspendUser
  :: UserId -- ^ "userId"
  -> OktaRequest UnsuspendUser MimeNoContent NoContent MimeNoContent
unsuspendUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/unsuspend"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data UnsuspendUser  
instance Produces UnsuspendUser MimeNoContent


-- *** updateUser

-- | @PUT \/api\/v1\/users\/{userId}@
-- 
-- Update User
-- 
-- Update a user's profile and/or credentials using strict-update semantics.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
updateUser
  :: (Consumes UpdateUser MimeJSON, MimeRender MimeJSON User)
  => User -- ^ "user"
  -> UserId -- ^ "userId"
  -> OktaRequest UpdateUser MimeJSON User MimeJSON
updateUser user (UserId userId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` user

data UpdateUser 
instance HasBodyParam UpdateUser User 
instance HasOptionalParam UpdateUser Strict where
  applyOptionalParam req (Strict xs) =
    req `addQuery` toQuery ("strict", Just xs)

-- | @application/json@
instance Consumes UpdateUser MimeJSON

-- | @application/json@
instance Produces UpdateUser MimeJSON

