{-
   Okta API

   Allows customers to easily access the Okta API

   OpenAPI Version: 3.0.1
   Okta API API version: 1.3.0
   Contact: devex-public@okta.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Okta.API.User
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Okta.API.User where

import Okta.Core
import Okta.MimeTypes
import Okta.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** User

-- *** activateUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/activate@
-- 
-- Activate User
-- 
-- Activates a user.  This operation can only be performed on users with a `STAGED` status.  Activation of a user is an asynchronous operation.  The user will have the `transitioningToStatus` property with a value of `ACTIVE` during activation to indicate that the user hasn't completed the asynchronous operation.  The user will have a status of `ACTIVE` when the activation process is complete.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
activateUser 
  :: UserId -- ^ "userId"
  -> SendEmail -- ^ "sendEmail" -  Sends an activation email to the user if true
  -> OktaRequest ActivateUser MimeNoContent UserActivationToken MimeJSON
activateUser (UserId userId) (SendEmail sendEmail) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/activate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setQuery` toQuery ("sendEmail", Just sendEmail)

data ActivateUser  
-- | @application/json@
instance Produces ActivateUser MimeJSON


-- *** addGroupTargetToRole

-- | @PUT \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/groups\/{groupId}@
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
addGroupTargetToRole 
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> GroupId -- ^ "groupId"
  -> OktaRequest AddGroupTargetToRole MimeNoContent NoContent MimeNoContent
addGroupTargetToRole (UserId userId) (RoleId roleId) (GroupId groupId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/groups/",toPath groupId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data AddGroupTargetToRole  
instance Produces AddGroupTargetToRole MimeNoContent


-- *** addRoleToUser

-- | @POST \/api\/v1\/users\/{userId}\/roles@
-- 
-- Assigns a role to a user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
addRoleToUser 
  :: (Consumes AddRoleToUser MimeJSON, MimeRender MimeJSON Role)
  => Role -- ^ "role"
  -> UserId -- ^ "userId"
  -> OktaRequest AddRoleToUser MimeJSON Role MimeJSON
addRoleToUser role (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` role

data AddRoleToUser 
instance HasBodyParam AddRoleToUser Role 

-- | @application/json@
instance Consumes AddRoleToUser MimeJSON

-- | @application/json@
instance Produces AddRoleToUser MimeJSON


-- *** changePassword

-- | @POST \/api\/v1\/users\/{userId}\/credentials\/change_password@
-- 
-- Change Password
-- 
-- Changes a user's password by validating the user's current password.  This operation can only be performed on users in `STAGED`, `ACTIVE`, `PASSWORD_EXPIRED`, or `RECOVERY` status that have a valid [password credential](#password-object)
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
changePassword 
  :: (Consumes ChangePassword MimeJSON, MimeRender MimeJSON ChangePasswordRequest)
  => ChangePasswordRequest -- ^ "changePasswordRequest"
  -> UserId -- ^ "userId"
  -> OktaRequest ChangePassword MimeJSON UserCredentials MimeJSON
changePassword changePasswordRequest (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/credentials/change_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` changePasswordRequest

data ChangePassword 
instance HasBodyParam ChangePassword ChangePasswordRequest 

-- | @application/json@
instance Consumes ChangePassword MimeJSON

-- | @application/json@
instance Produces ChangePassword MimeJSON


-- *** changeRecoveryQuestion

-- | @POST \/api\/v1\/users\/{userId}\/credentials\/change_recovery_question@
-- 
-- Change Recovery Question
-- 
-- Changes a user's recovery question & answer credential by validating the user's current password.  This operation can only be performed on users in **STAGED**, **ACTIVE** or **RECOVERY** `status` that have a valid [password credential](#password-object)
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
changeRecoveryQuestion 
  :: (Consumes ChangeRecoveryQuestion MimeJSON, MimeRender MimeJSON UserCredentials)
  => UserCredentials -- ^ "userCredentials"
  -> UserId -- ^ "userId"
  -> OktaRequest ChangeRecoveryQuestion MimeJSON UserCredentials MimeJSON
changeRecoveryQuestion userCredentials (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/credentials/change_recovery_question"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` userCredentials

data ChangeRecoveryQuestion 
instance HasBodyParam ChangeRecoveryQuestion UserCredentials 

-- | @application/json@
instance Consumes ChangeRecoveryQuestion MimeJSON

-- | @application/json@
instance Produces ChangeRecoveryQuestion MimeJSON


-- *** createUser

-- | @POST \/api\/v1\/users@
-- 
-- Create User
-- 
-- Creates a new user in your Okta organization with or without credentials.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
createUser 
  :: (Consumes CreateUser MimeJSON, MimeRender MimeJSON User)
  => User -- ^ "body"
  -> OktaRequest CreateUser MimeJSON User MimeJSON
createUser body =
  _mkRequest "POST" ["/api/v1/users"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` body

data CreateUser 
instance HasBodyParam CreateUser User 

-- | /Optional Param/ "activate" - Executes activation lifecycle operation when creating the user
instance HasOptionalParam CreateUser Activate where
  applyOptionalParam req (Activate xs) =
    req `setQuery` toQuery ("activate", Just xs)

-- | /Optional Param/ "provider" - Indicates whether to create a user with a specified authentication provider
instance HasOptionalParam CreateUser Provider where
  applyOptionalParam req (Provider xs) =
    req `setQuery` toQuery ("provider", Just xs)

-- | /Optional Param/ "nextLogin" - With activate=true, set nextLogin to \"changePassword\" to have the password be EXPIRED, so user must change it the next time they log in.
instance HasOptionalParam CreateUser NextLogin where
  applyOptionalParam req (NextLogin xs) =
    req `setQuery` toQuery ("nextLogin", Just xs)

-- | @application/json@
instance Consumes CreateUser MimeJSON

-- | @application/json@
instance Produces CreateUser MimeJSON


-- *** deactivateOrDeleteUser

-- | @DELETE \/api\/v1\/users\/{userId}@
-- 
-- Delete User
-- 
-- Deletes a user permanently.  This operation can only be performed on users that have a `DEPROVISIONED` status.  **This action cannot be recovered!**
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
deactivateOrDeleteUser 
  :: UserId -- ^ "userId"
  -> OktaRequest DeactivateOrDeleteUser MimeNoContent NoContent MimeNoContent
deactivateOrDeleteUser (UserId userId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data DeactivateOrDeleteUser  
instance Produces DeactivateOrDeleteUser MimeNoContent


-- *** deactivateUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/deactivate@
-- 
-- Deactivate User
-- 
-- Deactivates a user.  This operation can only be performed on users that do not have a `DEPROVISIONED` status.  Deactivation of a user is an asynchronous operation.  The user will have the `transitioningToStatus` property with a value of `DEPROVISIONED` during deactivation to indicate that the user hasn't completed the asynchronous operation.  The user will have a status of `DEPROVISIONED` when the deactivation process is complete.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
deactivateUser 
  :: UserId -- ^ "userId"
  -> OktaRequest DeactivateUser MimeNoContent NoContent MimeNoContent
deactivateUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/deactivate"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data DeactivateUser  
instance Produces DeactivateUser MimeNoContent


-- *** endAllUserSessions

-- | @DELETE \/api\/v1\/users\/{userId}\/sessions@
-- 
-- Removes all active identity provider sessions. This forces the user to authenticate on the next operation. Optionally revokes OpenID Connect and OAuth refresh and access tokens issued to the user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
endAllUserSessions 
  :: UserId -- ^ "userId"
  -> OktaRequest EndAllUserSessions MimeNoContent NoContent MimeNoContent
endAllUserSessions (UserId userId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/sessions"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data EndAllUserSessions  

-- | /Optional Param/ "oauthTokens" - Revoke issued OpenID Connect and OAuth refresh and access tokens
instance HasOptionalParam EndAllUserSessions OauthTokens where
  applyOptionalParam req (OauthTokens xs) =
    req `setQuery` toQuery ("oauthTokens", Just xs)
instance Produces EndAllUserSessions MimeNoContent


-- *** expirePassword

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/expire_password@
-- 
-- Expire Password
-- 
-- This operation transitions the user to the status of `PASSWORD_EXPIRED` so that the user is required to change their password at their next login.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
expirePassword 
  :: UserId -- ^ "userId"
  -> OktaRequest ExpirePassword MimeNoContent TempPassword MimeJSON
expirePassword (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/expire_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ExpirePassword  

-- | /Optional Param/ "tempPassword" - Sets the user's password to a temporary password,  if true
instance HasOptionalParam ExpirePassword TempPassword2 where
  applyOptionalParam req (TempPassword2 xs) =
    req `setQuery` toQuery ("tempPassword", Just xs)
-- | @application/json@
instance Produces ExpirePassword MimeJSON


-- *** forgotPassword

-- | @POST \/api\/v1\/users\/{userId}\/credentials\/forgot_password@
-- 
-- Forgot Password
-- 
-- Generates a one-time token (OTT) that can be used to reset a user's password.  The user will be required to validate their security question's answer when visiting the reset link.  This operation can only be performed on users with a valid [recovery question credential](#recovery-question-object) and have an `ACTIVE` status.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
forgotPassword 
  :: (Consumes ForgotPassword MimeJSON)
  => UserId -- ^ "userId"
  -> OktaRequest ForgotPassword MimeJSON ForgotPasswordResponse MimeJSON
forgotPassword (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/credentials/forgot_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ForgotPassword 
instance HasBodyParam ForgotPassword UserCredentials 
instance HasOptionalParam ForgotPassword SendEmail where
  applyOptionalParam req (SendEmail xs) =
    req `setQuery` toQuery ("sendEmail", Just xs)

-- | @application/json@
instance Consumes ForgotPassword MimeJSON

-- | @application/json@
instance Produces ForgotPassword MimeJSON


-- *** getUser

-- | @GET \/api\/v1\/users\/{userId}@
-- 
-- Get User
-- 
-- Fetches a user from your Okta organization.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
getUser 
  :: UserId -- ^ "userId"
  -> OktaRequest GetUser MimeNoContent User MimeJSON
getUser (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data GetUser  
-- | @application/json@
instance Produces GetUser MimeJSON


-- *** listAppLinks

-- | @GET \/api\/v1\/users\/{userId}\/appLinks@
-- 
-- Get Assigned App Links
-- 
-- Fetches appLinks for all direct or indirect (via group membership) assigned applications.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listAppLinks 
  :: UserId -- ^ "userId"
  -> OktaRequest ListAppLinks MimeNoContent [AppLink] MimeJSON
listAppLinks (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/appLinks"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListAppLinks  
instance HasOptionalParam ListAppLinks ShowAll where
  applyOptionalParam req (ShowAll xs) =
    req `setQuery` toQuery ("showAll", Just xs)
-- | @application/json@
instance Produces ListAppLinks MimeJSON


-- *** listAssignedRoles

-- | @GET \/api\/v1\/users\/{userId}\/roles@
-- 
-- Lists all roles assigned to a user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listAssignedRoles 
  :: UserId -- ^ "userId"
  -> OktaRequest ListAssignedRoles MimeNoContent [Role] MimeJSON
listAssignedRoles (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/roles"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListAssignedRoles  
instance HasOptionalParam ListAssignedRoles Expand where
  applyOptionalParam req (Expand xs) =
    req `setQuery` toQuery ("expand", Just xs)
-- | @application/json@
instance Produces ListAssignedRoles MimeJSON


-- *** listGroupTargetsForRole

-- | @GET \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/groups@
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listGroupTargetsForRole 
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest ListGroupTargetsForRole MimeNoContent [Group] MimeJSON
listGroupTargetsForRole (UserId userId) (RoleId roleId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/groups"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListGroupTargetsForRole  
instance HasOptionalParam ListGroupTargetsForRole After where
  applyOptionalParam req (After xs) =
    req `setQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListGroupTargetsForRole Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListGroupTargetsForRole MimeJSON


-- *** listUserGroups

-- | @GET \/api\/v1\/users\/{userId}\/groups@
-- 
-- Get Member Groups
-- 
-- Fetches the groups of which the user is a member.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUserGroups 
  :: UserId -- ^ "userId"
  -> OktaRequest ListUserGroups MimeNoContent [Group] MimeJSON
listUserGroups (UserId userId) =
  _mkRequest "GET" ["/api/v1/users/",toPath userId,"/groups"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUserGroups  
instance HasOptionalParam ListUserGroups After where
  applyOptionalParam req (After xs) =
    req `setQuery` toQuery ("after", Just xs)
instance HasOptionalParam ListUserGroups Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)
-- | @application/json@
instance Produces ListUserGroups MimeJSON


-- *** listUsers

-- | @GET \/api\/v1\/users@
-- 
-- List Users
-- 
-- Lists users in your organization with pagination in most cases.  A subset of users can be returned that match a supported filter expression or search criteria.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
listUsers 
  :: OktaRequest ListUsers MimeNoContent [User] MimeJSON
listUsers =
  _mkRequest "GET" ["/api/v1/users"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ListUsers  

-- | /Optional Param/ "q" - Finds a user that matches firstName, lastName, and email properties
instance HasOptionalParam ListUsers Q where
  applyOptionalParam req (Q xs) =
    req `setQuery` toQuery ("q", Just xs)

-- | /Optional Param/ "after" - Specifies the pagination cursor for the next page of users
instance HasOptionalParam ListUsers After where
  applyOptionalParam req (After xs) =
    req `setQuery` toQuery ("after", Just xs)

-- | /Optional Param/ "limit" - Specifies the number of results returned
instance HasOptionalParam ListUsers Limit where
  applyOptionalParam req (Limit xs) =
    req `setQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "filter" - Filters users with a supported expression for a subset of properties
instance HasOptionalParam ListUsers Filter where
  applyOptionalParam req (Filter xs) =
    req `setQuery` toQuery ("filter", Just xs)
instance HasOptionalParam ListUsers Format where
  applyOptionalParam req (Format xs) =
    req `setQuery` toQuery ("format", Just xs)

-- | /Optional Param/ "search" - Searches for users with a supported filtering  expression for most properties
instance HasOptionalParam ListUsers Search where
  applyOptionalParam req (Search xs) =
    req `setQuery` toQuery ("search", Just xs)
instance HasOptionalParam ListUsers Expand where
  applyOptionalParam req (Expand xs) =
    req `setQuery` toQuery ("expand", Just xs)
-- | @application/json@
instance Produces ListUsers MimeJSON


-- *** removeGroupTargetFromRole

-- | @DELETE \/api\/v1\/users\/{userId}\/roles\/{roleId}\/targets\/groups\/{groupId}@
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeGroupTargetFromRole 
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> GroupId -- ^ "groupId"
  -> OktaRequest RemoveGroupTargetFromRole MimeNoContent NoContent MimeNoContent
removeGroupTargetFromRole (UserId userId) (RoleId roleId) (GroupId groupId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId,"/targets/groups/",toPath groupId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveGroupTargetFromRole  
instance Produces RemoveGroupTargetFromRole MimeNoContent


-- *** removeRoleFromUser

-- | @DELETE \/api\/v1\/users\/{userId}\/roles\/{roleId}@
-- 
-- Unassigns a role from a user.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
removeRoleFromUser 
  :: UserId -- ^ "userId"
  -> RoleId -- ^ "roleId"
  -> OktaRequest RemoveRoleFromUser MimeNoContent NoContent MimeNoContent
removeRoleFromUser (UserId userId) (RoleId roleId) =
  _mkRequest "DELETE" ["/api/v1/users/",toPath userId,"/roles/",toPath roleId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data RemoveRoleFromUser  
instance Produces RemoveRoleFromUser MimeNoContent


-- *** resetAllFactors

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/reset_factors@
-- 
-- Reset Factors
-- 
-- This operation resets all factors for the specified user. All MFA factor enrollments returned to the unenrolled state. The user's status remains ACTIVE. This link is present only if the user is currently enrolled in one or more MFA factors.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
resetAllFactors 
  :: UserId -- ^ "userId"
  -> OktaRequest ResetAllFactors MimeNoContent NoContent MimeNoContent
resetAllFactors (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/reset_factors"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ResetAllFactors  
instance Produces ResetAllFactors MimeNoContent


-- *** resetPassword

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/reset_password@
-- 
-- Reset Password
-- 
-- Generates a one-time token (OTT) that can be used to reset a user's password.  The OTT link can be automatically emailed to the user or returned to the API caller and distributed using a custom flow.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
resetPassword 
  :: UserId -- ^ "userId"
  -> OktaRequest ResetPassword MimeNoContent ResetPasswordToken MimeJSON
resetPassword (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/reset_password"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data ResetPassword  
instance HasOptionalParam ResetPassword ProviderText where
  applyOptionalParam req (ProviderText xs) =
    req `setQuery` toQuery ("provider", Just xs)
instance HasOptionalParam ResetPassword SendEmail where
  applyOptionalParam req (SendEmail xs) =
    req `setQuery` toQuery ("sendEmail", Just xs)
-- | @application/json@
instance Produces ResetPassword MimeJSON


-- *** suspendUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/suspend@
-- 
-- Suspend User
-- 
-- Suspends a user.  This operation can only be performed on users with an `ACTIVE` status.  The user will have a status of `SUSPENDED` when the process is complete.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
suspendUser 
  :: UserId -- ^ "userId"
  -> OktaRequest SuspendUser MimeNoContent NoContent MimeNoContent
suspendUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/suspend"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data SuspendUser  
instance Produces SuspendUser MimeNoContent


-- *** unlockUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/unlock@
-- 
-- Unlock User
-- 
-- Unlocks a user with a `LOCKED_OUT` status and returns them to `ACTIVE` status.  Users will be able to login with their current password.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
unlockUser 
  :: UserId -- ^ "userId"
  -> OktaRequest UnlockUser MimeNoContent NoContent MimeNoContent
unlockUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/unlock"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data UnlockUser  
instance Produces UnlockUser MimeNoContent


-- *** unsuspendUser

-- | @POST \/api\/v1\/users\/{userId}\/lifecycle\/unsuspend@
-- 
-- Unsuspend User
-- 
-- Unsuspends a user and returns them to the `ACTIVE` state.  This operation can only be performed on users that have a `SUSPENDED` status.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
unsuspendUser 
  :: UserId -- ^ "userId"
  -> OktaRequest UnsuspendUser MimeNoContent NoContent MimeNoContent
unsuspendUser (UserId userId) =
  _mkRequest "POST" ["/api/v1/users/",toPath userId,"/lifecycle/unsuspend"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)

data UnsuspendUser  
instance Produces UnsuspendUser MimeNoContent


-- *** updateUser

-- | @PUT \/api\/v1\/users\/{userId}@
-- 
-- Update User
-- 
-- Update a user's profile and/or credentials using strict-update semantics.
-- 
-- AuthMethod: 'AuthApiKeyApiToken'
-- 
updateUser 
  :: (Consumes UpdateUser MimeJSON, MimeRender MimeJSON User)
  => User -- ^ "user"
  -> UserId -- ^ "userId"
  -> OktaRequest UpdateUser MimeJSON User MimeJSON
updateUser user (UserId userId) =
  _mkRequest "PUT" ["/api/v1/users/",toPath userId]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyApiToken)
    `setBodyParam` user

data UpdateUser 
instance HasBodyParam UpdateUser User 

-- | @application/json@
instance Consumes UpdateUser MimeJSON

-- | @application/json@
instance Produces UpdateUser MimeJSON

